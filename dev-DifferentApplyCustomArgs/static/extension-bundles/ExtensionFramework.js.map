{"version":3,"file":"ExtensionFramework.js","sources":["../../../../extensions/src/common/types/enums.ts","../../../../extensions/scripts/node_modules/tslib/tslib.es6.js","../../../../extensions/src/common/utils.ts","../../../../extensions/src/common/globals.ts","../../../../extensions/src/common/ui.ts","../../../../extensions/src/common/IDs.ts","../../../../extensions/src/common/extension/mixins/configurable/customSaveData.ts","../../../scratch-vm/src/util/color.js","../../../scratch-vm/src/util/cast.js","../../../../extensions/src/common/cast.ts","../../../../extensions/src/common/extension/mixins/configurable/customArguments/CustomArgumentManager.ts","../../../../extensions/src/common/extension/mixins/configurable/addCostumes/MockBitmapAdapter.ts","../../../../extensions/src/common/extension/mixins/configurable/addCostumes/index.ts","../../../../extensions/src/common/extension/mixins/dependencies.ts","../../../../extensions/src/common/extension/mixins/configurable/customArguments/utils.ts","../../../../extensions/src/common/extension/mixins/base/scratchInfo/menus.ts","../../../../extensions/src/common/extension/mixins/base/scratchInfo/util.ts","../../../../extensions/src/common/extension/mixins/base/scratchInfo/handlers.ts","../../../../extensions/src/common/extension/mixins/base/scratchInfo/args.ts","../../../../extensions/src/common/extension/mixins/base/scratchInfo/text.ts","../../../../extensions/src/common/extension/mixins/base/scratchInfo/index.ts","../../../../extensions/src/common/extension/decorators/blocks.ts","../../../../extensions/src/common/extension/decorators/legacySupport/index.ts","../../../../extensions/src/common/extension/mixins/configurable/legacySupport.ts","../../../../extensions/src/common/extension/mixins/configurable/indicators/svgAlert.ts","../../../../extensions/src/common/extension/mixins/configurable/indicators/index.ts","../../../../extensions/src/common/extension/mixins/configurable/video.ts","../../../../extensions/src/common/extension/mixins/index.ts","../../../../extensions/src/common/extension/mixins/configurable/customArguments/index.ts","../../../../extensions/src/common/extension/mixins/configurable/ui.ts","../../../../extensions/src/common/extension/mixins/configurable/drawable.ts","../../../../extensions/src/common/extension/mixins/configurable/addCostumes/utils.ts","../../../../extensions/src/common/extension/mixins/configurable/blocks/setVideoTransparency.ts","../../../../extensions/src/common/extension/mixins/configurable/blocks/toggleVideoState.ts","../../../../extensions/src/common/extension/mixins/configurable/appInventor/index.ts","../../../../extensions/src/common/extension/ExtensionBase.ts","../../../../extensions/src/common/extension/mixins/base/supported.ts","../../../../extensions/src/common/extension/index.ts","../../../../extensions/src/common/extension/GenericExtension.ts","../../../../extensions/src/common/extension/decorators/validators.ts"],"sourcesContent":["import { ValueOf } from \"../types\";\n\n/**\n * The different kind of blocks that an extension can define\n */\nexport const BlockType = {\n  /**\n   * Boolean reporter with hexagonal shape\n   */\n  Boolean: 'Boolean',\n\n  /**\n   * A button (not an actual block) for some special action, like making a variable\n   */\n  Button: 'button',\n\n  /**\n   * Command block\n   */\n  Command: 'command',\n\n  /**\n   * Specialized command block which may or may not run a child branch\n   * The thread continues with the next block whether or not a child branch ran.\n   */\n  Conditional: 'conditional',\n\n  /**\n   * Specialized hat block with no implementation function\n   * This stack only runs if the corresponding event is emitted by other code.\n   */\n  Event: 'event',\n\n  /**\n   * Hat block which conditionally starts a block stack\n   */\n  Hat: 'hat',\n\n  /**\n   * Specialized command block which may or may not run a child branch\n   * If a child branch runs, the thread evaluates the loop block again.\n   */\n  Loop: 'loop',\n\n  /**\n   * General reporter with numeric or string value\n   */\n  Reporter: 'reporter'\n} as const;\n\nexport const ArgumentType = {\n  /** Numeric value with angle picker. */\n  Angle: \"angle\",\n\n  /** Boolean value with hexagonal placeholder. */\n  Boolean: \"Boolean\",\n\n  /** Numeric value with color picker. */\n  Color: \"color\",\n\n  /** Numeric value with text field. */\n  Number: \"number\",\n\n  /** String value with text field. */\n  String: \"string\",\n\n  /** String value with matrix field. */\n  Matrix: \"matrix\",\n\n  /** MIDI note number with note picker (piano) field. */\n  Note: \"note\",\n\n  /** Inline image on block (as part of the label). */\n  Image: \"image\",\n\n  /** Type added by PRG to support custom arguments */\n  Custom: \"custom\"\n} as const;\n\n/**\n * Default types of Target supported by the VM\n * @enum {string} as const;\n */\nexport const TargetType = {\n  /**\n   * Rendered target which can move, change costumes, etc.\n   */\n  Sprite: 'sprite',\n\n  /**\n   * Rendered target which cannot move but can change backdrops\n   */\n  Stage: 'stage'\n} as const;\n\n/**\n * These constants are copied from scratch-blocks/core/constants.js\n * @TODO find a way to require() these straight from scratch-blocks... maybe make a scratch-blocks/dist/constants.js?\n * @readonly\n * @enum {int} as const;\n */\nexport const ScratchBlocksConstants = {\n  /**\n   * ENUM for output shape: hexagonal (booleans/predicates).\n   * @const\n   */\n  OutputShapeHexagonal: 1,\n\n  /**\n   * ENUM for output shape: rounded (numbers).\n   * @const\n   */\n  OutputShapeRound: 2,\n\n  /**\n   * ENUM for output shape: squared (any/all values; strings).\n   * @const\n   */\n  OutputShapeSquare: 3\n} as const;\n\nexport const StageLayering = {\n  BackgroundLayer: 'background',\n  VideoLayer: 'video',\n  PenLayer: 'pen',\n  SpriteLayer: 'sprite',\n} as const;\n\nexport const LayerGroups: readonly ValueOf<typeof StageLayering>[] = [\n  StageLayering.VideoLayer,\n  StageLayering.SpriteLayer,\n  StageLayering.BackgroundLayer,\n  StageLayering.PenLayer,\n] as const;\n\nexport const VariableType = {\n  /**\n   * Type representation for scalar variables.\n   * This is currently represented as ''\n   * for compatibility with blockly.\n   */\n  Scalar: '',\n  /**\n   * Type representation for list variables.\n   */\n  List: 'list',\n\n  BrooadcastMessage: 'broadcast_msg'\n} as const;\n\nexport const Branch = {\n  Exit: 0,\n  Enter: 1,\n  First: 1,\n  Second: 2,\n  Third: 3,\n  Fourth: 4,\n  Fifth: 5,\n  Sixth: 6,\n  Seventh: 7\n} as const;\n\nexport const Language = {\n  Аҧсшәа: 'ab',\n  العربية: 'ar',\n  አማርኛ: 'am',\n  Azeri: 'az',\n  Bahasa_Indonesia: 'id',\n  Беларуская: 'be',\n  Български: 'bg',\n  Català: 'ca',\n  Česky: 'cs',\n  Cymraeg: 'cy',\n  Dansk: 'da',\n  Deutsch: 'de',\n  Eesti: 'et',\n  Ελληνικά: 'el',\n  English: 'en',\n  Español: 'es',\n  Español_Latinoamericano: 'es-419',\n  Euskara: 'eu',\n  فارسی: 'fa',\n  Français: 'fr',\n  Gaeilge: 'ga',\n  Gàidhlig: 'gd',\n  Galego: 'gl',\n  한국어: 'ko',\n  עִבְרִית: 'he',\n  Hrvatski: 'hr',\n  isiZulu: 'zu',\n  Íslenska: 'is',\n  Italiano: 'it',\n  ქართული_ენა: 'ka',\n  Kiswahili: 'sw',\n  Kreyòl_ayisyen: 'ht',\n  کوردیی_ناوەندی: 'ckb',\n  Latviešu: 'lv',\n  Lietuvių: 'lt',\n  Magyar: 'hu',\n  Māori: 'mi',\n  Nederlands: 'nl',\n  日本語: 'ja',\n  にほんご: 'ja-Hira',\n  Norsk_Bokmål: 'nb',\n  Norsk_Nynorsk: 'nn',\n  Oʻzbekcha: 'uz',\n  ไทย: 'th',\n  ភាសាខ្មែរ: 'km',\n  Polski: 'pl',\n  Português: 'pt',\n  Português_Brasileiro: 'pt-br',\n  Rapa_Nui: 'rap',\n  Română: 'ro',\n  Русский: 'ru',\n  Српски: 'sr',\n  Slovenčina: 'sk',\n  Slovenščina: 'sl',\n  Suomi: 'fi',\n  Svenska: 'sv',\n  Tiếng_Việt: 'vi',\n  Türkçe: 'tr',\n  Українська: 'uk',\n  简体中文: 'zh-cn',\n  繁體中文: 'zh-tw'\n} as const;\n\nexport const LanguageKeys = Object.keys(Language);\n\nexport const RuntimeEvent = {\n  /**\n   * Event name for glowing a script.\n   */\n  ScriptGlowOn: 'SCRIPT_GLOW_ON',\n  /**\n   * Event name for unglowing a script.\n   */\n  ScriptGlowOff: 'SCRIPT_GLOW_OFF',\n  /**\n   * Event name for glowing a block.\n   */\n  BlockGlowOn: 'BLOCK_GLOW_ON',\n  /**\n   * Event name for unglowing a block.\n   */\n  BlockGlowOff: 'BLOCK_GLOW_OFF',\n  /**\n   * Event name for a cloud data update to this project.\n   */\n  HasCloudDataUpdate: 'HAS_CLOUD_DATA_UPDATE',\n  /**\n   * Event name for turning on turbo mode.\n   */\n  TurboModeOn: 'TURBO_MODE_ON',\n  /**\n   * Event name for turning off turbo mode.\n   */\n  TurboModeOff: 'TURBO_MODE_OFF',\n  /**\n   * Event name for turning on turbo mode.\n   */\n  RecordingOn: 'RECORDING_ON',\n  /**\n   * Event name for turning off turbo mode.\n   */\n  RecordingOff: 'RECORDING_OFF',\n  /**\n   * Event name when the project is started (threads may not necessarily be running).\n   */\n  ProjectStart: 'PROJECT_START',\n  /**\n   * Event name when threads start running.\n   * Used by the UI to indicate running status.\n   */\n  ProjectRunStart: 'PROJECT_RUN_START',\n  /**\n   * Event name when threads stop running\n   * Used by the UI to indicate not-running status.\n   */\n  ProjectRunStop: 'PROJECT_RUN_STOP',\n  /**\n   * Event name for project being stopped or restarted by the user.\n   * Used by blocks that need to reset state.\n   */\n  ProjectStopAll: 'PROJECT_STOP_ALL',\n  /**\n   * Event name for target being stopped by a stop for target call.\n   * Used by blocks that need to stop individual targets.\n   */\n  StopForTarget: 'STOP_FOR_TARGET',\n  /**\n   * Event name for visual value report.\n   */\n  VisualReport: 'VISUAL_REPORT',\n  /**\n   * Event name for project loaded report.\n   */\n  ProjectLoaded: 'PROJECT_LOADED',\n  /**\n   * Event name for report that a change was made that can be saved\n   */\n  ProjectChanged: 'PROJECT_CHANGED',\n  /**\n   * Event name for report that a change was made to an extension in the toolbox.\n   */\n  ToolboxExtensionsNeedUpdate: 'TOOLBOX_EXTENSIONS_NEED_UPDATE',\n  /**\n   * Event name for targets update report.\n   */\n  TargetsUpdate: 'TARGETS_UPDATE',\n  /**\n   * Event name for monitors update.\n   */\n  MonitorsUpdate: 'MONITORS_UPDATE',\n  /**\n   * Event name for block drag update.\n   */\n  BlockDragUpdate: 'BLOCK_DRAG_UPDATE',\n  /**\n   * Event name for block drag end.\n   */\n  BlockDragEnd: 'BLOCK_DRAG_END',\n  /**\n   * Event name for reporting that an extension was added.\n   */\n  ExtensionAdded: 'EXTENSION_ADDED',\n  /**\n   * Event name for reporting that an extension as asked for a custom field to be added\n   */\n  ExtensionFieldAdded: 'EXTENSION_FIELD_ADDED',\n  /**\n   * Event name for updating the available set of peripheral devices.\n   * This causes the peripheral connection modal to update a list of available peripherals.\n   */\n  PeripheralListUpdate: 'PERIPHERAL_LIST_UPDATE',\n  /**\n   * Event name for reporting that a peripheral has connected.\n   * This causes the status button in the blocks menu to indicate 'connected'.\n   */\n  PeripheralConnected: 'PERIPHERAL_CONNECTED',\n  /**\n   * Event name for reporting that a peripheral has been intentionally disconnected.\n   * This causes the status button in the blocks menu to indicate 'disconnected'.\n   */\n  PeripheralDisconnected: 'PERIPHERAL_DISCONNECTED',\n  /**\n   * Event name for reporting that a peripheral has encountered a request error.\n   * This causes the peripheral connection modal to switch to an error state.\n   */\n  PeripheralRequestError: 'PERIPHERAL_REQUEST_ERROR',\n  /**\n   * Event name for reporting that a peripheral connection has been lost.\n   * This causes a 'peripheral connection lost' error alert to display.\n   */\n  PeripheralConnectionLostError: 'PERIPHERAL_CONNECTION_LOST_ERROR',\n  /**\n   * Event name for reporting that a peripheral has not been discovered.\n   * This causes the peripheral connection modal to show a timeout state.\n   */\n  PeripheralScanTimeout: 'PERIPHERAL_SCAN_TIMEOUT',\n  /**\n   * Event name to indicate that the microphone is being used to stream audio.\n   */\n  MicListening: 'MIC_LISTENING',\n  /**\n   * Event name for reporting that blocksInfo was updated.\n   */\n  BlocksInfoUpdate: 'BLOCKSINFO_UPDATE',\n  /**\n   * Event name when the runtime tick loop has been started.\n   */\n  RuntimeStarted: 'RUNTIME_STARTED',\n  /**\n   * Event name when the runtime dispose has been called.\n   */\n  RuntimeDisposed: 'RUNTIME_DISPOSED',\n  /**\n   * Event name for reporting that a block was updated and needs to be rerendered.\n   */\n  BlocksNeedUpdate: 'BLOCKS_NEED_UPDATE',\n} as const;\n","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.push(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.push(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n","import { MenuItem, Primitive, RGBObject } from \"./types\"\n\ntype FetchParams = {\n  request: Parameters<typeof fetch>[0],\n  options: Parameters<typeof fetch>[1]\n}\n\nexport const getValueFromMenuItem = <T>(item: MenuItem<T>) => typeof item === \"object\" ? (item as { value: T }).value : item;\n\nexport const getTextFromMenuItem = <T>(item: MenuItem<T>) => typeof item === \"object\" ? (item as { text: string }).text : item;\n\nexport async function fetchWithTimeout(\n  resource: FetchParams[\"request\"],\n  options: FetchParams[\"options\"] & { timeout: number }\n) {\n  const { timeout } = options;\n\n  const controller = new AbortController();\n  const id = setTimeout(() => controller.abort(), timeout);\n\n  const response = await fetch(resource, {\n    ...options,\n    signal: controller.signal\n  });\n\n  clearTimeout(id);\n\n  return response;\n}\n\n/**\n * A utility to wait a certain amount of milliseconds in an async function.\n * @param timeMs \n * @returns \n */\nexport async function untilTimePassed(timeMs: number) {\n  let timeout: NodeJS.Timeout;\n  return await new Promise<void>(\n    (resolve) =>\n      timeout = setTimeout(\n        () => {\n          clearTimeout(timeout);\n          resolve();\n        },\n        timeMs)\n  );\n}\n\nexport async function untilObject<T>(getter: () => T, delay: number = 100): Promise<T> {\n  let timeout: NodeJS.Timeout;\n  let value: T = getter();\n  while (!value) {\n    await new Promise(resolve => {\n      clearTimeout(timeout);\n      timeout = setTimeout(resolve, delay);\n    });\n    value = getter();\n  }\n  clearTimeout(timeout);\n  return value;\n}\n\nexport async function untilCondition(condition: () => boolean, delay: number = 100): Promise<void> {\n  let timeout: NodeJS.Timeout;\n  while (!condition()) {\n    await new Promise(resolve => {\n      clearTimeout(timeout);\n      timeout = setTimeout(resolve, delay);\n    });\n  }\n  clearTimeout(timeout);\n};\n\nexport async function untilReady<T extends { ready: boolean }>(obj: T, delay: number = 100): Promise<void> {\n  let timeout: NodeJS.Timeout;\n  while (!obj.ready) {\n    await new Promise(resolve => {\n      clearTimeout(timeout);\n      timeout = setTimeout(resolve, delay);\n    });\n  }\n  clearTimeout(timeout);\n};\n\nexport const isString = (query: any): query is string => typeof query === 'string' || query instanceof String;\n\nexport const isFunction = (query: any): query is (...args: any[]) => any =>\n  Object.prototype.toString.call(query) === \"[object Function]\"\n  || \"function\" === typeof query\n  || query instanceof Function;\n\nexport const isPrimitive = (query: any): query is Primitive => query !== Object(query);\n\nexport const splitOnCapitals = (query: string) => query.split(/(?=[A-Z])/);\n\n/**\n * A type safe utility function for copy values from one object to another\n * @param param0 object containing the target to copy values to and the source of the values to copy\n */\nexport const copyTo = <TTarget extends object, TSource extends { [k in keyof TTarget]?: TTarget[k] }>({ target, source }: { target: TTarget, source: TSource }) => {\n  for (const key in source) {\n    if (!(key in target)) continue;\n    // @ts-ignore -- the types of the function should ensure this is valid TS\n    target[key] = source[key]\n  }\n}\n\nexport const identity = (x: any) => x;\n\nexport const loadExternalScript = (url: string, onLoad: () => void, onError?: () => void) => {\n  const script = document.createElement('script');\n\n  script.onload = onLoad;\n\n  script.onerror = onError ?? (() => {\n    throw new Error(`Error loading endpoint: ${url}`)\n  });\n\n  script.src = url;\n  script.async = true;\n\n  document.body.appendChild(script);\n}\n\n/**\n * \n * @param url \n * @returns \n */\nexport const untilExternalScriptLoaded = async (url: string): Promise<void> => {\n  const scriptLoaded = new Promise((resolve, reject) => {\n    const script = document.createElement('script');\n    script.onload = resolve;\n    script.onerror = reject;\n    script.async = true;\n    script.src = url;\n    document.body.appendChild(script);\n  });\n  await scriptLoaded;\n  return;\n}\n\n/**\n * \n * @param url \n * @param globalVariableName \n * @returns \n */\nexport const untilExternalGlobalVariableLoaded = async <T>(url: string, globalVariableName: string): Promise<T> => {\n  if (window[globalVariableName]) return window[globalVariableName];\n  await untilExternalScriptLoaded(url);\n  return window[globalVariableName];\n}\n\n/**\n * Utilize javascript's \"call\" method (on Function.prototype) in a typesafe manner\n * @param fn \n * @param _this \n * @param args \n * @returns \n */\nexport const typesafeCall = <Args extends any[], Return, This, Fn extends (this: This, ...args: Args) => Return>(fn: Fn, _this: This, ...args: Args) => fn.call(_this, ...args) as Return;\n\nexport const set = <T extends object, K extends keyof T>(container: T, key: K, value: T[K]) => {\n  container[key] = value;\n  return container;\n}\n\nexport const assertSameLength = (...collections: any[][]) => {\n  const { size } = collections.reduce((set, { length }) => set.add(length), new Set<number>());\n  if (size !== 1) throw new Error(\"Zip failed because collections weren't equal length\");\n}\n\n/**\n * Convert a Scratch decimal color to a hex string, #RRGGBB.\n * @param {number} decimal RGB color as a decimal.\n * @return {string} RGB color as #RRGGBB hex string.\n */\nconst decimalToHex = (decimal: number) => {\n  if (decimal < 0) {\n    decimal += 0xFFFFFF + 1;\n  }\n  let hex = Number(decimal).toString(16);\n  hex = `#${'000000'.substr(0, 6 - hex.length)}${hex}`;\n  return hex;\n}\n\n/**\n * Convert an RGB color object to a Scratch decimal color.\n * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n * @return {!number} Number representing the color.\n */\nfunction rgbToDecimal(rgb: RGBObject) {\n  return (rgb.r << 16) + (rgb.g << 8) + rgb.b;\n}\n\n/**\n * Convert an RGB color object to a hex color.\n * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n * @return {!string} Hex representation of the color.\n */\nexport const rgbToHex = (rgb: RGBObject) => {\n  return decimalToHex(rgbToDecimal(rgb));\n}\n\n/**\n * Create an event (within extension framework code, i.e. `extensions/src`) that can be subscribed to at _bundling time_. \n * \n * As a mental short-hand, you can think of this as a macro-esque mechanism.\n * \n * @see macro-link Macros\n * \n * @description\n * This **_works_** as it tries to create an object in the global scope, which is interacted with both from bundling-related code, \n * as well as the extension framework code \n * (as long as that code is executed at the _top-level_, and the runtime is NodeJS, not the browser). \n * \n * The reason why it's important the framework-based code is _top-level_ is because the framework sourcecode will actually be evaluated at _bundle time_, \n * meaning all _top-level_ expressions will be executed. \n * \n * This allows for the desired event mechanism: \n * > 1. Bundling-related code associates callbacks with a certain event (an entry to an object in global scope), \n * > 2. Framework code tries to fire the callbacks of a given event (when it is executed after step 1)\n * \n * @see top-level Top-level Code\n\n * **NOTE:** This function returns a non-null value only in NodeJS environments.\n * @param identifier \n * @returns \n */\nexport const tryCreateBundleTimeEvent = <Payload>(identifier: string) => {\n  const environment = typeof window === 'undefined' ? \"node\" : \"browser\";\n\n  if (environment !== \"node\") return null;\n\n  const key = `Bundle Time Event: ${identifier}`;\n\n  type Unregister = () => void;\n  type Callback = (details: Payload, removeSelf: Unregister) => void;\n  type Register = (callback: Callback) => Unregister;\n  type Callbacks = Record<symbol, Callback>;\n\n  const get = () => {\n    global[key] ??= {};\n    return global[key] as Callbacks;\n  }\n\n  const registerCallback: Register = (callback) => {\n    const id = Symbol(key);\n    get()[id] = callback;\n    return () => delete get()?.[id];\n  };\n\n  type Fire = (details: Payload) => void;\n\n  const fire: Fire = (details) => {\n    const callbackIDs = Object.getOwnPropertySymbols(get());\n    for (const id of callbackIDs) get()[id]?.(details, () => delete get()?.[id]);\n  };\n\n  return { registerCallback, fire };\n}\n\n/**\n * from: https://www.geeksforgeeks.org/how-to-create-a-guid-uuid-in-javascript/\n * @returns \n */\nexport const uuidv4 = () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'\n  .replace(/[xy]/g, function (c) {\n    const r = Math.random() * 16 | 0,\n      v = c == 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n","export const openUIEvent = \"OPEN_UI_FROM_EXTENSION\";\nexport const registerButtonCallbackEvent = \"REGISTER_BUTTON_CALLBACK_FROM_EXTENSION\";\nexport const FrameworkID = \"ExtensionFramework\";\nexport const AuxiliaryExtensionInfo = \"AuxiliaryExtensionInfo\";\n\nexport const customArgumentFlag = \"internal_IsCustomArgument\";\nexport const customArgumentMethod = \"tryProcessMenuItemAsCustomArgumentHack\";\n\nexport const guiDropdownInterop = {\n    runtimeKey: \"prgDropdownCustomization\",\n    runtimeProperties: {\n        stateKey: \"state\",\n        entryKey: \"entry\",\n        updateMethodKey: \"update\",\n    },\n    state: {\n        open: \"open\",\n        init: \"init\",\n        update: \"update\",\n        close: \"close\",\n    },\n} as const;\n\nexport const blockIDKey = \"blockID\";","import Runtime from \"$scratch-vm/engine/runtime\";\nimport { Extension as BaseExtension } from \"./extension/GenericExtension\";\nimport { openUIEvent, registerButtonCallbackEvent } from \"./globals\";\n\nexport type ReactivityDependency = any | any[];\n\nexport const activeClass = true;\n\nexport const px = (numberOf: number) => `${numberOf}px`;\n\ntype UniqueKeys<Extension> = Exclude<keyof Extension, keyof BaseExtension<any, any>>;\ntype Methods<Extension> = { [K in UniqueKeys<Extension>]-?: Extension[K] extends (...args: any) => any ? K : never };\ntype Properties<Extension> = { [K in UniqueKeys<Extension>]-?: Extension[K] extends (...args: any) => any ? never : K };\ntype MethodParams<Extension> = { [Key in UniqueKeys<Extension>]: Extension[Key] extends (...args: any) => any ? Parameters<Extension[Key]> : never };\ntype MethodReturns<Extension> = { [Key in UniqueKeys<Extension>]: Extension[Key] extends (...args: any) => any ? ReturnType<Extension[Key]> : never };\n\nexport type ReactiveInvoke<Extension> = <T extends keyof Methods<Extension>>(funcName: Methods<Extension>[T] extends never ? never : T, ...args: MethodParams<Extension>[T]) => MethodReturns<Extension>[T];\nexport type ReactiveSet<Extension> = <T extends keyof Properties<Extension>>(propertyName: Properties<Extension>[T] extends never ? never : T, value: Extension[T]) => void;\n\nexport type ReactiveMethods<Extension> = {\n  invoke: ReactiveInvoke<Extension>;\n  set: ReactiveSet<Extension>;\n}\n\nexport const reactiveInvoke = <Extension, T extends keyof Methods<Extension>>(extensionAssignment: Extension, funcName: T, args: MethodParams<Extension>[T]): MethodReturns<Extension>[T] => {\n  return (extensionAssignment[funcName] as Function)(...args as []);\n}\n\nexport const reactiveSet = <Extension, T extends keyof Properties<Extension>>(extensionAssignment: Extension, propertyName: T, value: Extension[T]): void => {\n  extensionAssignment[propertyName] = value;\n}\n\nexport const openUI = (runtime: Runtime, details: { id: string, name: string, component: string, label?: string }) => runtime.emit(openUIEvent, details);\n\nexport const registerButtonCallback = (runtime: Runtime, buttonID: string, callback: (...args: any[]) => void) => {\n  runtime.emit(registerButtonCallbackEvent, buttonID);\n  runtime.on(buttonID, callback);\n}\n\nconst enum Color {\n  ui = \"ui\",\n  text = \"text\",\n  motion = \"motion\",\n  red = \"red\",\n  sound = \"sound\",\n  control = \"control\",\n  data = \"data\",\n  pen = \"pen\",\n  error = \"error\",\n  extensions = \"extensions\",\n  drop = \"drop\"\n}\n\n/**\n * Makes it easier to reference the css color variables defined in prg-extension-boilerplate/packages/scratch-gui/src/components/programmatic-modal/programmatic-modal.jsx\n */\nclass CssVar {\n  root: Color;\n\n  constructor(root: Color) { this.root = root }\n\n  get(...parts: string[]) { return `var(--${this.root}-${parts.join(\"-\")})` }\n  primary(...parts: string[]) { return this.get(\"primary\", ...parts) }\n  secondary(...parts: string[]) { return this.get(\"secondary\", ...parts) }\n  tertiary(...parts: string[]) { return this.get(\"tertiary\", ...parts) }\n  transparent(...parts: string[]) { return this.get(\"transparent\", ...parts) }\n  light(...parts: string[]) { return this.get(\"light\", ...parts) }\n}\n\nconst ui = new CssVar(Color.ui);\nconst text = new CssVar(Color.text);\nconst motion = new CssVar(Color.motion);\nconst red = new CssVar(Color.red);\nconst sound = new CssVar(Color.sound);\nconst control = new CssVar(Color.control);\nconst data = new CssVar(Color.data);\nconst pen = new CssVar(Color.pen);\nconst error = new CssVar(Color.error);\nconst extensions = new CssVar(Color.extensions);\nconst drop = new CssVar(Color.extensions);\n\n/**\n * Color variable references corresponding to the css variables defined in prg-extension-boilerplate/packages/scratch-gui/src/components/programmatic-modal/programmatic-modal.jsx\n */\nexport const color = {\n  \"ui\": {\n    primary: ui.primary(),\n    secondary: ui.secondary(),\n    tertiary: ui.tertiary(),\n    modalOverlay: ui.get(\"modal\", \"overlay\"),\n    white: ui.get(\"white\"),\n    whiteDim: ui.get(\"white\", \"dim\"),\n    whiteTransparent: ui.get(\"white\", \"transparent\"),\n    transparent: ui.transparent(),\n    blackTransparent: ui.get(\"black\", \"transparent\"),\n  },\n  \"text\": {\n    primary: text.primary(),\n    primaryTransparent: text.transparent(),\n  },\n  \"motion\": {\n    primary: motion.primary(),\n    tertiary: motion.tertiary(),\n    transparent: motion.get(\"transparent\"),\n    lightTansparent: motion.light(\"transparent\"),\n  },\n  \"red\": {\n    primary: red.primary(),\n    tertiary: red.tertiary(),\n  },\n  \"sound\": {\n    primary: sound.primary(),\n    tertiary: sound.tertiary(),\n  },\n  \"control\": {\n    primary: control.primary(),\n  },\n  \"data\": {\n    primary: data.primary(),\n  },\n  \"pen\": {\n    primary: pen.primary(),\n    transparent: pen.transparent(),\n  },\n  \"error\": {\n    primary: error.primary(),\n    light: error.light(),\n    transparent: error.transparent(),\n  },\n  \"extensions\": {\n    primary: extensions.primary(),\n    tertiary: extensions.tertiary(),\n    light: extensions.light(),\n    transparent: extensions.transparent(),\n  },\n  \"drop\": {\n    highlight: drop.get(\"highlight\")\n  }\n}","const validRegEx = new RegExp('^[a-z0-9]+$', 'i');\nconst invalidRegEx = new RegExp('[^a-z0-9]+', 'gi');\n\nexport const isValidID = (id) => validRegEx.test(id);\n\nconst guard = 'prg';\nconst guards = [guard, guard.split(\"\").reverse().join(\"\")];\n\nconst guardsRegEx = new RegExp(`${guards[0]}([0-9]+)${guards[1]}`, 'g');\n\nconst wrap = (str) => `${guards[0]}${str}${guards[1]}`;\n\nconst replaceAll = (query, current, desired) => query.replaceAll(current, desired);\n\nexport const encode = (query: string): string => {\n  const matches = [...query.matchAll(invalidRegEx)];\n  const invalidCharacters = matches.reduce((set, current) => {\n    current[0].split(\"\").forEach(char => set.add(char));\n    return set;\n  }, new Set<string>());\n  const replacements = [...invalidCharacters].map(char => ({ char, code: char.charCodeAt(0) }));\n  return replacements.reduce((modified, { char, code }) => replaceAll(modified, char, wrap(code)), `${query}`);\n}\n\nexport const decode = (query: string): string => {\n  const matches = [...query.matchAll(guardsRegEx)];\n  const replacements = matches.reduce((replacements, match) => {\n    const [key, code] = match;\n    return replacements.set(key, String.fromCharCode(code as any as number));\n  }, new Map());\n  return [...replacements].reduce((modified, [current, desired]) => replaceAll(modified, current, desired), `${query}`);\n}","import { BaseGenericExtension, NonAbstractConstructor } from \"$common/types\";\nimport { MinimalExtensionConstructor } from \"../base\";\nimport { ExtensionInstanceWithFunctionality } from \"..\";\n\n/**\n * WARNING! If you change this key, it will affect already saved projects.\n * Do not rename this without first developing a mechanism for searching for previously used keys.\n */\nexport const saveDataKey = \"customSaveDataPerExtension\" as const;\n\n/**\n * @summary Utility class to assist in creating a (typesafe) object that, for a given Extension type, handles both:\n * - writing out data on save\n * - doing something with save data on load\n * \n * @description This class's constructor takes an object with both an `onSave` and an `onLoad` method\n * (and the `onSave`'s return type must match `onLoad`'s argument type)\n * @example\n * new SaveDataHandler({\n *    Extension: MyExtension,\n *    onSave: () => ({x: 0, y: 3}),\n *    onLoad: (data) => {\n *       const sum = data.x + data.y; // do something with saved data\n *    }\n * })\n * @todo Remove the `BaseGenericExtension` Generic Type restraint once Generic Extensions are no longer supported\n */\nexport class SaveDataHandler<T extends BaseGenericExtension | ExtensionInstanceWithFunctionality<[\"customSaveData\"]>, TData> {\n  constructor(public hooks: {\n    // @ts-ignore\n    Extension: NonAbstractConstructor<T>,\n    onSave: (self: T) => TData,\n    onLoad: (self: T, data: TData) => void,\n  }) { }\n}\n\n/**\n * Mixin the ability for extensions to save and reload custom data (including any data related to custom arguments)\n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport default function mixin<T extends MinimalExtensionConstructor>(Ctor: T) {\n  abstract class ExtensionWithCustomSaveDataSupport extends Ctor {\n    /**\n     * Optional field that can be defined if you need to save custom data for an extension \n     * (like some extension specific variable, or an API endpoint).\n     * @example\n     * class Example extends Extension<..., ...> {\n     *    someValue = 5;\n     *    ...\n     *    saveDataHandler = new SaveDataHandler({\n     *      Extension: Example,\n     *      // NOTE: The type info for 'instance' could be left off in the line below\n     *      onSave: (instance: Example) => ({ valueToSave: instance.someValue }),\n     *      onLoad: (instance, data) => instance.someValue = data.valueToSave\n     *    })\n     * }\n     * @see Extension.MakeSaveDataHandler\n     */\n    protected saveDataHandler: SaveDataHandler<ExtensionWithCustomSaveDataSupport, any> = undefined;\n\n    /**\n     * Save function called 'internally' by the VM when serializing a project.\n     * @param toSave \n     * @param extensionIDs \n     * @returns \n     */\n    private save(toSave: { [saveDataKey]: Record<string, any> }, extensionIDs: Set<string>) {\n      const { saveDataHandler, id } = this;\n      const argumentManager = this.supports(\"customArguments\") ? this.customArgumentManager : null;\n      const saveData = saveDataHandler?.hooks.onSave(this) ?? {};\n      argumentManager?.saveTo(saveData);\n      if (Object.keys(saveData).length === 0) return;\n      const container = toSave[saveDataKey];\n      container ? (container[id] = saveData) : (toSave[saveDataKey] = { [id]: saveData });\n      extensionIDs.add(id);\n    }\n\n    /**\n     * Load function called 'internally' by the VM when loading a project.\n     * Will be invoked on an extension immediately after it is constructed.\n     * @param saved \n     * @returns \n     */\n    private load(saved: { [saveDataKey]: Record<string, any> }) {\n      if (!saved) return;\n      const { saveDataHandler, id } = this;\n      const saveData = saveDataKey in saved ? saved[saveDataKey][id] : null;\n      if (!saveData) return;\n      saveDataHandler?.hooks.onLoad(this, saveData);\n\n      if (this.supports(\"customArguments\")) this.getOrCreateCustomArgumentManager().loadFrom(saveData);\n    }\n  }\n  return ExtensionWithCustomSaveDataSupport;\n}","class Color {\n    /**\n     * @typedef {object} RGBObject - An object representing a color in RGB format.\n     * @property {number} r - the red component, in the range [0, 255].\n     * @property {number} g - the green component, in the range [0, 255].\n     * @property {number} b - the blue component, in the range [0, 255].\n     */\n\n    /**\n     * @typedef {object} HSVObject - An object representing a color in HSV format.\n     * @property {number} h - hue, in the range [0-359).\n     * @property {number} s - saturation, in the range [0,1].\n     * @property {number} v - value, in the range [0,1].\n     */\n\n    /** @type {RGBObject} */\n    static get RGB_BLACK () {\n        return {r: 0, g: 0, b: 0};\n    }\n\n    /** @type {RGBObject} */\n    static get RGB_WHITE () {\n        return {r: 255, g: 255, b: 255};\n    }\n\n    /**\n     * Convert a Scratch decimal color to a hex string, #RRGGBB.\n     * @param {number} decimal RGB color as a decimal.\n     * @return {string} RGB color as #RRGGBB hex string.\n     */\n    static decimalToHex (decimal) {\n        if (decimal < 0) {\n            decimal += 0xFFFFFF + 1;\n        }\n        let hex = Number(decimal).toString(16);\n        hex = `#${'000000'.substr(0, 6 - hex.length)}${hex}`;\n        return hex;\n    }\n\n    /**\n     * Convert a Scratch decimal color to an RGB color object.\n     * @param {number} decimal RGB color as decimal.\n     * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     */\n    static decimalToRgb (decimal) {\n        const a = (decimal >> 24) & 0xFF;\n        const r = (decimal >> 16) & 0xFF;\n        const g = (decimal >> 8) & 0xFF;\n        const b = decimal & 0xFF;\n        return {r: r, g: g, b: b, a: a > 0 ? a : 255};\n    }\n\n    /**\n     * Convert a hex color (e.g., F00, #03F, #0033FF) to an RGB color object.\n     * CC-BY-SA Tim Down:\n     * https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb\n     * @param {!string} hex Hex representation of the color.\n     * @return {RGBObject} null on failure, or rgb: {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     */\n    static hexToRgb (hex) {\n        const shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n        hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);\n        const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n        return result ? {\n            r: parseInt(result[1], 16),\n            g: parseInt(result[2], 16),\n            b: parseInt(result[3], 16)\n        } : null;\n    }\n\n    /**\n     * Convert an RGB color object to a hex color.\n     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     * @return {!string} Hex representation of the color.\n     */\n    static rgbToHex (rgb) {\n        return Color.decimalToHex(Color.rgbToDecimal(rgb));\n    }\n\n    /**\n     * Convert an RGB color object to a Scratch decimal color.\n     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     * @return {!number} Number representing the color.\n     */\n    static rgbToDecimal (rgb) {\n        return (rgb.r << 16) + (rgb.g << 8) + rgb.b;\n    }\n\n    /**\n    * Convert a hex color (e.g., F00, #03F, #0033FF) to a decimal color number.\n    * @param {!string} hex Hex representation of the color.\n    * @return {!number} Number representing the color.\n    */\n    static hexToDecimal (hex) {\n        return Color.rgbToDecimal(Color.hexToRgb(hex));\n    }\n\n    /**\n     * Convert an HSV color to RGB format.\n     * @param {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}\n     * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     */\n    static hsvToRgb (hsv) {\n        let h = hsv.h % 360;\n        if (h < 0) h += 360;\n        const s = Math.max(0, Math.min(hsv.s, 1));\n        const v = Math.max(0, Math.min(hsv.v, 1));\n\n        const i = Math.floor(h / 60);\n        const f = (h / 60) - i;\n        const p = v * (1 - s);\n        const q = v * (1 - (s * f));\n        const t = v * (1 - (s * (1 - f)));\n\n        let r;\n        let g;\n        let b;\n\n        switch (i) {\n        default:\n        case 0:\n            r = v;\n            g = t;\n            b = p;\n            break;\n        case 1:\n            r = q;\n            g = v;\n            b = p;\n            break;\n        case 2:\n            r = p;\n            g = v;\n            b = t;\n            break;\n        case 3:\n            r = p;\n            g = q;\n            b = v;\n            break;\n        case 4:\n            r = t;\n            g = p;\n            b = v;\n            break;\n        case 5:\n            r = v;\n            g = p;\n            b = q;\n            break;\n        }\n\n        return {\n            r: Math.floor(r * 255),\n            g: Math.floor(g * 255),\n            b: Math.floor(b * 255)\n        };\n    }\n\n    /**\n     * Convert an RGB color to HSV format.\n     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     * @return {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}\n     */\n    static rgbToHsv (rgb) {\n        const r = rgb.r / 255;\n        const g = rgb.g / 255;\n        const b = rgb.b / 255;\n        const x = Math.min(Math.min(r, g), b);\n        const v = Math.max(Math.max(r, g), b);\n\n        // For grays, hue will be arbitrarily reported as zero. Otherwise, calculate\n        let h = 0;\n        let s = 0;\n        if (x !== v) {\n            const f = (r === x) ? g - b : ((g === x) ? b - r : r - g);\n            const i = (r === x) ? 3 : ((g === x) ? 5 : 1);\n            h = ((i - (f / (v - x))) * 60) % 360;\n            s = (v - x) / v;\n        }\n\n        return {h: h, s: s, v: v};\n    }\n\n    /**\n     * Linear interpolation between rgb0 and rgb1.\n     * @param {RGBObject} rgb0 - the color corresponding to fraction1 <= 0.\n     * @param {RGBObject} rgb1 - the color corresponding to fraction1 >= 1.\n     * @param {number} fraction1 - the interpolation parameter. If this is 0.5, for example, mix the two colors equally.\n     * @return {RGBObject} the interpolated color.\n     */\n    static mixRgb (rgb0, rgb1, fraction1) {\n        if (fraction1 <= 0) return rgb0;\n        if (fraction1 >= 1) return rgb1;\n        const fraction0 = 1 - fraction1;\n        return {\n            r: (fraction0 * rgb0.r) + (fraction1 * rgb1.r),\n            g: (fraction0 * rgb0.g) + (fraction1 * rgb1.g),\n            b: (fraction0 * rgb0.b) + (fraction1 * rgb1.b)\n        };\n    }\n}\n\nmodule.exports = Color;\n","const Color = require('../util/color');\n\n/**\n * @fileoverview\n * Utilities for casting and comparing Scratch data-types.\n * Scratch behaves slightly differently from JavaScript in many respects,\n * and these differences should be encapsulated below.\n * For example, in Scratch, add(1, join(\"hello\", world\")) -> 1.\n * This is because \"hello world\" is cast to 0.\n * In JavaScript, 1 + Number(\"hello\" + \"world\") would give you NaN.\n * Use when coercing a value before computation.\n */\n\nclass Cast {\n    /**\n     * Scratch cast to number.\n     * Treats NaN as 0.\n     * In Scratch 2.0, this is captured by `interp.numArg.`\n     * @param {*} value Value to cast to number.\n     * @return {number} The Scratch-casted number value.\n     */\n    static toNumber (value) {\n        // If value is already a number we don't need to coerce it with\n        // Number().\n        if (typeof value === 'number') {\n            // Scratch treats NaN as 0, when needed as a number.\n            // E.g., 0 + NaN -> 0.\n            if (Number.isNaN(value)) {\n                return 0;\n            }\n            return value;\n        }\n        const n = Number(value);\n        if (Number.isNaN(n)) {\n            // Scratch treats NaN as 0, when needed as a number.\n            // E.g., 0 + NaN -> 0.\n            return 0;\n        }\n        return n;\n    }\n\n    /**\n     * Scratch cast to boolean.\n     * In Scratch 2.0, this is captured by `interp.boolArg.`\n     * Treats some string values differently from JavaScript.\n     * @param {*} value Value to cast to boolean.\n     * @return {boolean} The Scratch-casted boolean value.\n     */\n    static toBoolean (value) {\n        // Already a boolean?\n        if (typeof value === 'boolean') {\n            return value;\n        }\n        if (typeof value === 'string') {\n            // These specific strings are treated as false in Scratch.\n            if ((value === '') ||\n                (value === '0') ||\n                (value.toLowerCase() === 'false')) {\n                return false;\n            }\n            // All other strings treated as true.\n            return true;\n        }\n        // Coerce other values and numbers.\n        return Boolean(value);\n    }\n\n    /**\n     * Scratch cast to string.\n     * @param {*} value Value to cast to string.\n     * @return {string} The Scratch-casted string value.\n     */\n    static toString (value) {\n        return String(value);\n    }\n\n    /**\n     * Cast any Scratch argument to an RGB color array to be used for the renderer.\n     * @param {*} value Value to convert to RGB color array.\n     * @return {Array.<number>} [r,g,b], values between 0-255.\n     */\n    static toRgbColorList (value) {\n        const color = Cast.toRgbColorObject(value);\n        return [color.r, color.g, color.b];\n    }\n\n    /**\n     * Cast any Scratch argument to an RGB color object to be used for the renderer.\n     * @param {*} value Value to convert to RGB color object.\n     * @return {import(\"../typescript-support/types\").RGBObject} [r,g,b], values between 0-255.\n     */\n    static toRgbColorObject (value) {\n        let color;\n        if (typeof value === 'string' && value.substring(0, 1) === '#') {\n            color = Color.hexToRgb(value);\n            // If the color wasn't *actually* a hex color, cast to black\n            if (!color) color = {r: 0, g: 0, b: 0, a: 255};\n        } else {\n            color = Color.decimalToRgb(Cast.toNumber(value));\n        }\n        return color;\n    }\n\n    /**\n     * Determine if a Scratch argument is a white space string (or null / empty).\n     * @param {*} val value to check.\n     * @return {boolean} True if the argument is all white spaces or null / empty.\n     */\n    static isWhiteSpace (val) {\n        return val === null || (typeof val === 'string' && val.trim().length === 0);\n    }\n\n    /**\n     * Compare two values, using Scratch cast, case-insensitive string compare, etc.\n     * In Scratch 2.0, this is captured by `interp.compare.`\n     * @param {*} v1 First value to compare.\n     * @param {*} v2 Second value to compare.\n     * @returns {number} Negative number if v1 < v2; 0 if equal; positive otherwise.\n     */\n    static compare (v1, v2) {\n        let n1 = Number(v1);\n        let n2 = Number(v2);\n        if (n1 === 0 && Cast.isWhiteSpace(v1)) {\n            n1 = NaN;\n        } else if (n2 === 0 && Cast.isWhiteSpace(v2)) {\n            n2 = NaN;\n        }\n        if (isNaN(n1) || isNaN(n2)) {\n            // At least one argument can't be converted to a number.\n            // Scratch compares strings as case insensitive.\n            const s1 = String(v1).toLowerCase();\n            const s2 = String(v2).toLowerCase();\n            if (s1 < s2) {\n                return -1;\n            } else if (s1 > s2) {\n                return 1;\n            }\n            return 0;\n        }\n        // Handle the special case of Infinity\n        if (\n            (n1 === Infinity && n2 === Infinity) ||\n            (n1 === -Infinity && n2 === -Infinity)\n        ) {\n            return 0;\n        }\n        // Compare as numbers.\n        return n1 - n2;\n    }\n\n    /**\n     * Determine if a Scratch argument number represents a round integer.\n     * @param {*} val Value to check.\n     * @return {boolean} True if number looks like an integer.\n     */\n    static isInt (val) {\n        // Values that are already numbers.\n        if (typeof val === 'number') {\n            if (isNaN(val)) { // NaN is considered an integer.\n                return true;\n            }\n            // True if it's \"round\" (e.g., 2.0 and 2).\n            return val === parseInt(val, 10);\n        } else if (typeof val === 'boolean') {\n            // `True` and `false` always represent integer after Scratch cast.\n            return true;\n        } else if (typeof val === 'string') {\n            // If it contains a decimal point, don't consider it an int.\n            return val.indexOf('.') < 0;\n        }\n        return false;\n    }\n\n    static get LIST_INVALID () {\n        return 'INVALID';\n    }\n\n    static get LIST_ALL () {\n        return 'ALL';\n    }\n\n    /**\n     * Compute a 1-based index into a list, based on a Scratch argument.\n     * Two special cases may be returned:\n     * LIST_ALL: if the block is referring to all of the items in the list.\n     * LIST_INVALID: if the index was invalid in any way.\n     * @param {*} index Scratch arg, including 1-based numbers or special cases.\n     * @param {number} length Length of the list.\n     * @param {boolean} acceptAll Whether it should accept \"all\" or not.\n     * @return {(number|string)} 1-based index for list, LIST_ALL, or LIST_INVALID.\n     */\n    static toListIndex (index, length, acceptAll) {\n        if (typeof index !== 'number') {\n            if (index === 'all') {\n                return acceptAll ? Cast.LIST_ALL : Cast.LIST_INVALID;\n            }\n            if (index === 'last') {\n                if (length > 0) {\n                    return length;\n                }\n                return Cast.LIST_INVALID;\n            } else if (index === 'random' || index === 'any') {\n                if (length > 0) {\n                    return 1 + Math.floor(Math.random() * length);\n                }\n                return Cast.LIST_INVALID;\n            }\n        }\n        index = Math.floor(Cast.toNumber(index));\n        if (index < 1 || index > length) {\n            return Cast.LIST_INVALID;\n        }\n        return index;\n    }\n}\n\nmodule.exports = Cast;\n","import { ArgumentType } from \"./types/enums\";\nimport { RGBObject, TypeByArgumentType, ValueOf } from \"./types\";\nimport Cast from '$scratch-vm/util/cast';\n\nexport const castToType = (argumentType: ValueOf<typeof ArgumentType>, value: any) => {\n  switch (argumentType) {\n    case ArgumentType.String:\n      return `${value}`;\n    case ArgumentType.Number:\n      return parseFloat(value);\n    case ArgumentType.Boolean:\n      return JSON.parse(value ?? false);\n    case ArgumentType.Note:\n      return parseInt(value);\n    case ArgumentType.Angle:\n      return parseInt(value);\n    case ArgumentType.Matrix:\n      return toMatrix(value);\n    case ArgumentType.Color:\n      return Cast.toRgbColorObject(value) as RGBObject;\n    default:\n      throw new Error(`Method not implemented for value of ${value} and type ${argumentType}`);\n  }\n}\n\nexport const tryCastToArgumentType = <T extends ValueOf<typeof ArgumentType>>(\n  argumentType: T,\n  value: any,\n  onFailure: (value: any) => TypeByArgumentType<T>\n): TypeByArgumentType<T> => {\n  try {\n    const casted = castToType(argumentType, value);\n    return casted as TypeByArgumentType<T>;\n  }\n  catch {\n    return onFailure(value);\n  }\n}\n\nconst toFlag = (value: string): boolean => parseInt(value) === 1;\n\nconst toMatrix = (matrixString: string): boolean[][] => {\n  if (matrixString.length !== 25) return new Array(5).fill(new Array(5).fill(false));\n\n  const entries = matrixString.split('');\n  const matrix = entries.map(toFlag).reduce((matrix, flag, index) => {\n    const row = Math.floor(index / 5);\n    const column = index % 5;\n    (column === 0) ? matrix[row] = [flag] : matrix[row].push(flag);\n    return matrix;\n  }, new Array<boolean[]>(5));\n\n  return matrix;\n}","import { uuidv4 } from \"$common/utils\";\nimport { RuntimeWithCustomArgumentSupport, ArgumentEntry, ArgumentEntrySetter, ArgumentID } from \"./utils\";\n\nexport default class CustomArgumentManager {\n  map: Map<string, ArgumentEntry<any>> = new Map();\n  pending: ArgumentID = null;\n\n  private setPending(id: ArgumentID) { return (this.pending = id) }\n  private clearPending() { this.pending = null }\n\n  private setEntry(entry: ArgumentEntry<any>) {\n    const id = CustomArgumentManager.GetIdentifier();\n    this.map.set(id, entry);\n    return id;\n  }\n\n  add<T>(entry: ArgumentEntry<T>): string {\n    const id = CustomArgumentManager.GetIdentifier();\n    this.map.set(id, entry);\n    return id;\n  }\n\n  request<T>(update: (id: ArgumentID) => void): ArgumentEntrySetter<T> {\n    this.clearPending();\n    return (entry) => update(this.setPending(this.setEntry(entry)));\n  }\n\n  peek() {\n    const { pending: id } = this;\n    const entry = this.getEntry(id);\n    return { entry, id };\n  }\n\n  tryResolve() {\n    if (!this.pending) return null;\n    const state = this.peek();\n    this.clearPending();\n    return state;\n  }\n\n  getCurrentEntries() {\n    return Array.from(this.map.entries())\n      .filter(([_, entry]) => entry !== null)\n      .map(([id, { text }]) => ({ text, value: id }) as const);\n  }\n\n  getEntry(id: string) { return this.map.get(id) }\n\n  static SaveKey = \"internal_customArgumentsSaveData\" as const;\n\n  requiresSave() { this.map.size > 0 }\n\n  saveTo(obj: object) {\n    const entries = Array.from(this.map.entries())\n      .filter(([_, entry]) => entry !== null)\n      .map(([id, entry]) => ({ id, entry }));\n    if (entries.length === 0) return;\n    obj[CustomArgumentManager.SaveKey] = entries;\n  }\n\n  loadFrom(obj: Record<typeof CustomArgumentManager[\"SaveKey\"], { id: string, entry: ArgumentEntry<any> }[]>) {\n    obj[CustomArgumentManager.SaveKey]?.forEach(({ id, entry }) => {\n      this.map.set(id, entry);\n    });\n  }\n\n  /**\n   * @todo Implement this if it becomes necessary (i.e the every growing size of this.map becomes an issue)\n   */\n  private purgeStaleIDs() {\n    // Somehow, tap into blockly to loop through all current blocks & their field dropdowns.\n    // Collect all field dropdowns values. \n    // Then, loop over entries in this.map -- if the values don't appear in the collected in-use values, drop those items.\n    // NOTE: The blocks in the 'pallette' do not show up in a target's \"blocks\" object, which makes this tricky.\n  }\n\n  static IsIdentifier = (query: string) => query.startsWith(CustomArgumentManager.IdentifierPrefix);\n  private static GetIdentifier = () => CustomArgumentManager.IdentifierPrefix + uuidv4();\n  private static IdentifierPrefix = \"__customArg__\";\n}","/**\n * Class adapted from: https://github.com/LLK/scratch-svg-renderer/blob/develop/src/bitmap-adapter.js\n */\nexport default class {\n  private makeImage() { return new Image() }\n  private makeCanvas() { return document.createElement('canvas') }\n\n  /**\n   * Return a canvas with the resized version of the given image, done using nearest-neighbor interpolation\n   * @param {CanvasImageSource} image The image to resize\n   * @param {int} newWidth The desired post-resize width of the image\n   * @param {int} newHeight The desired post-resize height of the image\n   * @returns {HTMLCanvasElement} A canvas with the resized image drawn on it.\n   */\n  resize(image, newWidth, newHeight) {\n    // We want to always resize using nearest-neighbor interpolation. However, canvas implementations are free to\n    // use linear interpolation (or other \"smooth\" interpolation methods) when downscaling:\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1360415\n    // It seems we can get around this by resizing in two steps: first width, then height. This will always result\n    // in nearest-neighbor interpolation, even when downscaling.\n    const stretchWidthCanvas = this.makeCanvas();\n    stretchWidthCanvas.width = newWidth;\n    stretchWidthCanvas.height = image.height;\n    let context = stretchWidthCanvas.getContext('2d');\n    context.imageSmoothingEnabled = false;\n    context.drawImage(image, 0, 0, stretchWidthCanvas.width, stretchWidthCanvas.height);\n    const stretchHeightCanvas = this.makeCanvas();\n    stretchHeightCanvas.width = newWidth;\n    stretchHeightCanvas.height = newHeight;\n    context = stretchHeightCanvas.getContext('2d');\n    context.imageSmoothingEnabled = false;\n    context.drawImage(stretchWidthCanvas, 0, 0, stretchHeightCanvas.width, stretchHeightCanvas.height);\n    return stretchHeightCanvas;\n  }\n\n  /**\n   * Scratch 2.0 had resolution 1 and 2 bitmaps. All bitmaps in Scratch 3.0 are equivalent\n   * to resolution 2 bitmaps. Therefore, converting a resolution 1 bitmap means doubling\n   * it in width and height.\n   * @param {!string} dataURI Base 64 encoded image data of the bitmap\n   * @param {!function} callback Node-style callback that returns updated dataURI if conversion succeeded\n   */\n  convertResolution1Bitmap(dataURI, callback) {\n    const image = new Image();\n    image.src = dataURI;\n    image.onload = () => {\n      callback(null, this.resize(image, image.width * 2, image.height * 2).toDataURL());\n    };\n    image.onerror = () => {\n      callback('Image load failed');\n    };\n  }\n\n  /**\n   * Given width/height of an uploaded item, return width/height the image will be resized\n   * to in Scratch 3.0\n   * @param {!number} oldWidth original width\n   * @param {!number} oldHeight original height\n   * @return {object} Array of new width, new height\n   */\n  getResizedWidthHeight(oldWidth, oldHeight) {\n    const STAGE_WIDTH = 480;\n    const STAGE_HEIGHT = 360;\n    const STAGE_RATIO = STAGE_WIDTH / STAGE_HEIGHT;\n\n    // If both dimensions are smaller than or equal to corresponding stage dimension,\n    // double both dimensions\n    if ((oldWidth <= STAGE_WIDTH) && (oldHeight <= STAGE_HEIGHT)) {\n      return { width: oldWidth * 2, height: oldHeight * 2 };\n    }\n\n    // If neither dimension is larger than 2x corresponding stage dimension,\n    // this is an in-between image, return it as is\n    if ((oldWidth <= STAGE_WIDTH * 2) && (oldHeight <= STAGE_HEIGHT * 2)) {\n      return { width: oldWidth, height: oldHeight };\n    }\n\n    const imageRatio = oldWidth / oldHeight;\n    // Otherwise, figure out how to resize\n    if (imageRatio >= STAGE_RATIO) {\n      // Wide Image\n      return { width: STAGE_WIDTH * 2, height: STAGE_WIDTH * 2 / imageRatio };\n    }\n    // In this case we have either:\n    // - A wide image, but not with as big a ratio between width and height,\n    // making it so that fitting the width to double stage size would leave\n    // the height too big to fit in double the stage height\n    // - A square image that's still larger than the double at least\n    // one of the stage dimensions, so pick the smaller of the two dimensions (to fit)\n    // - A tall image\n    // In any of these cases, resize the image to fit the height to double the stage height\n    return { width: STAGE_HEIGHT * 2 * imageRatio, height: STAGE_HEIGHT * 2 };\n  }\n\n  /**\n   * Given bitmap data, resize as necessary.\n   * @param {string} fileData Base 64 encoded image data of the bitmap\n   * @param {string} fileType The MIME type of this file\n   * @returns {Promise} Resolves to resized image data Uint8Array\n   */\n  importBitmap(dataURI: string): Promise<Uint8Array> {\n    return new Promise((resolve, reject) => {\n      const image = this.makeImage();\n      image.src = dataURI;\n      image.onload = () => {\n        const newSize = this.getResizedWidthHeight(image.width, image.height);\n        if (newSize.width === image.width && newSize.height === image.height) {\n          // No change\n          resolve(this.convertDataURIToBinary(dataURI));\n        } else {\n          const resizedDataURI = this.resize(image, newSize.width, newSize.height).toDataURL();\n          resolve(this.convertDataURIToBinary(resizedDataURI));\n        }\n      };\n      image.onerror = () => {\n        reject('Image load failed');\n      };\n    });\n  }\n\n  // TODO consolidate with scratch-vm/src/util/base64-util.js\n  // From https://gist.github.com/borismus/1032746\n  convertDataURIToBinary(dataURI) {\n    const BASE64_MARKER = ';base64,';\n    const base64Index = dataURI.indexOf(BASE64_MARKER) + BASE64_MARKER.length;\n    const base64 = dataURI.substring(base64Index);\n    const raw = window.atob(base64);\n    const rawLength = raw.length;\n    const array = new Uint8Array(new ArrayBuffer(rawLength));\n\n    for (let i = 0; i < rawLength; i++) {\n      array[i] = raw.charCodeAt(i);\n    }\n    return array;\n  }\n}","import type RenderedTarget from \"$scratch-vm/sprites/rendered-target\";\nimport Target from \"$scratch-vm/engine/target\";\nimport { MinimalExtensionConstructor } from \"../../base\";\nimport MockBitmapAdapter from \"./MockBitmapAdapter\";\nimport { getUrlHelper } from \"./utils\";\n\nlet bitmapAdapter: MockBitmapAdapter;\nlet urlHelper: ReturnType<typeof getUrlHelper>;\n\nconst rendererKey: keyof RenderedTarget = \"renderer\";\nconst isRenderedTarget = (target: Target | RenderedTarget): target is RenderedTarget => rendererKey in target;\n\n/**\n * Mixin the ability for extensions to add costumes to sprites\n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport default function <T extends MinimalExtensionConstructor>(Ctor: T) {\n  abstract class ExtensionWithCustomSupport extends Ctor {\n\n    /**\n     * Add a costume to the current sprite based on same image data\n     * @param {RenderedTarget} target (e.g. `util.target`)\n     * @param {ImageData} image What image to use to create the costume\n     * @param {\"add only\" | \"add and set\"} action What action should be applied\n     * - **_add only_**: generates the costume and append it it to the sprite's costume library\n     * - **_add and set_**: Both generate the costume (adding it to the sprite's costume library) and set it as the sprite's current costume\n     * @param {string?} name optional name to attach to the costume\n     */\n    async addCostume(target: Target, image: ImageData, action: \"add only\" | \"add and set\", name?: string) {\n      if (!isRenderedTarget(target)) return console.warn(\"Costume could not be added is the supplied target wasn't a rendered target\");\n\n      name ??= `${this.id}_generated_${Date.now()}`;\n      bitmapAdapter ??= new MockBitmapAdapter();\n      urlHelper ??= getUrlHelper(image);\n\n      // storage is of type: https://github.com/LLK/scratch-storage/blob/develop/src/ScratchStorage.js\n      const { storage } = this.runtime;\n      const dataFormat = storage.DataFormat.PNG;\n      const assetType = storage.AssetType.ImageBitmap;\n      const dataBuffer = await bitmapAdapter.importBitmap(urlHelper.getDataURL(image));\n\n      const asset = storage.createAsset(assetType, dataFormat, dataBuffer, null, true);\n      const { assetId } = asset;\n      const costume = { name, dataFormat, asset, md5: `${assetId}.${dataFormat}`, assetId };\n\n      await this.runtime.addCostume(costume);\n\n      const { length } = target.getCostumes();\n\n      target.addCostume(costume, length);\n      if (action === \"add and set\") target.setCostume(length);\n    }\n\n  }\n\n  return ExtensionWithCustomSupport;\n}\n","import { ValueOf } from \"$common/types\";\nimport { Mixin, MixinName, optionalMixins } from \"./index\";\nimport { MinimalExtensionConstructor } from \"./base\";\n\ntype DependentFunctionality<TBase, TMixinDependencies extends Mixin<unknown>[]> =\n  TMixinDependencies extends [infer Head extends Mixin<unknown>, ...infer Tail extends Mixin<unknown>[]]\n  ? DependentFunctionality<ReturnType<Head> & TBase, Tail>\n  : TBase;\n\nconst dependencyListeners: ((mixins: Mixin<any>[]) => void)[] = []\n\nexport const withDependencies = <\n  Base extends MinimalExtensionConstructor,\n  TMixinDependencies extends Mixin<T>[],\n  T\n>(Ctor: Base, ...dependencies: TMixinDependencies) => {\n  dependencyListeners.pop()?.(dependencies);\n  return Ctor as Base & DependentFunctionality<Base, TMixinDependencies>;\n}\n\nlet mixinsMap: Map<ValueOf<typeof optionalMixins>, keyof typeof optionalMixins>;\n\nexport const tryCaptureDependencies = <TReturn>(createMixin: () => TReturn): { MixedIn: TReturn, dependencies: MixinName[] | null } => {\n\n  mixinsMap ??= Object.entries(optionalMixins).reduce((map, [name, mixin]) => {\n    return map.set(mixin, name as MixinName);\n  }, new Map());\n\n  let dependencies: MixinName[];\n\n  dependencyListeners.push((mixins) => {\n    mixins\n      .map(dependency => dependency as ValueOf<typeof optionalMixins>)\n      .forEach(dependency => {\n        if (!mixinsMap.has(dependency)) throw new Error(\"Unkown mixin dependency! \" + dependency);\n        dependencies ??= [];\n        dependencies.push(mixinsMap.get(dependency));\n      })\n  });\n\n  const MixedIn = createMixin();\n\n  return { dependencies, MixedIn };\n}","import { ExtensionBase } from \"$common/extension/ExtensionBase\";\nimport { customArgumentFlag, guiDropdownInterop, } from \"$common/globals\";\nimport { Environment, Expand, ExpandRecursively, MenuItem, SvelteComponentConstructor, ValueOf } from \"$common/types\";\nimport { untilObject } from \"$common/utils\";\n\nexport type ArgumentEntry<T> = { text: string, value: T };\nexport type ArgumentEntrySetter<T, TReturn = void> = (entry: ArgumentEntry<T>) => TReturn;\nexport type ArgumentID = string;\n\nexport type ComponentProps<T, TExtension extends ExtensionBase> = {\n    extension: TExtension,\n    setter: ArgumentEntrySetter<T>,\n    current: ArgumentEntry<T>\n}\n\nexport type NonspecificComponentProps = ComponentProps<any, ExtensionBase>;\n\nexport type CustomArgumentComponent = SvelteComponentConstructor<NonspecificComponentProps>;\n\nexport type CustomArgumentRecipe<T, TExtension extends ExtensionBase> = {\n    /**\n     * The svelte component to render the custom argument UI\n     */\n    component: SvelteComponentConstructor<ComponentProps<T, TExtension>>,\n    /**\n     * The starting value of the the custom argument (including both its value and text representation)\n     */\n    initial: ArgumentEntry<T>,\n    /**\n     * A function that must be defined if you'd like for your custom argument to accept reporters\n     * @param x \n     * @returns \n     */\n    acceptReportersHandler?: (x: any) => ArgumentEntry<T>\n};\n\ntype DropdownEntry = { [k in typeof guiDropdownInterop.runtimeProperties.entryKey]: ArgumentEntry<string> };\ntype DropdownState = { [k in typeof guiDropdownInterop.runtimeProperties.stateKey]: ValueOf<typeof guiDropdownInterop.state> };\ntype DropdownUpdateMethod = { [k in typeof guiDropdownInterop.runtimeProperties.updateMethodKey]: (id: string) => void };\n\nexport type RuntimeWithCustomArgumentSupport = Environment[\"runtime\"] & {\n    [k in typeof guiDropdownInterop.runtimeKey]: ExpandRecursively<DropdownEntry & DropdownState & DropdownUpdateMethod>\n}\n\nconst findUniqueElementByClass = <T extends Element = Element>(container: Document | Element, className: string) => {\n    const elements = container.getElementsByClassName(className);\n    if (elements.length !== 1) throw new Error(`Uh oh! Expected 1 element with class '${className}', but found ${elements.length}`);\n    return elements[0] as T;\n}\n\nconst hideText = (element: Element) => (element as HTMLElement).style.display = \"none\";\n\nexport const renderToDropdown = async <TProps extends NonspecificComponentProps>(Compononent: SvelteComponentConstructor<TProps>, props: TProps) => {\n    const dropdownContainerClass = \"blocklyDropDownContent\";\n    const target = findUniqueElementByClass(document, dropdownContainerClass);\n    const anchor = await untilObject(() => target.children[0]);\n    const component = new Compononent({ target, anchor, props });\n    hideText(anchor);\n}","import { MenuThatAcceptsReporters, DynamicMenuThatAcceptsReporters, Menu, MenuItem, DynamicMenu, ExtensionMenuMetadata, ExtensionArgumentMetadata } from \"$common/types\";\nimport { isFunction, isPrimitive } from \"$common/utils\";\n\nconst reporterItemsKey: keyof MenuThatAcceptsReporters<any> = \"items\";\nconst reporterItemsGetterKey: keyof DynamicMenuThatAcceptsReporters<any> = \"getItems\";\n\nexport const menuProbe = {\n  isSimpleStatic: (menu: Menu<any>): menu is any[] | MenuItem<any>[] => Array.isArray(menu),\n  isSimpleDynamic: (menu: Menu<any>): menu is DynamicMenu<any> => isFunction(menu),\n  isStaticWithReporters: (menu: Menu<any>): menu is MenuThatAcceptsReporters<any> => reporterItemsKey in menu,\n  isDynamicWithReporters: (menu: Menu<any>): menu is DynamicMenuThatAcceptsReporters<any> => reporterItemsGetterKey in menu,\n}\n\nexport const getMenuName = (index: number) => `${index}`;\n\nexport const convertMenuItemsToString = (item: any | MenuItem<any>) =>\n  isPrimitive(item) ? `${item}` : { ...item, value: `${item.value}` };\n\nexport const asStaticMenu = (items: MenuItem<any>[], acceptReporters: boolean) => ({\n  acceptReporters,\n  items: items\n    .map(item => item /**TODO figure out how to format */)\n    .map(convertMenuItemsToString)\n} satisfies ExtensionMenuMetadata);\n\nexport const addOptionsAndGetMenuName = (options: Menu<any>, menus: Menu<any>[],) => {\n  const alreadyAddedIndex = menus.indexOf(options);\n  const menuIndex = alreadyAddedIndex >= 0 ? alreadyAddedIndex : menus.push(options) - 1;\n  return `${getMenuName(menuIndex)}`;\n}\n\nexport const setMenu = (entry: ExtensionArgumentMetadata, options: Menu<any>, menus: Menu<any>[]) =>\n  options ? entry.menu = addOptionsAndGetMenuName(options, menus) : null;","import { BlockMetadata, BlockOperation } from \"$common/types\";\nimport { isFunction } from \"$common/utils\";\n\nexport const format = (text: string, identifier: string, description: string): string => {\n  return text; // make use of formatMessage in the future\n}\n\nexport type BlockGetter<This, Fn extends BlockOperation> = (this: This, self: This) => BlockMetadata<Fn>;\nexport type BlockDefinition<T, Fn extends BlockOperation> = BlockMetadata<Fn> | BlockGetter<T, Fn>;\n\nexport const isBlockGetter = <T, Fn extends BlockOperation>(details: BlockDefinition<any, Fn>): details is BlockGetter<T, Fn> => isFunction(details);\n\nexport const getButtonID = (id: string, opcode: string) => `${id}_${opcode}`;\n\nexport const extractArgNamesFromText = (text: string): string[] => {\n  const textAndNumbersInBrackets = /\\[([A-Za-z0-9]+)\\]/gm;\n  const argNames: string[] = [];\n  for (const [_, result] of text.matchAll(textAndNumbersInBrackets)) {\n    argNames.push(result);\n  }\n  return argNames;\n}","import { Argument, ArgumentType, DynamicMenuThatAcceptsReporters, Menu, MenuThatAcceptsReporters, VerboseArgument } from \"$common/types\";\nimport { isPrimitive, identity } from \"$common/utils\";\n\nexport type Handler = (MenuThatAcceptsReporters<any>['handler']);\nconst isVerbose = (arg: Argument<any>): arg is VerboseArgument<any> => !isPrimitive(arg);\nconst handlerKey: keyof MenuThatAcceptsReporters<any> = 'handler';\nconst hasHandler = (options: Menu<any>): options is MenuThatAcceptsReporters<any> | DynamicMenuThatAcceptsReporters<any> => options && handlerKey in options;\n\nexport const extractHandlers = (args: readonly Argument<any>[]): Handler[] => args.map(element => {\n  if (!isVerbose(element)) return identity;\n  if (element.type === ArgumentType.Image) return identity;\n  const { options } = element;\n  if (!hasHandler(options)) return identity;\n  return options.handler;\n});","import { Argument, ArgumentType, BlockMetadata, BlockOperation, ExtensionArgumentMetadata, InlineImage, Menu, MultipleArgsBlock, OneArgBlock, ValidKey, ValueOf, VerboseArgument } from \"$common/types\";\nimport { assertSameLength, isPrimitive, isString } from \"$common/utils\";\nimport { extractHandlers } from \"./handlers\";\nimport { setMenu } from \"./menus\";\nimport { format } from \"./util\";\n\nexport const getArgName = (index: number) => `${index}`;\n\nconst getArgumentType = <T>(arg: Argument<T>): ValueOf<typeof ArgumentType> =>\n  isPrimitive(arg) ? arg as ValueOf<typeof ArgumentType> : (arg as VerboseArgument<T>).type;\n\n/**\n * Extract an array of args tied to a block \n * @param block \n * @returns An array of 0, 1, or 2+ args\n */\nexport const extractArgs = (block: BlockMetadata<BlockOperation>) => {\n  const argKey: ValidKey<OneArgBlock> = \"arg\";\n  const argsKey: ValidKey<MultipleArgsBlock> = \"args\";\n  if (argKey in block && block[argKey]) return [(block as OneArgBlock).arg];\n  if (argsKey in block && (block[argsKey]?.length ?? 0) > 0) return (block as MultipleArgsBlock).args;\n  return [];\n}\n\n/**\n * Combine arguments' type, name, and handler information into a single structure\n * @param args \n * @param names \n * @returns \n */\nexport const zipArgs = (args: readonly Argument<any>[], names?: string[]) => {\n  const types = args.map(getArgumentType);\n  const handlers = extractHandlers(args);\n  names ??= types.map((_, index) => getArgName(index));\n  assertSameLength(types, handlers, names);\n  return types.map((type, index) => ({ type, name: names[index], handler: handlers[index] }));\n}\n\nexport const convertToArgumentInfo = (opcode: string, args: readonly Argument<any>[], menus: Menu<any>[]) => {\n  if (!args || args.length === 0) return undefined;\n\n  return Object.fromEntries(\n    args\n      .map((element, index) => {\n        if (isInlineImage(element)) return { ...element, dataURI: element.uri };\n\n        const entry = {} as ExtensionArgumentMetadata;\n        entry.type = getArgumentType(element);\n\n        if (isPrimitive(element)) return entry;\n\n        const { defaultValue, options } = element as VerboseArgument<any>;\n\n        setDefaultValue(entry, opcode, index, defaultValue);\n        setMenu(entry, options, menus);\n\n        return entry;\n      })\n      .reduce(\n        (accumulation, entry, index) => accumulation.set(getArgName(index), entry),\n        new Map<string, ExtensionArgumentMetadata>\n      )\n  );\n}\n\nconst getArgTranslationID = (blockname: string, index: number) => `${blockname}-arg${index}-default`;\n\nconst getDefaultValue = (defaultValue: any, opcode: string, index: number) => isString(defaultValue)\n  ? format(defaultValue, getArgTranslationID(opcode, index), `Default value for arg ${index + 1} of ${opcode} block`)\n  : defaultValue;\n\nconst setDefaultValue = (entry: ExtensionArgumentMetadata, opcode: string, index: number, defaultValue: any,) => {\n  if (defaultValue === undefined) return;\n  entry.defaultValue = getDefaultValue(defaultValue, opcode, index)\n}\n\nconst isInlineImage = (arg: Argument<any>): arg is InlineImage => !isString(arg) && arg.type === ArgumentType.Image;","import { AnyBlock, OneArgBlock, MultipleArgsBlock, Argument } from \"$common/types\";\nimport { isString } from \"$common/utils\";\nimport { getArgName } from \"./args\";\nimport { format } from \"./util\";\n\nconst isDynamicText = (text: AnyBlock[\"text\"]): text is (OneArgBlock[\"text\"] | MultipleArgsBlock[\"text\"]) => !isString(text);\n\nexport const convertToDisplayText = (opcode: string, text: AnyBlock[\"text\"], args: readonly Argument<any>[]) => {\n  if (!args || args.length === 0) return text as string;\n\n  if (!isDynamicText(text)) return format(text, opcode, `Block text for '${opcode}'`);\n\n  const textFunc: (...args: any[]) => string = text;\n  const argPlaceholders = args.map((_, index) => `[${getArgName(index)}]`);\n  return format(textFunc(...argPlaceholders), opcode, `Block text for '${opcode}'`);\n}","import { castToType } from \"$common/cast\";\nimport CustomArgumentManager from \"$common/extension/mixins/configurable/customArguments/CustomArgumentManager\";\nimport { ArgumentType, BlockType } from \"$common/types/enums\";\nimport { BlockOperation, ValueOf, Menu, ExtensionMetadata, ExtensionBlockMetadata, ExtensionMenuMetadata, DynamicMenu, BlockMetadata, } from \"$common/types\";\nimport { registerButtonCallback } from \"$common/ui\";\nimport { isString, typesafeCall, } from \"$common/utils\";\nimport type BlockUtility from \"$root/packages/scratch-vm/src/engine/block-utility\";\nimport { menuProbe, asStaticMenu, getMenuName, convertMenuItemsToString } from \"./menus\";\nimport { Handler } from \"./handlers\";\nimport { BlockDefinition, getButtonID, isBlockGetter } from \"./util\";\nimport { convertToArgumentInfo, extractArgs, zipArgs } from \"./args\";\nimport { convertToDisplayText } from \"./text\";\nimport { CustomizableExtensionConstructor, MinimalExtensionInstance, } from \"..\";\nimport { ExtensionInstanceWithFunctionality } from \"../..\";\n\nexport const getImplementationName = (opcode: string) => `internal_${opcode}`;\n\nconst inlineImageAccessError = \"ERROR: This argument represents an inline image and should not be accessed.\";\n\n/**\n * Wraps a blocks operation so that the arguments passed from Scratch are first extracted and then passed as indices in a parameter array.\n * @param _this What will be bound to the 'this' context of the underlying operation\n * @param operation The operation (function) to wrap\n * @param args The args that must be parsed before being passed to the underlying operation \n * @returns \n */\nexport const wrapOperation = <T extends MinimalExtensionInstance>(\n  _this: T,\n  operation: BlockOperation,\n  args: { name: string, type: ValueOf<typeof ArgumentType>, handler: Handler }[]\n) => _this.supports(\"customArguments\")\n    ? function (this: ExtensionInstanceWithFunctionality<[\"customArguments\"]>, argsFromScratch: Record<string, any>, blockUtility: BlockUtility) {\n      const castedArguments = args.map(({ name, type, handler }) => {\n        if (type === ArgumentType.Image) return inlineImageAccessError;\n        const param = argsFromScratch[name];\n        switch (type) {\n          case ArgumentType.Custom:\n            const isIdentifier = isString(param) && CustomArgumentManager.IsIdentifier(param);\n            const value = isIdentifier ? this.customArgumentManager.getEntry(param).value : param;\n            return handler.call(_this, value);\n          default:\n            return castToType(type, handler.call(_this, param));\n        }\n      });\n      return operation.call(_this, ...castedArguments, blockUtility);\n    }\n    : function (this: T, argsFromScratch: Record<string, any>, blockUtility: BlockUtility) {\n      const castedArguments = args.map(({ name, type, handler }) =>\n        type === ArgumentType.Image\n          ? inlineImageAccessError\n          : castToType(type, handler.call(_this, argsFromScratch[name]))\n      );\n      return operation.call(_this, ...castedArguments, blockUtility);\n    }\n\n/**\n * Mixin the ability for extension's to:\n * - build up block definitions incrementally (through the use of `pushBlock`)\n * - implement a valid `getInfo` method that interacts with the scratch-vm correctly  \n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport default function (Ctor: CustomizableExtensionConstructor) {\n  type BlockEntry = { definition: BlockDefinition<ScratchExtension, BlockOperation>, operation: BlockOperation };\n  type BlockMap = Map<string, BlockEntry>;\n  abstract class ScratchExtension extends Ctor {\n    private readonly blockMap: BlockMap = new Map();\n\n    private readonly menus: Menu<any>[] = [];\n    private info: ExtensionMetadata;\n\n    /**\n     * Add a block \n     * @param opcode \n     * @param definition \n     * @param operation \n     */\n    pushBlock<Fn extends BlockOperation>(opcode: string, definition: BlockDefinition<any, Fn>, operation: BlockOperation) {\n      if (this.blockMap.has(opcode)) throw new Error(`Attempt to push block with opcode ${opcode}, but it was already set. This is assumed to be a mistake.`)\n      this.blockMap.set(opcode, { definition, operation });\n    }\n\n    protected getInfo(): ExtensionMetadata {\n      if (!this.info) {\n        const { id, name, blockIconURI } = this;\n        const blocks = Array.from(this.blockMap.entries()).map(entry => this.convertToInfo(entry));\n        const color1 = this.blockColor;\n        const color2 = this.menuColor;\n        const color3 = this.menuSelectColor;\n        this.info = { id, blocks, name, blockIconURI, menus: this.collectMenus(), color1, color2, color3 };\n      }\n      return this.info;\n    }\n\n    private convertToInfo(details: [opcode: string, entry: BlockEntry]) {\n      const [opcode, entry] = details;\n      const { definition, operation } = entry;\n\n      // Utilize explicit casting to appease test framework's typechecker\n      const block = isBlockGetter(definition)\n        ? typesafeCall(definition, this, this) as BlockMetadata<BlockOperation>\n        : definition as BlockMetadata<BlockOperation>;\n\n      const { type, text } = block;\n\n      const args = extractArgs(block);\n\n      const { id, runtime, menus } = this;\n\n      const displayText = convertToDisplayText(opcode, text, args);\n      const argumentsInfo = convertToArgumentInfo(opcode, args, menus);\n\n      const info: ExtensionBlockMetadata = { opcode, text: displayText, blockType: type, arguments: argumentsInfo };\n\n      if (type === BlockType.Button) {\n        const buttonID = getButtonID(id, opcode);\n        registerButtonCallback(runtime, buttonID, operation.bind(this));\n        info.func = buttonID;\n      } else {\n        const implementationName = getImplementationName(opcode);\n        this[implementationName] = wrapOperation(this as MinimalExtensionInstance, operation, zipArgs(args));\n      }\n\n      return info;\n    }\n\n    private collectMenus() {\n      const { isSimpleStatic, isSimpleDynamic, isStaticWithReporters, isDynamicWithReporters } = menuProbe;\n      return Object.fromEntries(\n        this.menus\n          .map((menu, index) => {\n            if (isSimpleStatic(menu)) return asStaticMenu(menu, false);\n            if (isSimpleDynamic(menu)) return this.registerDynamicMenu(menu, false, index);\n            if (isStaticWithReporters(menu)) return asStaticMenu(menu.items, true);\n            if (isDynamicWithReporters(menu)) return this.registerDynamicMenu(menu.getItems, true, index);\n            throw new Error(\"Unable to process menu\");\n          })\n          .reduce((map, menu, index) => map.set(getMenuName(index), menu), new Map<string, ExtensionMenuMetadata>())\n      );\n    }\n\n    private registerDynamicMenu(getItems: DynamicMenu<any>, acceptReporters: boolean, menuIndex: number) {\n      const key = `internal_dynamic_${menuIndex}`; // legacy support?\n      this[key] = () => getItems.call(this).map(item => item).map(convertMenuItemsToString);\n      return { acceptReporters, items: key } satisfies ExtensionMenuMetadata\n    }\n  }\n\n  return ScratchExtension;\n}","import type BlockUtility from \"$scratch-vm/engine/block-utility\";\nimport { TypedClassDecorator, TypedGetterDecorator, TypedMethodDecorator, TypedSetterDecorator } from \".\";\nimport { BlockType } from \"$common/types/enums\";\nimport { BlockMetadata, ScratchArgument, Argument } from \"$common/types\";\nimport { getImplementationName } from \"../mixins/base/scratchInfo/index\";\nimport { ExtensionInstance } from \"..\";\nimport { isFunction, isString, tryCreateBundleTimeEvent } from \"$common/utils\";\nimport { extractArgs } from \"../mixins/base/scratchInfo/args\";\n\ntype BlockFunctionMetadata = {\n  methodName: string,\n  scratchType: string,\n  args: string[],\n  returns: string,\n}\n\nexport const blockBundleEvent = tryCreateBundleTimeEvent<BlockFunctionMetadata>(\"blocks\");\n\nexport const getAccessorPrefix = \"__getter__\";\nexport const setAccessorPrefix = \"__setter__\";\n\n/**\n * This a decorator function that should be associated with methods of your Extension class, all in order to turn your class methods\n * into Blocks that can be executed in the Block Programming Environment.\n * @param {BlockMetadata} blockInfoOrGetter Either an object or a function that returns an object of the following specified shapes \n * (which shape is required depends on your method's argument(s)):\n * @example \n * Block method accepts no arguments\n * ```ts\n * {\n *  type: BlockType, // e.g. \"reporter\", \"command\"\n *  text: string // the display text of your block\n * }\n * ```\n * @example \n * Block method accepts one argument\n * ```ts\n * {\n *  type: BlockType, // e.g. \"reporter\", \"command\"\n *  text: (arg) => string, // a function that returns a string, hover over the 'text' field in your code for more thourough documentation\n *  arg: Argument, // hover over the 'arg' field in your code for more thourough documentation\n * }\n * ```\n* @example \n * Block method accepts 2 or more arguments\n * ```ts\n * {\n *  type: BlockType, // e.g. \"reporter\", \"command\"\n *  text: (...args) => string, // a function that returns a string, hover over the 'text' field in your code for more thourough documentation\n *  args: Argument[], // hover over the 'args' field in your code for more thourough documentation\n * }\n * ```\n * @returns A manipulated version of the original method that is\n */\nexport function block<\n  const This extends ExtensionInstance,\n  const Args extends any[],\n  const Return,\n  const Fn extends (...args: Args) => Return,\n  const TRemoveUtil extends any[] = Args extends [...infer R extends any[], BlockUtility] ? R : Args,\n>\n  (\n    blockInfoOrGetter: (BlockMetadata<(...args: TRemoveUtil) => Return> | ((this: This, self: This) => BlockMetadata<(...args: TRemoveUtil) => Return>))\n  ): TypedMethodDecorator<This, Args, Return, (...args: Args) => Return> {\n\n  return function (this: This, target: (this: This, ...args: Args) => Return, context: ClassMethodDecoratorContext<This, Fn>) {\n    const opcode = target.name;\n    const internalFuncName = getImplementationName(opcode);\n    // could add check for if this block is meant for scratch\n    context.addInitializer(function () { this.pushBlock(opcode, blockInfoOrGetter, target) });\n\n    const isProbableAtBundleTime = !isFunction(blockInfoOrGetter);\n    if (isProbableAtBundleTime) {\n      const { type } = blockInfoOrGetter;\n      blockBundleEvent?.fire({\n        methodName: opcode,\n        args: extractArgs(blockInfoOrGetter).map(a => isString(a) ? a : a.type),\n        // is 'any' an issue? Likely!\n        returns: type === \"command\" ? \"void\" : type === \"Boolean\" ? \"bool\" : \"any\",\n        scratchType: blockInfoOrGetter.type\n      });\n    }\n\n    return (function () { return this[internalFuncName].call(this, ...arguments) });\n  };\n}\n\n/**\n * This is a short-hand for invoking the block decorator when your `blockType` is button\n * @param text \n * @returns \n * @see {@link block} \n * @example\n * // Ignore the leading \"_\"\n * _@buttonBlock(\"The text of button block\")\n * buttonMethod() {\n *    this.openUI(\"someUI\")\n * }\n * \n */\nexport function buttonBlock<\n  This extends ExtensionInstance,\n>(text: string): TypedMethodDecorator<This, [], void, () => void> {\n  type Args = [] | [BlockUtility];\n  type Return = void;\n  type Fn = (...args: Args) => Return;\n\n  return block<This, Args, Return, Fn>({\n    text,\n    type: BlockType.Button\n  });\n}\n\nexport type PropertyBlockDetails<T> = {\n  /** \n   * The name of the property, which is both displayed to the user and used to associate the getter and setter blocks.\n   * \n   * **NOTE:** Associated getter and setter blocks should use the same `name`. Thus, it is best practice to define this name as a constant. \n  */\n  name: string,\n  /**\n   * The type of property \n   */\n  type: ScratchArgument<T>\n};\n\n/**\n * A block decorator for creating a reporer block out of a `get` accessor / \"getter\" property.\n * \n * @see https://www.typescriptlang.org/docs/handbook/classes.html#accessors \n * @param details \n * @returns \n */\nexport function getterBlock<This extends ExtensionInstance, TReturn>\n  (details: PropertyBlockDetails<TReturn>): TypedGetterDecorator<This, TReturn> {\n  return function (this: This, target: (this: This) => TReturn, context: ClassGetterDecoratorContext<This, TReturn>) {\n    const opcode = target.name.replace(\"get \", getAccessorPrefix);\n    const internalFuncName = getImplementationName(opcode);\n\n    context.addInitializer(function () {\n      this[opcode] = (_, util) => this[internalFuncName].call(this, null, util);;\n      const text = `Get ${details.name}`;\n      this.pushBlock(opcode, { type: \"reporter\", text }, target);\n    });\n\n    blockBundleEvent?.fire({\n      methodName: opcode,\n      args: [],\n      returns: details.type,\n      scratchType: \"reporter\"\n    });\n  }\n}\n\n/**\n * A block decorator for creating a command block out of a `set` accessor / \"setter\" property.\n * \n * @param details \n * @returns \n */\nexport function setterBlock<This extends ExtensionInstance, TValue>\n  (details: PropertyBlockDetails<TValue>): TypedSetterDecorator<ExtensionInstance, TValue> {\n  return function (this: This, target: (this: This, value: TValue) => void, context: ClassSetterDecoratorContext<This, TValue>) {\n    const opcode = target.name.replace(\"set \", setAccessorPrefix);\n    const internalFuncName = getImplementationName(opcode);\n\n    context.addInitializer(function () {\n      this[opcode] = (args, util) => this[internalFuncName].call(this, args, util);\n      const text = (value: TValue) => `Set ${details.name} to ${value}`;\n      const arg = details.type as Argument<TValue>;\n      type Fn = (this: This, value: any, util: BlockUtility) => void;\n      const blockInfo = { type: BlockType.Command, text, arg } as BlockMetadata<Fn>;\n      this.pushBlock<Fn>(opcode, blockInfo, target);\n    });\n\n    blockBundleEvent?.fire({\n      methodName: opcode,\n      args: [details.type],\n      returns: \"void\",\n      scratchType: \"command\"\n    });\n  }\n}","import { legacySupportWithInfoArgument } from \"$common/extension/mixins/configurable/legacySupport\";\nimport { ExtensionMetadata, ExtensionBlockMetadata, ExtensionMenuItems, BlockOperation, Argument, ExtensionMenuMetadata, ExtensionDynamicMenu, Menu, DynamicMenuThatAcceptsReporters, BaseGenericExtension, VerboseArgument, DefineBlock, AbstractConstructor, NonAbstractConstructor, BlockMetadata } from \"$common/types\";\nimport { isFunction, isString } from \"$common/utils\";\nimport { block } from \"../blocks\";\nimport { ArgumentMethods, BlockDecorators, BlockDefinitions, BlockEntry, BlockMap, LegacyExtension, LegacyExtensionDecorator, LegacySupport, ObjectOrGetter } from \"./types\";\nimport { ExtensionInstance } from \"$common/extension\";\n\n/**\n * \n * @param info \n * @param flags \n * @returns \n */\nexport const legacy = <\n  const TInfo extends ExtensionMetadata,\n  TFlags extends { incrementalDevelopment: boolean } = undefined,\n  const TStrict extends boolean = TFlags extends { incrementalDevelopment: false } | undefined ? true : false\n>(info: TInfo, flags?: TFlags): LegacySupport<TInfo, TStrict> => ({\n\n  for<TExtension extends LegacyExtension<TInfo, TStrict>>() {\n\n    const legacyExtension = (): LegacyExtensionDecorator<TExtension> => (value, context) => {\n      abstract class LegacySupport extends legacySupportWithInfoArgument(value as AbstractConstructor<ExtensionInstance>, info) {\n        readonly originalClassName = context.name;\n      };\n\n      return LegacySupport as AbstractConstructor<ExtensionInstance> as NonAbstractConstructor<TExtension>;\n    };\n\n    const blockMethodBroker = getBlockMetaData(info).map(([opcode, entry]) => {\n      const key = opcode as keyof BlockDefinitions<TInfo, TExtension>;\n      return {\n        key,\n        definer: createBlockDefiner<TExtension & BaseGenericExtension>(entry),\n        decorator: createBlockDecorator<TExtension & ExtensionInstance>(entry)\n      }\n    });\n\n    const legacyDefinition = blockMethodBroker.reduce((definitions, { key, definer }) => {\n      definitions[key] = definer as any; // TODO: See if we can get this type to work\n      return definitions;\n    }, {} as BlockDefinitions<TInfo, TExtension>);\n\n\n    const legacyBlock = blockMethodBroker.reduce((decorators, { key, decorator }) => {\n      decorators[key] = decorator as any; // TODO: See if we can get this type to work\n      return decorators;\n    }, {} as BlockDecorators<TInfo>);\n\n    const throwTypeOnlyError = () => {\n      throw new Error(\"This property is not meant to be accessed, and is instead solely for type inference / documentation purposes.\")\n    };\n\n    return {\n      legacyExtension, legacyDefinition, legacyBlock,\n      ReservedNames: {\n        get Menus(): any { return throwTypeOnlyError() },\n        get Blocks(): any { return throwTypeOnlyError() },\n        get ArgumentNamesByBlock(): any { return throwTypeOnlyError() },\n      },\n    };\n  }\n})\n\n/**\n * Creates a function that returns a function that acts as a block definition for the 'entry' block metadata.\n * @param entry \n * @returns \n */\nconst createBlockDefiner = <TExtension extends ExtensionInstance & BaseGenericExtension>(entry: BlockEntry) =>\n  (objOrGetter: ObjectOrGetter<{ opertation: BlockOperation } & Partial<ArgumentMethods<any, any>>, TExtension>) =>\n    ((extension: TExtension) => {\n      const { operation, argumentMethods } = isFunction(objOrGetter) ? objOrGetter.call(extension, extension) : objOrGetter;\n      if (argumentMethods) attachArgumentMethods(entry, argumentMethods, extension);\n      return { ...entry, operation }\n    }) as DefineBlock<TExtension, BlockOperation>;\n\n/**\n * Creates a function that returns a decorator function that wraps the data contained within 'entry'.\n * @param entry \n * @returns \n */\nconst createBlockDecorator = <TExtension extends ExtensionInstance>(entry: BlockEntry) =>\n  (...params: ([ObjectOrGetter<ArgumentMethods<any, any>, TExtension>] | [])) => {\n    if (params.length === 0 || !params[0]) return block<TExtension, any[], any, any>(entry as BlockMetadata<any>);\n    const objOrGetter = params[0];\n    return block<TExtension, any[], any, any>((extension: TExtension) => {\n      const { argumentMethods } = isFunction(objOrGetter)\n        ? objOrGetter.call(extension, extension) : objOrGetter;\n\n      attachArgumentMethods(entry, argumentMethods, extension);\n      return entry as BlockMetadata<any>;\n    });\n  }\n\nconst attachArgumentMethods = (\n  block: ReturnType<BlockMap[\"get\"]>,\n  argumentMethods: Record<number, Partial<DynamicMenuThatAcceptsReporters<unknown>>>,\n  extension: ExtensionInstance\n) => {\n  const args = block.args ? block.args : block.arg ? [block.arg] : [];\n\n  Object.entries(argumentMethods)\n    .map(([indexKey, { handler, getItems }]) => {\n      const arg = args[parseInt(indexKey)] as VerboseArgument<any>;\n      return { arg, methods: { handler, getItems } }\n    })\n    .forEach(({ arg, methods }) =>\n      Object.entries(methods)\n        .filter(([_, method]) => method !== undefined)\n        .map(([key, method]) => [key, method.bind(extension)])\n        .forEach(([key, method]) => tryUpdateKey(arg, key, method)))\n}\n\nconst tryUpdateKey = <T extends Menu<any>>(arg: VerboseArgument<any>, key: string, value: T) => {\n  if (isFunction(arg.options)) arg.options = value;\n  arg.options[key] = value;\n}\n\nconst asBlockMetaData = (block: ExtensionBlockMetadata | string) => {\n  if (isString(block)) throw new Error(`Block defined as string, unexpected! ${block}`)\n  return block as ExtensionBlockMetadata;\n}\n\nconst convertAndInsertBlock = (map: BlockMap, block: ExtensionBlockMetadata, metadata: ExtensionMetadata) => {\n  const { opcode, arguments: _arguments, blockType: type } = block;\n  const { text, orderedNames } = parseText(block);\n\n  if (!_arguments) return map.set(opcode, { type, text });\n\n  const args = Object.entries(_arguments ?? {})\n    .map(([name, { menu, ...rest }]) => ({ options: extractMenuOptions(metadata, menu), name, menu, ...rest }))\n    .sort(({ name: a }, { name: b }) => orderedNames.indexOf(a) < orderedNames.indexOf(b) ? -1 : 1)\n    .map(({ name, ...details }) => details satisfies Argument<any> as Argument<unknown>);\n\n  const { length } = args;\n  return length >= 2\n    ? map.set(opcode, { type, text, args: args as [] })\n    : map.set(opcode, { type, text, arg: args[0] })\n}\n\nconst getBlockMetaData = (metadata: ExtensionMetadata) => Array.from(\n  metadata.blocks\n    .map(asBlockMetaData)\n    .reduce((map, block) => convertAndInsertBlock(map, block, metadata), new Map() as BlockMap)\n    .entries()\n);\n\nexport const parseText = ({ arguments: _arguments, text }: ExtensionBlockMetadata) => {\n  const placeholder = \"Error: This should have been overridden by legacy support\";\n\n  if (!_arguments) return { orderedNames: null as null, text: placeholder };\n\n  const args = Object.keys(_arguments)\n    .map(name => ({ name, template: `[${name}]` }))\n    .sort(({ template: a }, { template: b }) => text.indexOf(a) < text.indexOf(b) ? -1 : 1);\n\n  return args.length === 0\n    ? { orderedNames: null as null, text: placeholder }\n    : { orderedNames: args.map(({ name }) => name), text: () => placeholder }\n}\n\nconst getItemsPlaceholder = { getItems: () => (\"Error: This should have been filled in.\" as any) };\nconst handlerPlaceholder = { handler: () => (\"Error: This should have been filled in.\" as any) };\n\nexport const isDynamicMenu = (menu: ExtensionMenuMetadata | ExtensionMenuItems[\"items\"]): menu is ExtensionDynamicMenu => isString(menu);\n\nconst extractMenuOptions = (data: ExtensionMetadata, menuName: string): Menu<any> => {\n  const menu = menuName ? data.menus[menuName] : undefined;\n\n  if (!menu) return undefined;\n  if (isDynamicMenu(menu)) return getItemsPlaceholder.getItems;\n\n  const { items, acceptReporters: acceptsReporters } = menu;\n\n  if (!isDynamicMenu(items)) return acceptsReporters ? { acceptsReporters, items: [...items], ...handlerPlaceholder } : [...items];\n\n  return acceptsReporters ? { acceptsReporters, ...handlerPlaceholder, ...getItemsPlaceholder } : getItemsPlaceholder.getItems;\n}","import { ExtensionInstance } from \"$common/extension\";\nimport { AbstractConstructor, ExtensionArgumentMetadata, ExtensionBlockMetadata, ExtensionMenuMetadata, ExtensionMetadata } from \"$common/types\";\nimport { isString, set } from \"$common/utils\";\nimport { isDynamicMenu, parseText } from \"../../decorators/legacySupport/index\";\nimport { MinimalExtensionConstructor } from \"../base\";\nimport { getImplementationName, wrapOperation } from \"../base/scratchInfo/index\";\n\ntype WrappedOperation = ReturnType<typeof wrapOperation>;\ntype WrappedOperationParams = Parameters<WrappedOperation>;\ntype WithLegacySupport = InstanceType<ReturnType<typeof legacySupportMixin>>;\ntype BlockMap = Map<string, Omit<ExtensionBlockMetadata, \"opcode\"> & { index: number }>;\n\nexport const isLegacy = (extension: ExtensionInstance | WithLegacySupport): extension is WithLegacySupport => {\n  const key: keyof WithLegacySupport = \"__isLegacy\";\n  return key in extension;\n}\n\nconst validBlock = (legacyBlock: string | ExtensionBlockMetadata, blockMap: BlockMap): legacyBlock is ExtensionBlockMetadata => {\n  if (isString(legacyBlock)) throw new Error(\"Block was unexpectedly a string: \" + legacyBlock);\n  if (!blockMap.has(legacyBlock.opcode)) {\n    console.error(`Could not find legacy opcode ${legacyBlock.opcode} within currently defined blocks`);\n    return false;\n  };\n  return true;\n}\n\nconst validArg = (pair: { legacy: ExtensionArgumentMetadata, modern: ExtensionArgumentMetadata }): typeof pair => {\n  if (typeof pair.legacy.menu !== typeof pair.modern.menu) throw new Error(\"Menus don't match\")\n  return pair;\n}\n\nconst getDynamicMenuName = (menu: ExtensionMenuMetadata): string => {\n  if (isDynamicMenu(menu)) return menu;\n  if (isDynamicMenu(menu.items)) return menu.items;\n  throw new Error(\"Menu is not dynamic: \" + menu);\n}\n\n/**\n * Mixin the ability for extensions to make use of 'legacy' `getInfo` json, \n * so that extensions ported to the framework can support old, serialized projects\n * @param Ctor \n * @param legacyInfo \n * @returns \n */\nexport default function legacySupportMixin<T extends MinimalExtensionConstructor>(Ctor: T) {\n  abstract class ExtensionWithLegacySupport extends Ctor {\n    private validatedInfo: ExtensionMetadata;\n\n    protected abstract getLegacyInfo(): ExtensionMetadata;\n\n    public __isLegacy = true;\n    public orderArgumentNamesByBlock: Map<string, string[]> = new Map();\n\n    protected override getInfo(): ExtensionMetadata {\n      if (!this.validatedInfo) {\n        const info = super.getInfo();\n        this.validatedInfo = this.validateAndAttach(info);\n      }\n\n      return this.validatedInfo;\n    }\n\n    private getArgNames = (legacyBlock: ExtensionBlockMetadata) => {\n      const { opcode } = legacyBlock;\n\n      if (!this.orderArgumentNamesByBlock.has(opcode)) {\n        const { orderedNames } = parseText(legacyBlock);\n        this.orderArgumentNamesByBlock.set(opcode, orderedNames);\n      }\n\n      return this.orderArgumentNamesByBlock.get(opcode);\n    }\n\n    private validateAndAttach({ id, blocks, menus, ...metaData }: ExtensionMetadata): ExtensionMetadata {\n      const { id: legacyID, blocks: legacyBlocks, menus: legacyMenus } = this.getLegacyInfo();\n      const mutableBlocks = [...blocks as ExtensionBlockMetadata[]];\n\n      if (id !== legacyID) throw new Error(`ID mismatch! Legacy id: ${legacyID} vs. current id: ${id}`);\n\n      const blockMap = mutableBlocks.reduce(\n        (map, { opcode, ...block }, index) => map.set(opcode, { ...block, index }),\n        new Map() as BlockMap\n      );\n\n      const self = this;\n\n      const updates = legacyBlocks\n        .map(legacyBlock => validBlock(legacyBlock, blockMap) ? legacyBlock : undefined)\n        .filter(Boolean)\n        .map(legacyBlock => {\n          const { opcode, arguments: legacyArgs } = legacyBlock;\n          const { index, arguments: modernArgs } = blockMap.get(opcode);\n          const argNames = this.getArgNames(legacyBlock);\n\n          if (!argNames) return { replaceAt: { index, block: legacyBlock } };\n\n          const remapper = (args: Record<string, any>) => argNames.reduce(\n            (remap, current, index) => set(remap, index, args[current]),\n            {} as Record<number, any>);\n\n          const implementation: WrappedOperation = this[getImplementationName(opcode)];\n\n          this[opcode] = (\n            (...[args, util]: WrappedOperationParams) => implementation.call(self, remapper(args), util)\n          ).bind(self);\n\n          const menuUpdates = argNames\n            .map((legacyName, index) => ({ legacy: legacyArgs[legacyName], modern: modernArgs[index] }))\n            .map(validArg)\n            .map(({ legacy: { menu: legacyName }, modern: { menu: modernName } }) => ({ legacyName, modernName }))\n            .filter(menus => menus.legacyName && menus.modernName)\n            .map(({ legacyName, modernName }) =>\n              ({ legacyName, modernName, legacy: legacyMenus[legacyName], modern: menus[modernName] }))\n            .map(({ legacy, modern, legacyName, modernName }) => !isDynamicMenu(legacy) && !isDynamicMenu(legacy.items)\n              ? { type: \"static\" as const, legacy: legacyName, modern: modernName }\n              : { type: \"dynamic\" as const, legacy: legacyName, modern: modernName, methods: { legacy: getDynamicMenuName(legacy), modern: getDynamicMenuName(modern) } }\n            );\n\n          return { menuUpdates, replaceAt: { index, block: legacyBlock } };\n        });\n\n      updates.forEach(({ replaceAt: { index, block } }) => mutableBlocks[index] = block);\n\n      updates\n        .map(({ menuUpdates }) => menuUpdates)\n        .flat()\n        .filter(Boolean)\n        .map(menu => {\n          const { legacy } = menu;\n          if (legacy in menus) throw new Error(`Somehow, there was already a menu called ${legacy}, which will cause issues in the next step.`);\n          return menu;\n        })\n        .forEach(({ type, legacy, methods }) => {\n          menus[legacy] = legacyMenus[legacy];\n          if (type === \"dynamic\") self[methods.legacy] = () => self[methods.modern]();\n        });\n\n      return {\n        id, blocks: mutableBlocks, menus, ...metaData\n      };\n    }\n  }\n  return ExtensionWithLegacySupport\n}\n\n/**\n * Mixin the ability for extensions to make use of 'legacy' `getInfo` json, \n * so that extensions ported to the framework can support old, serialized projects\n * @param Ctor \n * @param legacyInfo \n * @returns \n */\nexport function legacySupportWithInfoArgument<T extends AbstractConstructor<ExtensionInstance>>(Ctor: T, legacyInfo: ExtensionMetadata) {\n  abstract class ExtensionWithLegacySupport extends legacySupportMixin(Ctor) {\n    protected getLegacyInfo() {\n      return legacyInfo;\n    }\n  }\n\n  return ExtensionWithLegacySupport\n}","import { ExtensionInstanceWithFunctionality } from \"../..\";\n\nexport const isSvgGroup = (element: Element): element is SVGGElement => element.nodeName === \"g\";\nexport const isSvgText = (element: Element): element is SVGTextElement => element.nodeName === \"text\";\n\ntype AlertType = Parameters<ExtensionInstanceWithFunctionality<[\"indicators\"]>[\"indicate\"]>[0][\"type\"];\n\nconst fills = {\n  success: \"#5ACA75\",\n  warning: \"#FF8f39\",\n  error: \"#db1f1f\"\n} satisfies Record<AlertType, string>;\n\nconst textAttributes = {\n  fill: \"white\",\n  \"font-weight\": \"bold\",\n  \"font-size\": \"14pt\",\n  \"font-family\": \"\\\"Helvetica Neue\\\", Helvetica, Arial, sans-serif;\"\n}\n\nexport async function openAlert(container: SVGGElement, msg: string, type: AlertType) {\n  const elements = createElements();\n  const [rect, triangle, text] = elements;\n\n  const padding = 12;\n  const y = 55;\n  const x = 0;\n  const fill = fills[type];\n\n  applyAttributes(triangle, { points: equilateralTrianglePoints, fill });\n  applyAttributes(text, { x: x + padding / 2, y });\n  applyAttributes(text, textAttributes);\n\n  text.innerHTML = msg;\n\n  elements.forEach(el => container.appendChild(el));\n\n  await Promise.resolve(); // await for elements to render (is there a better way?)\n\n  const { width, height } = text.getBBox();\n  applyAttributes(rect, { x, width: width + padding, height: height + padding, y: y - height, fill, rx: 5 });\n\n  return {\n    close() { elements.forEach(element => container.removeChild(element)); }\n  };\n}\n\nconst applyAttributes = <T extends Record<string, any>>(element: Element, attributes: T) => {\n  for (const key in attributes) {\n    element.setAttribute(key, `${attributes[key]}`);\n  }\n}\n\nconst createElements = () => [createElement(\"rect\"), createElement(\"polygon\"), createElement(\"text\")] as const;\n\nconst createElement = <T extends \"text\" | \"rect\" | \"polygon\">(type: T) =>\n  document.createElementNS('http://www.w3.org/2000/svg', type);\n\nconst getEquilateralTrianglePoints = () => {\n  const reduction = { x: 5, y: 14 };\n  const shift = { x: 10, y: 26 };\n  return [[50, 15], [100, 100], [0, 100]]\n    .map(([x, y]) => [x / reduction.x + shift.x, y / reduction.y + shift.y])\n    .map(([x, y]) => `${x} ${y}`)\n    .join(\", \");\n}\n\nconst equilateralTrianglePoints = getEquilateralTrianglePoints();","import { MinimalExtensionConstructor } from \"../../base\";\nimport { isSvgGroup, isSvgText, openAlert } from \"./svgAlert\";\n\n/**\n * Mixin the ability for extensions to add an indicator message to the workspace.\n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport default function <T extends MinimalExtensionConstructor>(Ctor: T) {\n  abstract class ExtensionThatIndicates extends Ctor {\n    /**\n     * Add an indicator message to the workspace.\n     * @param param0 Details\n     * - `position`: Where to place the indicator. Currently only \"category\" is supported, which places the message immediately below the extensions name.\n     * - `msg`: The message to display.\n     * - `type`: The type of indicator to display. Currently \"success\", \"warning\" and \"error\", which effect the color of the indicator.\n     * @returns \n     */\n    async indicate({ position, msg, type }: { position: \"category\", msg: string, type: \"success\" | \"warning\" | \"error\" }) {\n\n      const elements = position === \"category\"\n        ? getCategoryElements(this.name)\n        : { error: \"Unsupported indicator position\" };\n\n      if (\"error\" in elements) throw new Error(elements.error);\n      const { container } = elements;\n      const alert = await openAlert(container, msg, type);\n      return alert;\n    }\n  }\n\n  return ExtensionThatIndicates;\n}\n\nconst topLevelClass = \"blocklyFlyout\";\nconst containerClass = \"blocklyFlyoutLabel categoryLabel\";\nconst textClass = \"blocklyFlyoutLabelText\";\n\nconst getCategoryElements = (text: string): { error: string } | { container: SVGGElement, title: SVGTextElement } => {\n  const topLevel = document.body.getElementsByClassName(topLevelClass);\n  if (topLevel.length !== 1) return { error: \"No top level element found.\" };\n\n  for (const container of topLevel[0].getElementsByClassName(containerClass)) {\n    for (const title of container.getElementsByClassName(textClass)) {\n      if (title.innerHTML !== text || !isSvgGroup(container) || !isSvgText(title)) continue;\n      return { container, title };\n    }\n  }\n  return { error: \"No title found matching given name\" };\n}","import type Video from \"$scratch-vm/io/video\";\nimport { MinimalExtensionConstructor } from \"../base\";\n\nconst Format = {\n  image: \"image-data\",\n  canvas: \"canvas\"\n} as const satisfies {\n  image: (typeof Video)[\"FORMAT_IMAGE_DATA\"],\n  canvas: (typeof Video)[\"FORMAT_CANVAS\"];\n}\n\ntype VideoFrameTypeByFormat = {\n  \"image-data\": ImageData,\n  \"canvas\": HTMLCanvasElement\n}\n\n/**\n * Mixin the ability for extensions to interact with the user's web cam video feed\n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport default function <T extends MinimalExtensionConstructor>(Ctor: T) {\n  abstract class ExtensionWithVideoSupport extends Ctor {\n    private videoDevice: Video | null;\n\n    private get video(): Video | null {\n      this.videoDevice ??= this.runtime.ioDevices?.video;\n      return this.videoDevice;\n    };\n\n    /**\n     * Dimensions of the video frame\n     */\n    videoDimensions = { width: 480, height: 360 } as const;\n\n    /**\n     * Access the most recent frame captured by the web cam\n     * @param {\"image\" | \"canvas\"} format \n     * @returns \n     */\n    getVideoFrame<TFormat extends keyof typeof Format>(format: TFormat) {\n      return this.video?.getFrame({\n        format: Format[format]\n      }) as VideoFrameTypeByFormat[typeof Format[typeof format]]\n    }\n\n    setVideoTransparency(transparency: number) {\n      this.video?.setPreviewGhost(transparency);\n    }\n\n    /**\n     * Turn the video feed on so that it's frames can be accessed and the feed\n     * diplays within the game window.\n     * @param {boolean} mirror defaults to `true`\n     * @returns \n     */\n    enableVideo(mirror: boolean = true) {\n      if (!this.video) return;\n      this.video.enableVideo();\n      this.video.provider.mirror = mirror;\n    }\n\n    /**\n     * Disable the video feed\n     */\n    disableVideo() {\n      this.video?.disableVideo();\n    }\n  }\n\n  return ExtensionWithVideoSupport;\n}\n","import { AbstractConstructor } from \"$common/types\";\nimport addCostumes from \"./configurable/addCostumes/index\";\nimport customArguments from \"./configurable/customArguments/index\";\nimport customSaveData from \"./configurable/customSaveData\";\nimport drawable from \"./configurable/drawable\";\nimport legacySupport from \"./configurable/legacySupport\";\nimport ui from \"./configurable/ui\";\nimport indicators from \"./configurable/indicators\";\nimport video from \"./configurable/video\";\nimport setTransparencyBlock from \"./configurable/blocks/setVideoTransparency\";\nimport toggleVideoBlock from \"./configurable/blocks/toggleVideoState\";\nimport appInventor from \"./configurable/appInventor/index\";\nimport { MinimalExtensionConstructor } from \"./base\";\n\nexport type Mixin<T> = (Ctor: MinimalExtensionConstructor) => AbstractConstructor<T>;\n\nexport const optionalMixins = {\n  customArguments,\n  ui,\n  customSaveData,\n  video,\n  drawable,\n  addCostumes,\n  legacySupport,\n  setTransparencyBlock,\n  toggleVideoBlock,\n  appInventor,\n  indicators,\n} as const satisfies OptionalMixins satisfies Record<string, Mixin<unknown>>;\n\nexport type OptionalMixins<T extends MinimalExtensionConstructor = MinimalExtensionConstructor> = {\n  ui: typeof ui<T>;\n  customArguments: typeof customArguments<T>,\n  customSaveData: typeof customSaveData<T>,\n  video: typeof video<T>,\n  drawable: typeof drawable<T>,\n  addCostumes: typeof addCostumes<T>,\n  legacySupport: typeof legacySupport<T>,\n  setTransparencyBlock: typeof setTransparencyBlock<T>,\n  toggleVideoBlock: typeof toggleVideoBlock<T>,\n  appInventor: typeof appInventor<T>,\n  indicators: typeof indicators<T>,\n}\n\nexport type MixinName = keyof typeof optionalMixins;\n\nexport type ExtensionWithFunctionality<TSupported extends MixinName[], TBase extends MinimalExtensionConstructor = MinimalExtensionConstructor> =\n  TSupported extends [infer Head, ...infer Tail]\n  /** Use `extends` to enable typescript to infer desired characteristics */\n  ? Head extends keyof OptionalMixins ? Tail extends (keyof OptionalMixins)[] ? TBase extends MinimalExtensionConstructor\n  /** Accumalate the TBase parameter */\n  ? ExtensionWithFunctionality<Tail, ReturnType<OptionalMixins<TBase>[Head]>>\n  /** Return never as Head, Tail, and TBase should never not meet the above type requirements */\n  : never : never : never\n  /** Base case */\n  : TBase;\n\nexport type ExtensionInstanceWithFunctionality<TSupported extends MixinName[]> = InstanceType<ExtensionWithFunctionality<TSupported>>;","import CustomArgumentManager from \"$common/extension/mixins/configurable/customArguments/CustomArgumentManager\";\nimport { ArgumentType } from \"$common/types/enums\";\nimport { guiDropdownInterop } from \"$common/globals\";\nimport { Argument, MenuItem } from \"$common/types\";\nimport { MinimalExtensionConstructor } from \"../../base\";\nimport { withDependencies } from \"../../dependencies\";\nimport customSaveData from \"../customSaveData\";\nimport { ArgumentEntry, ArgumentID, CustomArgumentComponent, CustomArgumentRecipe, RuntimeWithCustomArgumentSupport, renderToDropdown } from \"./utils\";\nimport { ExtensionBase } from \"$common/extension/ExtensionBase\";\n\n/**\n * Mixin the ability for extensions to create custom argument types with their own specific UIs\n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport default function mixin<T extends MinimalExtensionConstructor>(Ctor: T) {\n  abstract class ExtensionWithCustomArgumentSupport extends withDependencies(Ctor, customSaveData) {\n    /**\n     * Create a custom argument for one of this block's arguments\n     */\n    protected makeCustomArgument = <T, TExtension extends ExtensionBase>({ component, initial, acceptReportersHandler: handler }: CustomArgumentRecipe<T, TExtension>): Argument<T> => {\n      this.argumentManager ??= new CustomArgumentManager();\n      const id = this.argumentManager.add(initial);\n      const getItems = () => this.processMenuForCustomArgument(id, component);\n      return {\n        type: ArgumentType.Custom,\n        defaultValue: id,\n        options: handler === undefined ? getItems : { acceptsReports: true, getItems, handler },\n      } as Argument<T>\n    }\n\n    protected argumentManager: CustomArgumentManager = null;\n\n    public get customArgumentManager(): CustomArgumentManager {\n      return this.argumentManager\n    }\n\n    public getOrCreateCustomArgumentManager(): CustomArgumentManager {\n      this.argumentManager ??= new CustomArgumentManager();\n      return this.argumentManager;\n    }\n\n    /**\n     * Utilized externally by scratch-vm to process custom arguments\n     * @param runtime NOTE: once we switch to V2, we can remove this and instead use the extension's runtime\n     * @param param1 \n     * @param getComponent \n     * @returns \n     */\n    private processMenuForCustomArgument(initialID: ArgumentID, Component: CustomArgumentComponent): (ArgumentEntry<any>)[] {\n      const { runtime, argumentManager } = this;\n      const interop = (runtime as RuntimeWithCustomArgumentSupport)[guiDropdownInterop.runtimeKey];\n\n      const { state, update, entry } = interop\n\n      switch (state) {\n        case \"init\":\n          return argumentManager.getCurrentEntries();\n        case \"open\": {\n          const id = entry?.value ?? initialID;\n          const current = argumentManager.getEntry(id);\n          const setter = argumentManager.request(update);\n          renderToDropdown(Component, { setter, current, extension: this });\n          return [{ text: current.text, value: id }];\n        }\n        case \"update\": {\n          const result = argumentManager.peek();\n          return [{ text: result.entry.text, value: result.id }];\n        }\n        case \"close\": {\n          const result = argumentManager.tryResolve();\n          return result\n            ? [{ text: result.entry.text, value: result.id }]\n            : argumentManager.getCurrentEntries();\n        }\n      }\n\n      throw new Error(\"Error during processing -- Context:\" + state);\n    };\n\n  }\n  return ExtensionWithCustomArgumentSupport;\n}","import { openUI } from \"$common/ui\";\nimport { MinimalExtensionConstructor } from \"../base\";\n\n/**\n * Mixin the ability for extensions to open up UI at-will\n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport default function <T extends MinimalExtensionConstructor>(Ctor: T) {\n  abstract class ExtensionWithUISupport extends Ctor {\n\n    /**\n     * Open a UI in a modal window \n     * @param component The name of the svelte component / file to open (which should be stored within the same folder as your extension's `index.ts` file). \n     * You can optionally leave off the `.svelte` extension.\n     * @param label What to title the modal window that pops up (defaults to your extension's name if left blank)\n     */\n    openUI(component: string, label?: string) {\n      const { id, name, runtime } = this;\n      openUI(runtime, { id, name, component: component.replace(\".svelte\", \"\"), label });\n    }\n\n  }\n\n  return ExtensionWithUISupport;\n}\n","import { StageLayering, ValueOf } from \"$common/types\";\nimport { MinimalExtensionConstructor } from \"../base\";\n\ntype Handle = number;\n\ntype Renderer = {\n  /**\n   * Create a new bitmap skin from a snapshot of the provided bitmap data.\n   * @param {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} bitmapData - new contents for this skin.\n   * @param {!int} [costumeResolution=1] - The resolution to use for this bitmap.\n   * @param {?Array<number>} [rotationCenter] Optional: rotation center of the skin. If not supplied, the center of\n   * the skin will be used.\n   * @returns {!int} the ID for the new skin.\n   */\n  createBitmapSkin(bitmapData: ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement, costumeResolution?: number, rotationCenter?: Array<number> | null): Handle;\n  /**\n   * Create a new Drawable and add it to the scene.\n   * @param {string} group Layer group to add the drawable to\n   * @returns {int} The ID of the new Drawable.\n   */\n  createDrawable(group: string): Handle;\n  /**\n     * Update a drawable's visibility.\n     * @param {number} drawableID The drawable's id.\n     * @param {boolean} visible Will the drawable be visible?\n     */\n  updateDrawableVisible(drawableID: number, visible: boolean): void;\n  /**\n   * Update a drawable's visual effect.\n   * @param {number} drawableID The drawable's id.\n   * @param {string} effectName The effect to change.\n   * @param {number} value A new effect value.\n   */\n  updateDrawableEffect(drawableID: number, effectName: string, value: number): void;\n  /**\n   * Update a drawable's skin.\n   * @param {number} drawableID The drawable's id.\n   * @param {number} skinId The skin to update to.\n   */\n  updateDrawableSkinId(drawableID: Handle, skinId: Handle): void;\n  /**\n   * Update an existing bitmap skin, or create a bitmap skin if the previous skin was not bitmap.\n   * @param {!int} skinId the ID for the skin to change.\n   * @param {!ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imgData - new contents for this skin.\n   * @param {!number} bitmapResolution - the resolution scale for a bitmap costume.\n   * @param {?Array<number>} rotationCenter Optional: rotation center of the skin. If not supplied, the center of the\n   * skin will be used\n   */\n  updateBitmapSkin(skinId: Handle, imgData: ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement, bitmapResolution: number, rotationCenter?: Array<number> | null): void;\n  /**\n   * Destroy an existing skin. Do not use the skin or its ID after calling this.\n   * @param {!int} skinId - The ID of the skin to destroy.\n   */\n  destroySkin(skinId: number): void;\n  /**\n   * Destroy a Drawable, removing it from the scene.\n   * @param {int} drawableID The ID of the Drawable to remove.\n   * @param {string} group Group name that the drawable belongs to\n   */\n  destroyDrawable(drawableID: Handle, group: string): void;\n}\n\n/**\n * Mixin the ability for extensions to draw images into the canvas\n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport default function <T extends MinimalExtensionConstructor>(Ctor: T) {\n  abstract class ExtensionWithDrawingSupport extends Ctor {\n    private renderer: Renderer;\n\n    /**\n     * Draw an item on screen using image data\n     * @param {ImageData | ImageBitmap} image \n     * @returns \n     */\n    protected createDrawable<T extends ImageData | ImageBitmap>(image: T) {\n      this.renderer ??= this.runtime.renderer;\n      const { renderer } = this;\n\n      if (!renderer) return null;\n\n      const skin = renderer.createBitmapSkin(image as ImageData, 1);\n      const drawable = renderer.createDrawable(StageLayering.VideoLayer);\n\n      renderer.updateDrawableSkinId(drawable, skin);\n\n      const setTransparency = (transparency: number) =>\n        renderer.updateDrawableEffect(drawable, 'ghost', transparency);\n\n      const setVisible = (visible: boolean = true) =>\n        renderer.updateDrawableVisible(drawable, visible);\n\n      const update = (image: ImageData | ImageBitmap) =>\n        renderer.updateBitmapSkin(skin, image as ImageData, 1);\n\n      const destroy = () => {\n        setVisible(false);\n        renderer.destroyDrawable(drawable, StageLayering.VideoLayer);\n        renderer.destroySkin(skin);\n      }\n\n      setTransparency(0);\n      setVisible(true);\n\n      return { setTransparency, setVisible, update, destroy }\n    }\n  }\n\n  return ExtensionWithDrawingSupport;\n}\n","export const getUrlHelper = (dimensions: { width: number, height: number }) => {\n  const canvas = document.body.appendChild(document.createElement(\"canvas\"));\n\n  const setDimensions = ({ width, height }: Parameters<typeof getUrlHelper>[0]) => {\n    if (canvas.width !== width) canvas.width = width;\n    if (canvas.height !== height) canvas.height = height;\n  };\n\n  setDimensions(dimensions);\n\n  canvas.hidden = true;\n  const context = canvas.getContext(\"2d\");\n\n  return {\n    /**\n     * \n     * @param image \n     * @returns \n     */\n    getDataURL(image: ImageData) {\n      const { width, height } = image;\n      setDimensions(image);\n      context.save();\n      context.clearRect(0, 0, width, height);\n      context.putImageData(image, 0, 0);\n      const url = canvas.toDataURL('image/png');\n      context.restore();\n      return url;\n    }\n  }\n}","import { block } from \"$common/extension/decorators/blocks\";\nimport { withDependencies } from \"../../dependencies\";\nimport { MinimalExtensionConstructor } from \"../../base\";\nimport video from \"../video\";\n\n/**\n * Mixin a 'setVideoTransparency' Block to control the transparency of the videofeed\n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport default function <T extends MinimalExtensionConstructor>(Ctor: T) {\n  abstract class ExtensionWithSetVideoTransparencyBlock extends withDependencies(Ctor, video) {\n    /**\n     * A `command` block that takes a single number argument and uses it to set the transparency of the video feed.\n     * @param transparency What transparency to set -- a higher number is more transparent (thus '100' is fully invisible)\n     */\n    @block({\n      type: \"command\",\n      text: (transparency) => `Set video to ${transparency}% transparent`,\n      arg: \"number\"\n    })\n    setVideoTransparencyBlock(transparency: number) {\n      this.setVideoTransparency(transparency);\n    }\n  }\n\n  return ExtensionWithSetVideoTransparencyBlock;\n}\n","import { block } from \"$common/extension/decorators/blocks\";\nimport { withDependencies } from \"../../dependencies\";\nimport { MinimalExtensionConstructor } from \"../../base\";\nimport video from \"../video\";\n\n/**\n * Mixin a 'toggleVideo' Block to control whether the video feed is on, off, or flipped\n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport default function <T extends MinimalExtensionConstructor>(Ctor: T) {\n  abstract class ExtensionWithToggleVideoBlock extends withDependencies(Ctor, video) {\n    /**\n     * A `command` block that sets the current video state\n     * @param state What state to set (\"on\", \"off\", or \"on (flipped)\")\n     * @returns \n     */\n    @block({\n      type: \"command\",\n      text: (state) => `Set video feed to ${state}`,\n      arg: { type: \"string\", options: [\"on\", \"off\", \"on (flipped)\"] }\n    })\n    toggleVideoBlock(state: \"off\" | \"on\" | \"on (flipped)\") {\n      if (state === \"off\") return this.disableVideo();\n      this.enableVideo(state === \"on\");\n    }\n  }\n\n  return ExtensionWithToggleVideoBlock;\n}\n","import { MinimalExtensionConstructor } from \"../../base\";\n\n/**\n * Mixin the ability for an extension to be treated as a cross-platform extension, \n * spanning both the RAISE Playground and App Inventor.\n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport default function <T extends MinimalExtensionConstructor>(Ctor: T) {\n    abstract class ExtensionWithAppInventorInterop extends Ctor {\n        get withinAppInventor() {\n            return false; // TODO: Determine what/if there is a way to do this.?\n        }\n    }\n\n    return ExtensionWithAppInventorInterop;\n}\n","import Runtime from \"$scratch-vm/engine/runtime\";\n\nimport { AbstractConstructor, Environment, ExlcudeFirst } from \"$common/types\";\n\nexport type ExtensionConstructorParams = ConstructorParameters<typeof ConstructableExtension>;\nexport type AuxiliaryExtensionInfoParams = ExlcudeFirst<ExtensionConstructorParams>;\nexport type ExtensionBaseConstructor = AbstractConstructor<ExtensionBase>;\n\nexport abstract class ConstructableExtension {\n  /**\n   * @summary This member function (or 'method') will be called when a user adds your extension via the Extensions Menu (i.e. when your extension is instantiated)\n   * @example\n   * // Initialize class field(s)\n   * private count: number;\n   *\n   * init() {\n   *  count = 0;\n   * }\n   * @example\n   * // Interact with environment's runtime\n   * init(env: Environment) {\n   *  env.runtime.emit(RuntimeEvent.ProjectStart);\n   * }\n   * @example\n   * // Nothing to initialize\n   * init() {}\n   * @description This function is intended to behave exactly like a constructor, used to initialize the state of your extension.\n   *\n   * The reason we use this function INSTEAD of a constructor is so that the base Extension class can manage the construction of this class.\n   * \n   * This also allows us to enable this method to be async (if you'd like).\n   * @param {Environment} env An object that allows your Extension to interact with the Scratch Environment. Currently is a little bare, but will be expanded soon.\n   * Can be ommitted if not needed.\n   *\n   * For Scratch developers: The `runtime` property on env is the same as the runtime passed to non-Typescript-Framework Extension constructors\n   */\n  abstract init(env: Environment): void | Promise<void>;\n\n  protected async internal_init() {\n    const runtime = this.runtime;\n    return await Promise.resolve(this.init({\n      runtime,\n      get extensionManager() { return runtime.getExtensionManager() }\n    }));\n  }\n\n  /**\n   *\n   * @param runtime The 'runtime' connected to the scratch-vm that enables your extension to interact with the scratch workspace\n   * @param name The name of this extension.\n   * @param id The ID of this extension.\n   * @param blockIconURI\n   */\n  constructor(\n    readonly runtime: Runtime,\n    readonly name: string,\n    readonly id: string,\n    readonly blockIconURI: string,\n    readonly blockColor: string,\n    readonly menuColor: string,\n    readonly menuSelectColor: string\n  ) {\n  }\n}\n\nexport const extensionsMap = new Map<string, ExtensionBase>();\n\nexport abstract class ExtensionBase extends ConstructableExtension {\n  constructor(FORBIDDEN: never) {\n    // @ts-ignore\n    super(...arguments);\n    extensionsMap.set(this.id, this);\n  }\n}","import { ExtensionInstanceWithFunctionality, MixinName, optionalMixins } from \"..\";\nimport { ExtensionBaseConstructor } from \"../../ExtensionBase\";\n\n/**\n * Mixin the ability for extensions to check which optional mixins they support\n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport default function (Ctor: ExtensionBaseConstructor, supported: string[]) {\n  abstract class ExtensionWithConfigurableSupport extends Ctor {\n\n    supports<const TKey extends MixinName>(mixinName: TKey): this is typeof this & ExtensionInstanceWithFunctionality<[TKey]> {\n      return supported.includes(mixinName);\n    }\n  }\n\n  return ExtensionWithConfigurableSupport;\n}","import { ExtensionWithFunctionality, MixinName, optionalMixins } from \"./mixins/index\";\nimport { ExtensionBase } from \"./ExtensionBase\";\nimport scratchInfo from \"./mixins/base/scratchInfo\";\nimport supported from \"./mixins/base/supported\";\nimport { ExtensionMenuDisplayDetails, Writeable } from \"$common/types\";\nimport { tryCaptureDependencies } from \"./mixins/dependencies\";\nimport { tryCreateBundleTimeEvent } from \"$common/utils\";\n\nexport const extensionBundleEvent = tryCreateBundleTimeEvent<{ details: ExtensionMenuDisplayDetails, addOns: MixinName[] }>(\"extension\");\n\n/**\n * Creates the base class that your Extension should 'extend' which is compatible with your request. \n * \n * Your request will have the following two parts:\n * @param details The details about how your extension should display and behave within the Extensions Menu.\n * Only the `name` field is required, but before your extension can be officially published, \n * it will additionally need a `description`, `iconURL`, and `insetIconURL`\n * @param addOns An optional collection of specifiers about what functionality this extension should have.\n * In this way, the functionality your Extension has access to (through its base class) is configurable.\n * \n * To see what `addOns` you can specify, place your cursor after the details parameter and type a double quote (\"). \n * Your IDE (code editor) should then suggest what values you can provide (e.g. `\"ui\"`, `\"customArguments\"`, `\"customSaveData\"`, etc.). \n * \n * **Note:** The order of the `addOns` does not matter.\n * @returns \n * @example Defining an extension with a name and description (and no add ons)\n * ```ts\n * export default class Example extends extension({ name: \"Some Name\", description: \"Some description...\" }) {\n *  ...\n * }\n * ```\n * @example Defining an extension with a name and UI functionality\n * ```ts\n * export default class Example extends extension({ name: \"Some Name\" }, \"ui\") {\n *  ...\n * }\n * ```\n * @example Defining an extension with a name and UI & custom arguments functionality\n * ```ts\n * export default class Example extends extension({ name: \"Some Name\" }, \"ui\", \"customArguments\") {\n *  ...\n * }\n * ```\n */\nexport const extension = <const TSupported extends readonly MixinName[]>(\n  details: ExtensionMenuDisplayDetails,\n  ...addOns: Writeable<TSupported>\n): ExtensionWithFunctionality<[...TSupported]> & typeof ExtensionBase => {\n\n  if (details) extensionBundleEvent?.fire({ details, addOns });\n\n  const Base = scratchInfo(supported(ExtensionBase, addOns)) as ExtensionWithFunctionality<[...TSupported]>;\n\n  if (!addOns) return Base;\n\n  const { Result, allSupported } = recursivelyApplyMixinsAndDependencies(Base, addOns);\n  return supported(Result, Array.from(allSupported)) as typeof Result;\n}\n\nconst recursivelyApplyMixinsAndDependencies = <const TSupported extends readonly MixinName[]>(\n  Base: ExtensionWithFunctionality<[...TSupported]>,\n  addons: TSupported,\n  alreadyAdded: Set<MixinName> = new Set()\n): { Result: ExtensionWithFunctionality<[...TSupported]>, allSupported: Set<MixinName> } => {\n  const Result = addons\n    .filter(addon => !alreadyAdded.has(addon))\n    .map(key => {\n      alreadyAdded.add(key);\n      return key;\n    })\n    .map(key => optionalMixins[key])\n    .reduce((acc, mixin) => {\n      const { dependencies, MixedIn } = tryCaptureDependencies(() => mixin(acc));\n      return !dependencies\n        ? MixedIn\n        : recursivelyApplyMixinsAndDependencies(MixedIn, dependencies, alreadyAdded).Result as typeof MixedIn;\n    }, Base);\n\n  return { Result, allSupported: alreadyAdded }\n}\n\nexport type ExtensionConstructor<TSupported extends MixinName[] = []> = ReturnType<typeof extension<TSupported>>;\nexport type ExtensionInstance<TSupported extends MixinName[] = []> = InstanceType<ExtensionConstructor<TSupported>>;","import { ExtensionMenuDisplayDetails, ExtensionBlocks, BlockDefinitions, Translations } from \"$common/types\";\nimport { isFunction } from \"$common/utils\";\nimport { extension } from \"./index\";\nimport { getImplementationName } from \"./mixins/base/scratchInfo/index\";\n\n/**\n * @summary Base class for extensions implemented via the Typescript Extension Framework (using the \"generic\" strategy).\n * @example\n * class MyExtension extends Extension<\n *  { // Display details\n *    name: \"My Extension\",\n *    description: \"This is my extension\",\n *    iconURL: \"example.png\",\n *    insetIconURL: \"example.svg\"\n *  },\n *  { // Blocks\n *    myBlock: (someArg: number) => void;\n *  }\n * > {\n *  init(env: Environment): { ... };\n *  defineBlocks(): MyExtension[\"BlockDefinitions\"] { return ... }\n * }\n * @description Extension developers will create Typescript classes that `extend` (or 'inherit', or 'implement') this `Extension` class.\n *\n * In order to `extend` this class, you must first specify 2 generic type arguments, which effectively describe what kind of Extension you're implementing.\n *\n * More specifically, the 2 generic type arguments describe how this extension is presented to the user (by specifyng the details displayed in the Extensions Menu),\n * and what this Extension actually does (by specifying the blocks it will define).\n *\n * By declaring that we're extending an `Extension` with our specific generic type arguments,\n * Typescript holds us accountable to implement exactly what we said we would (all in order to make a working extension).\n *\n * This includes:\n * * Defining an `init` method, which is used INSTEAD of a constructor\n * * Defining a `defineBlocks` method that does just that: defines this extension's blocks\n * @template MenuDetails How the extension should display in the extensions menu\n * @template Blocks What kind of blocks this extension implements\n * @link https://www.typescriptlang.org/docs/handbook/2/generics.html Learn more about generics!\n */\n\nexport abstract class Extension<\n  MenuDetails extends ExtensionMenuDisplayDetails,\n  Blocks extends ExtensionBlocks\n> extends extension(undefined, \"ui\", \"customSaveData\", \"customArguments\") {\n\n  readonly BlockFunctions: Blocks;\n  readonly BlockDefinitions: BlockDefinitions<typeof this>;\n  readonly Translations: Translations<typeof this>;\n\n  /**\n   * @summary Extension member method that returns an object defining all blocks that belong to the extension.\n   * @description Every block your extension implements (defined by the second generic argument of the Extension class), will have an entry in the object return by this function.\n   * Each entry will either be an object or a function that returns an object that provides the:\n   * - type: the type of block\n   * - text: what is displayed on the block\n   * - arg or args: the arguments the block accepts\n   * - operation: the function that is called when the blocked is executed\n   * @example\n   * // Returning an object with two block definition function for 'someBlock'\n   * defineBlocks(): ExampleExtension[\"BlockDefinitions\"] {\n   *  return {\n   *    // Using object syntax\n   *    someBlock: {\n   *      type: BlockType.Reporter,\n   *      arg: ArgumentType.String,\n   *      text: (argument) => `Some text about ${argument}`,\n   *      operation: (argument) => {\n   *        // do something\n   *      }\n   *    },\n   *    // Using arrow function syntax\n   *    someBlock: (self: MyExtension) => ({\n   *      type: BlockType.Reporter,\n   *      arg: ArgumentType.String,\n   *      text: (argument) => `Some text about ${argument}`,\n   *      operation: (argument) => {\n   *        // do something\n   *      }\n   *    }),\n   *    // Using method function syntax\n   *    someOtherBlock(self: MyExtension) {\n   *      const type = BlockType.Reporter;\n   *      const arg = ArgumentType.String;\n   *      return {\n   *        arg, type,\n   *        text: (argument) => `Some text about ${argument}`,\n   *        operation: (argument) => {\n   *          // do something\n   *        }\n   *      }\n   *    }\n   *  }\n   * }\n   * @see BlockDefinitions\n   * @returns {BlockDefinitions<Blocks>} An object defining 'block definition' objects / functions for each block associated with this Extension.\n   */\n  abstract defineBlocks(): BlockDefinitions<Extension<MenuDetails, Blocks>>;\n\n  protected override async internal_init() {\n    await super.internal_init();\n    const blocks = this.defineBlocks();\n    const self = this;\n    for (const opcode in blocks) {\n      this.validateOpcode(opcode);\n      const block = blocks[opcode];\n      const { operation, text, arg, args, type } = isFunction(block) ? block.call(this, this) : block;;\n      this.pushBlock(opcode,\n        arg\n          ? { text, type, arg }\n          : args\n            ? { text, type, args }\n            : { text, type },\n        operation);\n      const internalFuncName = getImplementationName(opcode);\n      (this as unknown)[opcode] = function () { return self[internalFuncName].call(self, ...arguments); };\n    }\n  }\n\n  private validateOpcode(opcode: string) {\n    if (!(opcode in this)) return;\n\n    const error = `The Extension has a member defined as '${opcode}', ` +\n      `but that name should be reserved for the opcode of the block with the same name. ` +\n      `Please rename your member, and attach the \"validateGenericExtension\" decorator to your class ` +\n      `so that this can be an error in your IDE and not at runtime.`;\n\n    throw new Error(error);\n  }\n}\n","import { ExtensionBlocks, ExtensionMenuDisplayDetails } from \"$common/types\";\nimport { TypedClassDecorator } from \".\";\nimport { ExtensionConstructor } from \"..\";\nimport { Extension } from \"../GenericExtension\";\n\n/**\n * Used to validate (through type assertion) that a Generic Extension does not\n * define any members with the same name as one of its blocks. \n * \n * The Generic Extension `Extension` class predates this requirment of having no overlap between the keys of blocks and the members of the associated Extension \n * class, so this decorator is provided as an easy way to check and confirm a Generic Extension class is compliant.\n * \n * Runtime errors will also be produced if this condition is not met.\n * @param failure If this extension is not valid, this will be a type that displays the member names causing trouble. \n * @returns \n */\nexport const validGenericExtension = <const T extends Extension<ExtensionMenuDisplayDetails, ExtensionBlocks>>\n  (...failure: T extends Extension<any, infer Blocks> ? T extends { [k in keyof Blocks]?: any } ? [{ [k in keyof Blocks & keyof T]: \"Your class cannot have a member with this name, as it's a name of one of your blocks.\" }] : [] : never):\n  TypedClassDecorator<T, ConstructorParameters<ExtensionConstructor>> => {\n  return function (value, context) { }\n}"],"names":["ExtensionFramework","exports","BlockType","Boolean","Button","Command","Conditional","Event","Hat","Loop","Reporter","ArgumentType","Angle","Color","Number","String","Matrix","Note","Image","Custom","StageLayering","BackgroundLayer","VideoLayer","PenLayer","SpriteLayer","LayerGroups","Language","Azeri","Bahasa_Indonesia","Cymraeg","Dansk","Deutsch","Eesti","English","Euskara","Gaeilge","Galego","Hrvatski","isiZulu","Italiano","Kiswahili","Magyar","Nederlands","Norsk_Nynorsk","Polski","Rapa_Nui","Suomi","Svenska","LanguageKeys","Object","keys","__rest","s","e","t","p","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","length","propertyIsEnumerable","__esDecorate","ctor","descriptorIn","decorators","contextIn","initializers","extraInitializers","accept","f","TypeError","_","kind","key","target","descriptor","getOwnPropertyDescriptor","name","done","context","access","addInitializer","push","result","get","set","init","defineProperty","__runInitializers","thisArg","value","useValue","arguments","__awaiter","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","rejected","then","apply","untilObject","getter","delay","timeout","clearTimeout","setTimeout","isString","query","isFunction","toString","Function","isPrimitive","identity","x","untilExternalScriptLoaded","url","scriptLoaded","script","document","createElement","onload","onerror","async","src","body","appendChild","typesafeCall","fn","_this","args","container","assertSameLength","collections","size","reduce","add","Set","Error","tryCreateBundleTimeEvent","identifier","window","_a","global","registerCallback","callback","id","Symbol","fire","details","callbackIDs","_b","uuidv4","replace","c","r","Math","random","openUIEvent","registerButtonCallbackEvent","guiDropdownInterop","runtimeKey","runtimeProperties","stateKey","entryKey","updateMethodKey","state","open","update","close","openUI","runtime","emit","registerButtonCallback","buttonID","on","CssVar","constructor","root","this","parts","join","primary","secondary","tertiary","transparent","light","ui","text","motion","red","sound","control","data","pen","error","extensions","drop","color","modalOverlay","white","whiteDim","whiteTransparent","blackTransparent","primaryTransparent","lightTansparent","highlight","validRegEx","RegExp","invalidRegEx","guards","split","reverse","guardsRegEx","replaceAll","current","desired","saveDataKey","mixin","Ctor","saveDataHandler","undefined","save","toSave","extensionIDs","argumentManager","supports","customArgumentManager","saveData","hooks","onSave","saveTo","load","saved","onLoad","getOrCreateCustomArgumentManager","loadFrom","RGB_BLACK","g","b","RGB_WHITE","static","decimal","hex","substr","a","m","exec","parseInt","rgb","decimalToHex","rgbToDecimal","hexToRgb","hsv","h","max","min","v","floor","q","rgb0","rgb1","fraction1","fraction0","Cast","isNaN","n","toLowerCase","toRgbColorObject","substring","decimalToRgb","toNumber","val","trim","v1","v2","n1","n2","isWhiteSpace","NaN","s1","s2","Infinity","LIST_INVALID","LIST_ALL","index","acceptAll","cast","castToType","argumentType","parseFloat","JSON","parse","toMatrix","toFlag","matrixString","Array","fill","map","matrix","flag","row","CustomArgumentManager","Map","pending","setPending","clearPending","setEntry","entry","GetIdentifier","request","peek","getEntry","tryResolve","getCurrentEntries","from","entries","filter","requiresSave","obj","SaveKey","forEach","purgeStaleIDs","IsIdentifier","startsWith","IdentifierPrefix","MockBitmapAdapter","makeImage","makeCanvas","resize","image","newWidth","newHeight","stretchWidthCanvas","width","height","getContext","imageSmoothingEnabled","drawImage","stretchHeightCanvas","convertResolution1Bitmap","dataURI","toDataURL","getResizedWidthHeight","oldWidth","oldHeight","STAGE_WIDTH","STAGE_HEIGHT","imageRatio","importBitmap","newSize","convertDataURIToBinary","resizedDataURI","BASE64_MARKER","base64Index","base64","raw","atob","rawLength","array","Uint8Array","ArrayBuffer","charCodeAt","bitmapAdapter","urlHelper","dependencyListeners","withDependencies","dependencies","pop","mixinsMap","renderToDropdown","Compononent","props","className","elements","getElementsByClassName","findUniqueElementByClass","anchor","children","style","display","menuProbe","isSimpleStatic","menu","isArray","isSimpleDynamic","isStaticWithReporters","isDynamicWithReporters","getMenuName","convertMenuItemsToString","item","assign","asStaticMenu","items","acceptReporters","setMenu","options","menus","alreadyAddedIndex","menuIndex","addOptionsAndGetMenuName","format","description","extractHandlers","element","type","hasHandler","handler","getArgName","getArgumentType","arg","extractArgs","block","argsKey","setDefaultValue","opcode","defaultValue","getDefaultValue","isInlineImage","convertToDisplayText","isDynamicText","textFunc","argPlaceholders","getImplementationName","inlineImageAccessError","wrapOperation","operation","argsFromScratch","blockUtility","castedArguments","param","scratchInfo","blockMap","pushBlock","definition","has","getInfo","info","blockIconURI","blocks","convertToInfo","color1","blockColor","color2","menuColor","color3","menuSelectColor","collectMenus","isBlockGetter","displayText","argumentsInfo","fromEntries","uri","accumulation","convertToArgumentInfo","blockType","getButtonID","bind","func","names","types","handlers","zipArgs","registerDynamicMenu","getItems","blockBundleEvent","getAccessorPrefix","setAccessorPrefix","blockInfoOrGetter","internalFuncName","methodName","returns","scratchType","createBlockDefiner","objOrGetter","extension","argumentMethods","attachArgumentMethods","createBlockDecorator","params","indexKey","methods","method","tryUpdateKey","asBlockMetaData","getBlockMetaData","metadata","orderedNames","parseText","rest","extractMenuOptions","sort","convertAndInsertBlock","placeholder","template","getItemsPlaceholder","handlerPlaceholder","isDynamicMenu","menuName","acceptsReporters","validBlock","legacyBlock","console","validArg","pair","legacy","modern","getDynamicMenuName","legacySupportMixin","__isLegacy","orderArgumentNamesByBlock","getArgNames","validatedInfo","super","validateAndAttach","metaData","legacyID","legacyBlocks","legacyMenus","getLegacyInfo","mutableBlocks","self","updates","legacyArgs","modernArgs","argNames","replaceAt","implementation","util","remap","remapper","menuUpdates","legacyName","modernName","flat","isSvgText","nodeName","fills","success","warning","textAttributes","applyAttributes","attributes","setAttribute","createElements","createElementNS","equilateralTrianglePoints","reduction","shift","y","getEquilateralTrianglePoints","getCategoryElements","topLevel","title","innerHTML","Format","canvas","video","videoDimensions","videoDevice","ioDevices","getVideoFrame","getFrame","setVideoTransparency","transparency","setPreviewGhost","enableVideo","mirror","provider","disableVideo","optionalMixins","ExtensionWithCustomArgumentSupport","customSaveData","makeCustomArgument","component","initial","acceptReportersHandler","processMenuForCustomArgument","acceptsReports","initialID","Component","interop","setter","label","drawable","createDrawable","renderer","skin","createBitmapSkin","updateDrawableSkinId","setTransparency","updateDrawableEffect","setVisible","visible","updateDrawableVisible","updateBitmapSkin","destroy","destroyDrawable","destroySkin","addCostumes","addCostume","action","isRenderedTarget","warn","Date","now","dimensions","setDimensions","hidden","getDataURL","clearRect","putImageData","restore","getUrlHelper","storage","dataFormat","DataFormat","PNG","assetType","AssetType","ImageBitmap","dataBuffer","asset","createAsset","assetId","costume","md5","getCostumes","setCostume","legacySupport","setTransparencyBlock","ExtensionWithSetVideoTransparencyBlock","setVideoTransparencyBlock","_setVideoTransparencyBlock_decorators","private","_instanceExtraInitializers","toggleVideoBlock","ExtensionWithToggleVideoBlock","_toggleVideoBlock_decorators","appInventor","withinAppInventor","indicators","indicate","position","msg","alert","rect","triangle","points","el","getBBox","rx","removeChild","openAlert","ConstructableExtension","internal_init","extensionManager","getExtensionManager","extensionsMap","ExtensionBase","FORBIDDEN","supported","mixinName","includes","extensionBundleEvent","addOns","Base","Result","allSupported","recursivelyApplyMixinsAndDependencies","addons","alreadyAdded","addon","acc","MixedIn","createMixin","mixins","dependency","tryCaptureDependencies","Extension","_super","defineBlocks","validateOpcode","AuxiliaryExtensionInfo","Branch","Exit","Enter","First","Second","Third","Fourth","Fifth","Sixth","Seventh","FrameworkID","RuntimeEvent","ScriptGlowOn","ScriptGlowOff","BlockGlowOn","BlockGlowOff","HasCloudDataUpdate","TurboModeOn","TurboModeOff","RecordingOn","RecordingOff","ProjectStart","ProjectRunStart","ProjectRunStop","ProjectStopAll","StopForTarget","VisualReport","ProjectLoaded","ProjectChanged","ToolboxExtensionsNeedUpdate","TargetsUpdate","MonitorsUpdate","BlockDragUpdate","BlockDragEnd","ExtensionAdded","ExtensionFieldAdded","PeripheralListUpdate","PeripheralConnected","PeripheralDisconnected","PeripheralRequestError","PeripheralConnectionLostError","PeripheralScanTimeout","MicListening","BlocksInfoUpdate","RuntimeStarted","RuntimeDisposed","BlocksNeedUpdate","SaveDataHandler","ScratchBlocksConstants","OutputShapeHexagonal","OutputShapeRound","OutputShapeSquare","TargetType","Sprite","Stage","VariableType","Scalar","List","BrooadcastMessage","activeClass","blockIDKey","buttonBlock","color$1","copyTo","source","customArgumentFlag","customArgumentMethod","decode","matchAll","replacements","match","code","fromCharCode","modified","encode","invalidCharacters","char","fetchWithTimeout","resource","controller","AbortController","abort","response","fetch","signal","getTextFromMenuItem","getValueFromMenuItem","getterBlock","isValidID","test","flags","for","blockMethodBroker","definer","decorator","legacyDefinition","definitions","throwTypeOnlyError","legacyExtension","LegacySupport","legacyInfo","ExtensionWithLegacySupport","legacySupportWithInfoArgument","originalClassName","ReservedNames","Menus","Blocks","ArgumentNamesByBlock","loadExternalScript","onError","px","numberOf","reactiveInvoke","extensionAssignment","funcName","reactiveSet","propertyName","rgbToHex","setterBlock","blockInfo","splitOnCapitals","tryCastToArgumentType","onFailure","untilCondition","condition","untilExternalGlobalVariableLoaded","globalVariableName","untilReady","ready","untilTimePassed","timeMs","validGenericExtension","failure"],"mappings":"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"}