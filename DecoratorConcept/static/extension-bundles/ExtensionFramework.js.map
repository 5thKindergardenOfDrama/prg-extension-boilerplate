{"version":3,"file":"ExtensionFramework.js","sources":["../../../../extensions/src/common/customArguments/CustomArgumentManager.ts","../../../../extensions/src/common/extension/mixins/customSaveData.ts","../../../../extensions/src/common/enums.ts","../../../scratch-vm/src/util/color.js","../../../scratch-vm/src/util/cast.js","../../../../extensions/src/common/cast.ts","../../../../extensions/src/common/globals.ts","../../../../extensions/src/common/ui.ts","../../../../extensions/src/common/utils.ts","../../../../extensions/src/common/extension/mixins/scratchInfo.ts","../../../../extensions/src/common/customArguments/dropdownOverride.ts","../../../../extensions/src/common/extension/mixins/customArguments.ts","../../../../extensions/src/common/extension/Extension.ts","../../../../extensions/src/common/extension/mixins/ui.ts","../../../../extensions/src/common/IDs.ts","../../../../extensions/src/common/portHelper.ts","../../../../extensions/src/common/extension/decorators/blocks.ts","../../../../extensions/src/common/extension/decorators/extension.ts","../../../../extensions/src/common/extension/decorators/legacy.ts","../../../../extensions/src/common/extension/mixins/legacySupport.ts"],"sourcesContent":["export type ArgumentEntry<T> = { text: string, value: T };\nexport type ArgumentEntrySetter<T> = (entry: ArgumentEntry<T>) => void;\n\nexport default class CustomArgumentManager {\n  map: Map<string, ArgumentEntry<any>> = new Map();\n  pending: { id: string, entry: ArgumentEntry<any> } = null;\n\n  clearPending() { this.pending = null }\n  setPending(update: typeof this.pending) { this.pending = update }\n\n  add<T>(entry: ArgumentEntry<T>): string {\n    const id = CustomArgumentManager.GetIdentifier();\n    this.map.set(id, entry);\n    this.clearPending();\n    return id;\n  }\n\n  insert<T>(id: string, entry: ArgumentEntry<T>): string {\n    this.map.set(id, entry);\n    this.clearPending();\n    return id;\n  }\n\n  request<T>(): [string, ArgumentEntrySetter<T>] {\n    this.clearPending();\n    const id = CustomArgumentManager.GetIdentifier();\n    return [id, (entry) => this.setPending({ id, entry })];\n  }\n\n  tryResolve() {\n    if (!this.pending) return;\n    const { pending: { entry, id } } = this;\n    this.map.set(id, entry);\n    this.clearPending();\n    return { entry, id };\n  }\n\n  getCurrentEntries() {\n    return Array.from(this.map.entries())\n      .filter(([_, entry]) => entry !== null)\n      .map(([id, { text }]) => [text, id] as const);\n  }\n\n  getEntry(id: string) { return this.map.get(id) }\n\n  static SaveKey = \"internal_customArgumentsSaveData\" as const;\n\n  requiresSave() { this.map.size > 0 }\n\n  saveTo(obj: object) {\n    const entries = Array.from(this.map.entries())\n      .filter(([_, entry]) => entry !== null)\n      .map(([id, entry]) => ({ id, entry }));\n    if (entries.length === 0) return;\n    obj[CustomArgumentManager.SaveKey] = entries;\n  }\n\n  loadFrom(obj: Record<typeof CustomArgumentManager[\"SaveKey\"], { id: string, entry: ArgumentEntry<any> }[]>) {\n    obj[CustomArgumentManager.SaveKey]?.forEach(({ id, entry }) => {\n      this.map.set(id, entry);\n    });\n  }\n\n  /**\n   * @todo Implement this if it becomes necessary (i.e the every growing size of this.map becomes an issue)\n   */\n  private purgeStaleIDs() {\n    // Somehow, tap into blockly to loop through all current blocks & their field dropdowns.\n    // Collect all field dropdowns values. \n    // Then, loop over entries in this.map -- if the values don't appear in the collected in-use values, drop those items.\n    // NOTE: The blocks in the 'pallette' do not show up in a target's \"blocks\" object, which makes this tricky.\n  }\n\n  static IsIdentifier = (query: string) => query.startsWith(CustomArgumentManager.IdentifierPrefix);\n  private static GetIdentifier = () => CustomArgumentManager.IdentifierPrefix + new Date().getTime().toString();\n  private static IdentifierPrefix = \"__customArg__\";\n}","import CustomArgumentManager from \"$common/customArguments/CustomArgumentManager\";\nimport { ExtensionBaseConstructor, TypedConstructor, ExtensionBase } from \"$common/extension/Extension\";\nimport customArgumentSupport from \"$common/extension/mixins/customArguments\";\n\n/**\n * WARNING! If you change this key, it will affect already saved projects.\n * Do not rename this without first developing a mechanism for searching for previously used keys.\n */\nconst saveDataKey = \"customSaveDataPerExtension\" as const;\n\n/**\n * @summary Utility class to assist in creating a (typesafe) object that, for a given Extension type, handles both:\n * - writing out data on save\n * - doing something with save data on load\n * \n * @description This class's constructor takes an object with both an `onSave` and an `onLoad` method\n * (and the `onSave`'s return type must match `onLoad`'s argument type)\n * @example\n * new SaveDataHandler({\n *    Extension: MyExtension,\n *    onSave: () => ({x: 0, y: 3}),\n *    onLoad: (data) => {\n *       const sum = data.x + data.y; // do something with saved data\n *    }\n * })\n */\nexport class SaveDataHandler<T extends ExtensionBase, TData> {\n  constructor(public hooks: {\n    // @ts-ignore\n    Extension: TypedConstructor<T>,\n    onSave: (self: T) => TData,\n    onLoad: (self: T, data: TData) => void,\n  }) { }\n}\n\nexport default function <T extends ExtensionBaseConstructor & ReturnType<typeof customArgumentSupport>>(Ctor: T) {\n  abstract class _ extends Ctor {\n\n    /**\n     * Optional field that can be defined if you need to save custom data for an extension \n     * (like some extension specific variable, or an API endpoint).\n     * @example\n     * class Example extends Extension<..., ...> {\n     *    someValue = 5;\n     *    ...\n     *    saveDataHandler = new SaveDataHandler({\n     *      Extension: Example,\n     *      // NOTE: The type info for 'instance' could be left off in the line below\n     *      onSave: (instance: Example) => ({ valueToSave: instance.someValue }),\n     *      onLoad: (instance, data) => instance.someValue = data.valueToSave\n     *    })\n     * }\n     * @see Extension.MakeSaveDataHandler\n     */\n    protected saveDataHandler: SaveDataHandler<_, any> = undefined;\n\n    /**\n     * Save function called 'internally' by the VM when serializing a project.\n     * @param toSave \n     * @param extensionIDs \n     * @returns \n     */\n    private save(toSave: { [saveDataKey]: Record<string, any> }, extensionIDs: Set<string>) {\n      const { saveDataHandler, id, argumentManager } = this;\n      const saveData = saveDataHandler?.hooks.onSave(this) ?? {};\n      argumentManager?.saveTo(saveData);\n      if (Object.keys(saveData).length === 0) return;\n      const container = toSave[saveDataKey];\n      container ? (container[id] = saveData) : (toSave[saveDataKey] = { [id]: saveData });\n      extensionIDs.add(id);\n    }\n\n    /**\n     * Load function called 'internally' by the VM when loading a project.\n     * Will be invoked on an extension immediately after it is constructed.\n     * @param saved \n     * @returns \n     */\n    private load(saved: { [saveDataKey]: Record<string, any> }) {\n      if (!saved) return;\n      const { saveDataHandler, id } = this;\n      const saveData = saveDataKey in saved ? saved[saveDataKey][id] : null;\n      if (!saveData) return;\n      saveDataHandler?.hooks.onLoad(this, saveData);\n      (this.argumentManager ??= new CustomArgumentManager()).loadFrom(saveData);\n    }\n  }\n  return _;\n}","import { ValueOf } from \"./types\";\n\n/**\n * The different kind of blocks that an extension can define\n */\nexport const BlockType = {\n  /**\n   * Boolean reporter with hexagonal shape\n   */\n  Boolean: 'Boolean',\n\n  /**\n   * A button (not an actual block) for some special action, like making a variable\n   */\n  Button: 'button',\n\n  /**\n   * Command block\n   */\n  Command: 'command',\n\n  /**\n   * Specialized command block which may or may not run a child branch\n   * The thread continues with the next block whether or not a child branch ran.\n   */\n  Conditional: 'conditional',\n\n  /**\n   * Specialized hat block with no implementation function\n   * This stack only runs if the corresponding event is emitted by other code.\n   */\n  Event: 'event',\n\n  /**\n   * Hat block which conditionally starts a block stack\n   */\n  Hat: 'hat',\n\n  /**\n   * Specialized command block which may or may not run a child branch\n   * If a child branch runs, the thread evaluates the loop block again.\n   */\n  Loop: 'loop',\n\n  /**\n   * General reporter with numeric or string value\n   */\n  Reporter: 'reporter'\n} as const;\n\nexport const ArgumentType = {\n  /** Numeric value with angle picker. */\n  Angle: \"angle\",\n\n  /** Boolean value with hexagonal placeholder. */\n  Boolean: \"Boolean\",\n\n  /** Numeric value with color picker. */\n  Color: \"color\",\n\n  /** Numeric value with text field. */\n  Number: \"number\",\n\n  /** String value with text field. */\n  String: \"string\",\n\n  /** String value with matrix field. */\n  Matrix: \"matrix\",\n\n  /** MIDI note number with note picker (piano) field. */\n  Note: \"note\",\n\n  /** Inline image on block (as part of the label). */\n  Image: \"image\",\n\n  /** Type added by PRG to support custom arguments */\n  Custom: \"custom\"\n} as const;\n\n/**\n * Default types of Target supported by the VM\n * @enum {string} as const;\n */\nexport const TargetType = {\n  /**\n   * Rendered target which can move, change costumes, etc.\n   */\n  Sprite: 'sprite',\n\n  /**\n   * Rendered target which cannot move but can change backdrops\n   */\n  Stage: 'stage'\n} as const;\n\n/**\n * These constants are copied from scratch-blocks/core/constants.js\n * @TODO find a way to require() these straight from scratch-blocks... maybe make a scratch-blocks/dist/constants.js?\n * @readonly\n * @enum {int} as const;\n */\nexport const ScratchBlocksConstants = {\n  /**\n   * ENUM for output shape: hexagonal (booleans/predicates).\n   * @const\n   */\n  OutputShapeHexagonal: 1,\n\n  /**\n   * ENUM for output shape: rounded (numbers).\n   * @const\n   */\n  OutputShapeRound: 2,\n\n  /**\n   * ENUM for output shape: squared (any/all values; strings).\n   * @const\n   */\n  OutputShapeSquare: 3\n} as const;\n\nexport const StageLayering = {\n  BackgroundLayer: 'background',\n  VideoLayer: 'video',\n  PenLayer: 'pen',\n  SpriteLayer: 'sprite',\n} as const;\n\nexport const LayerGroups: readonly ValueOf<typeof StageLayering>[] = [\n  StageLayering.VideoLayer,\n  StageLayering.SpriteLayer,\n  StageLayering.BackgroundLayer,\n  StageLayering.PenLayer,\n] as const;\n\nexport const VariableType = {\n  /**\n   * Type representation for scalar variables.\n   * This is currently represented as ''\n   * for compatibility with blockly.\n   */\n  Scalar: '',\n  /**\n   * Type representation for list variables.\n   */\n  List: 'list',\n\n  BrooadcastMessage: 'broadcast_msg'\n} as const;\n\nexport const Branch = {\n  Exit: 0,\n  Enter: 1,\n  First: 1,\n  Second: 2,\n  Third: 3,\n  Fourth: 4,\n  Fifth: 5,\n  Sixth: 6,\n  Seventh: 7\n} as const;\n\nexport const Language = {\n  Аҧсшәа: 'ab',\n  العربية: 'ar',\n  አማርኛ: 'am',\n  Azeri: 'az',\n  Bahasa_Indonesia: 'id',\n  Беларуская: 'be',\n  Български: 'bg',\n  Català: 'ca',\n  Česky: 'cs',\n  Cymraeg: 'cy',\n  Dansk: 'da',\n  Deutsch: 'de',\n  Eesti: 'et',\n  Ελληνικά: 'el',\n  English: 'en',\n  Español: 'es',\n  Español_Latinoamericano: 'es-419',\n  Euskara: 'eu',\n  فارسی: 'fa',\n  Français: 'fr',\n  Gaeilge: 'ga',\n  Gàidhlig: 'gd',\n  Galego: 'gl',\n  한국어: 'ko',\n  עִבְרִית: 'he',\n  Hrvatski: 'hr',\n  isiZulu: 'zu',\n  Íslenska: 'is',\n  Italiano: 'it',\n  ქართული_ენა: 'ka',\n  Kiswahili: 'sw',\n  Kreyòl_ayisyen: 'ht',\n  کوردیی_ناوەندی: 'ckb',\n  Latviešu: 'lv',\n  Lietuvių: 'lt',\n  Magyar: 'hu',\n  Māori: 'mi',\n  Nederlands: 'nl',\n  日本語: 'ja',\n  にほんご: 'ja-Hira',\n  Norsk_Bokmål: 'nb',\n  Norsk_Nynorsk: 'nn',\n  Oʻzbekcha: 'uz',\n  ไทย: 'th',\n  ភាសាខ្មែរ: 'km',\n  Polski: 'pl',\n  Português: 'pt',\n  Português_Brasileiro: 'pt-br',\n  Rapa_Nui: 'rap',\n  Română: 'ro',\n  Русский: 'ru',\n  Српски: 'sr',\n  Slovenčina: 'sk',\n  Slovenščina: 'sl',\n  Suomi: 'fi',\n  Svenska: 'sv',\n  Tiếng_Việt: 'vi',\n  Türkçe: 'tr',\n  Українська: 'uk',\n  简体中文: 'zh-cn',\n  繁體中文: 'zh-tw'\n} as const;\n\nexport const LanguageKeys = Object.keys(Language);\n\nexport const RuntimeEvent = {\n  /**\n   * Event name for glowing a script.\n   */\n  ScriptGlowOn: 'SCRIPT_GLOW_ON',\n  /**\n   * Event name for unglowing a script.\n   */\n  ScriptGlowOff: 'SCRIPT_GLOW_OFF',\n  /**\n   * Event name for glowing a block.\n   */\n  BlockGlowOn: 'BLOCK_GLOW_ON',\n  /**\n   * Event name for unglowing a block.\n   */\n  BlockGlowOff: 'BLOCK_GLOW_OFF',\n  /**\n   * Event name for a cloud data update to this project.\n   */\n  HasCloudDataUpdate: 'HAS_CLOUD_DATA_UPDATE',\n  /**\n   * Event name for turning on turbo mode.\n   */\n  TurboModeOn: 'TURBO_MODE_ON',\n  /**\n   * Event name for turning off turbo mode.\n   */\n  TurboModeOff: 'TURBO_MODE_OFF',\n  /**\n   * Event name for turning on turbo mode.\n   */\n  RecordingOn: 'RECORDING_ON',\n  /**\n   * Event name for turning off turbo mode.\n   */\n  RecordingOff: 'RECORDING_OFF',\n  /**\n   * Event name when the project is started (threads may not necessarily be running).\n   */\n  ProjectStart: 'PROJECT_START',\n  /**\n   * Event name when threads start running.\n   * Used by the UI to indicate running status.\n   */\n  ProjectRunStart: 'PROJECT_RUN_START',\n  /**\n   * Event name when threads stop running\n   * Used by the UI to indicate not-running status.\n   */\n  ProjectRunStop: 'PROJECT_RUN_STOP',\n  /**\n   * Event name for project being stopped or restarted by the user.\n   * Used by blocks that need to reset state.\n   */\n  ProjectStopAll: 'PROJECT_STOP_ALL',\n  /**\n   * Event name for target being stopped by a stop for target call.\n   * Used by blocks that need to stop individual targets.\n   */\n  StopForTarget: 'STOP_FOR_TARGET',\n  /**\n   * Event name for visual value report.\n   */\n  VisualReport: 'VISUAL_REPORT',\n  /**\n   * Event name for project loaded report.\n   */\n  ProjectLoaded: 'PROJECT_LOADED',\n  /**\n   * Event name for report that a change was made that can be saved\n   */\n  ProjectChanged: 'PROJECT_CHANGED',\n  /**\n   * Event name for report that a change was made to an extension in the toolbox.\n   */\n  ToolboxExtensionsNeedUpdate: 'TOOLBOX_EXTENSIONS_NEED_UPDATE',\n  /**\n   * Event name for targets update report.\n   */\n  TargetsUpdate: 'TARGETS_UPDATE',\n  /**\n   * Event name for monitors update.\n   */\n  MonitorsUpdate: 'MONITORS_UPDATE',\n  /**\n   * Event name for block drag update.\n   */\n  BlockDragUpdate: 'BLOCK_DRAG_UPDATE',\n  /**\n   * Event name for block drag end.\n   */\n  BlockDragEnd: 'BLOCK_DRAG_END',\n  /**\n   * Event name for reporting that an extension was added.\n   */\n  ExtensionAdded: 'EXTENSION_ADDED',\n  /**\n   * Event name for reporting that an extension as asked for a custom field to be added\n   */\n  ExtensionFieldAdded: 'EXTENSION_FIELD_ADDED',\n  /**\n   * Event name for updating the available set of peripheral devices.\n   * This causes the peripheral connection modal to update a list of available peripherals.\n   */\n  PeripheralListUpdate: 'PERIPHERAL_LIST_UPDATE',\n  /**\n   * Event name for reporting that a peripheral has connected.\n   * This causes the status button in the blocks menu to indicate 'connected'.\n   */\n  PeripheralConnected: 'PERIPHERAL_CONNECTED',\n  /**\n   * Event name for reporting that a peripheral has been intentionally disconnected.\n   * This causes the status button in the blocks menu to indicate 'disconnected'.\n   */\n  PeripheralDisconnected: 'PERIPHERAL_DISCONNECTED',\n  /**\n   * Event name for reporting that a peripheral has encountered a request error.\n   * This causes the peripheral connection modal to switch to an error state.\n   */\n  PeripheralRequestError: 'PERIPHERAL_REQUEST_ERROR',\n  /**\n   * Event name for reporting that a peripheral connection has been lost.\n   * This causes a 'peripheral connection lost' error alert to display.\n   */\n  PeripheralConnectionLostError: 'PERIPHERAL_CONNECTION_LOST_ERROR',\n  /**\n   * Event name for reporting that a peripheral has not been discovered.\n   * This causes the peripheral connection modal to show a timeout state.\n   */\n  PeripheralScanTimeout: 'PERIPHERAL_SCAN_TIMEOUT',\n  /**\n   * Event name to indicate that the microphone is being used to stream audio.\n   */\n  MicListening: 'MIC_LISTENING',\n  /**\n   * Event name for reporting that blocksInfo was updated.\n   */\n  BlocksInfoUpdate: 'BLOCKSINFO_UPDATE',\n  /**\n   * Event name when the runtime tick loop has been started.\n   */\n  RuntimeStarted: 'RUNTIME_STARTED',\n  /**\n   * Event name when the runtime dispose has been called.\n   */\n  RuntimeDisposed: 'RUNTIME_DISPOSED',\n  /**\n   * Event name for reporting that a block was updated and needs to be rerendered.\n   */\n  BlocksNeedUpdate: 'BLOCKS_NEED_UPDATE',\n} as const;\n","class Color {\n    /**\n     * @typedef {object} RGBObject - An object representing a color in RGB format.\n     * @property {number} r - the red component, in the range [0, 255].\n     * @property {number} g - the green component, in the range [0, 255].\n     * @property {number} b - the blue component, in the range [0, 255].\n     */\n\n    /**\n     * @typedef {object} HSVObject - An object representing a color in HSV format.\n     * @property {number} h - hue, in the range [0-359).\n     * @property {number} s - saturation, in the range [0,1].\n     * @property {number} v - value, in the range [0,1].\n     */\n\n    /** @type {RGBObject} */\n    static get RGB_BLACK () {\n        return {r: 0, g: 0, b: 0};\n    }\n\n    /** @type {RGBObject} */\n    static get RGB_WHITE () {\n        return {r: 255, g: 255, b: 255};\n    }\n\n    /**\n     * Convert a Scratch decimal color to a hex string, #RRGGBB.\n     * @param {number} decimal RGB color as a decimal.\n     * @return {string} RGB color as #RRGGBB hex string.\n     */\n    static decimalToHex (decimal) {\n        if (decimal < 0) {\n            decimal += 0xFFFFFF + 1;\n        }\n        let hex = Number(decimal).toString(16);\n        hex = `#${'000000'.substr(0, 6 - hex.length)}${hex}`;\n        return hex;\n    }\n\n    /**\n     * Convert a Scratch decimal color to an RGB color object.\n     * @param {number} decimal RGB color as decimal.\n     * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     */\n    static decimalToRgb (decimal) {\n        const a = (decimal >> 24) & 0xFF;\n        const r = (decimal >> 16) & 0xFF;\n        const g = (decimal >> 8) & 0xFF;\n        const b = decimal & 0xFF;\n        return {r: r, g: g, b: b, a: a > 0 ? a : 255};\n    }\n\n    /**\n     * Convert a hex color (e.g., F00, #03F, #0033FF) to an RGB color object.\n     * CC-BY-SA Tim Down:\n     * https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb\n     * @param {!string} hex Hex representation of the color.\n     * @return {RGBObject} null on failure, or rgb: {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     */\n    static hexToRgb (hex) {\n        const shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n        hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);\n        const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n        return result ? {\n            r: parseInt(result[1], 16),\n            g: parseInt(result[2], 16),\n            b: parseInt(result[3], 16)\n        } : null;\n    }\n\n    /**\n     * Convert an RGB color object to a hex color.\n     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     * @return {!string} Hex representation of the color.\n     */\n    static rgbToHex (rgb) {\n        return Color.decimalToHex(Color.rgbToDecimal(rgb));\n    }\n\n    /**\n     * Convert an RGB color object to a Scratch decimal color.\n     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     * @return {!number} Number representing the color.\n     */\n    static rgbToDecimal (rgb) {\n        return (rgb.r << 16) + (rgb.g << 8) + rgb.b;\n    }\n\n    /**\n    * Convert a hex color (e.g., F00, #03F, #0033FF) to a decimal color number.\n    * @param {!string} hex Hex representation of the color.\n    * @return {!number} Number representing the color.\n    */\n    static hexToDecimal (hex) {\n        return Color.rgbToDecimal(Color.hexToRgb(hex));\n    }\n\n    /**\n     * Convert an HSV color to RGB format.\n     * @param {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}\n     * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     */\n    static hsvToRgb (hsv) {\n        let h = hsv.h % 360;\n        if (h < 0) h += 360;\n        const s = Math.max(0, Math.min(hsv.s, 1));\n        const v = Math.max(0, Math.min(hsv.v, 1));\n\n        const i = Math.floor(h / 60);\n        const f = (h / 60) - i;\n        const p = v * (1 - s);\n        const q = v * (1 - (s * f));\n        const t = v * (1 - (s * (1 - f)));\n\n        let r;\n        let g;\n        let b;\n\n        switch (i) {\n        default:\n        case 0:\n            r = v;\n            g = t;\n            b = p;\n            break;\n        case 1:\n            r = q;\n            g = v;\n            b = p;\n            break;\n        case 2:\n            r = p;\n            g = v;\n            b = t;\n            break;\n        case 3:\n            r = p;\n            g = q;\n            b = v;\n            break;\n        case 4:\n            r = t;\n            g = p;\n            b = v;\n            break;\n        case 5:\n            r = v;\n            g = p;\n            b = q;\n            break;\n        }\n\n        return {\n            r: Math.floor(r * 255),\n            g: Math.floor(g * 255),\n            b: Math.floor(b * 255)\n        };\n    }\n\n    /**\n     * Convert an RGB color to HSV format.\n     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     * @return {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}\n     */\n    static rgbToHsv (rgb) {\n        const r = rgb.r / 255;\n        const g = rgb.g / 255;\n        const b = rgb.b / 255;\n        const x = Math.min(Math.min(r, g), b);\n        const v = Math.max(Math.max(r, g), b);\n\n        // For grays, hue will be arbitrarily reported as zero. Otherwise, calculate\n        let h = 0;\n        let s = 0;\n        if (x !== v) {\n            const f = (r === x) ? g - b : ((g === x) ? b - r : r - g);\n            const i = (r === x) ? 3 : ((g === x) ? 5 : 1);\n            h = ((i - (f / (v - x))) * 60) % 360;\n            s = (v - x) / v;\n        }\n\n        return {h: h, s: s, v: v};\n    }\n\n    /**\n     * Linear interpolation between rgb0 and rgb1.\n     * @param {RGBObject} rgb0 - the color corresponding to fraction1 <= 0.\n     * @param {RGBObject} rgb1 - the color corresponding to fraction1 >= 1.\n     * @param {number} fraction1 - the interpolation parameter. If this is 0.5, for example, mix the two colors equally.\n     * @return {RGBObject} the interpolated color.\n     */\n    static mixRgb (rgb0, rgb1, fraction1) {\n        if (fraction1 <= 0) return rgb0;\n        if (fraction1 >= 1) return rgb1;\n        const fraction0 = 1 - fraction1;\n        return {\n            r: (fraction0 * rgb0.r) + (fraction1 * rgb1.r),\n            g: (fraction0 * rgb0.g) + (fraction1 * rgb1.g),\n            b: (fraction0 * rgb0.b) + (fraction1 * rgb1.b)\n        };\n    }\n}\n\nmodule.exports = Color;\n","const Color = require('../util/color');\n\n/**\n * @fileoverview\n * Utilities for casting and comparing Scratch data-types.\n * Scratch behaves slightly differently from JavaScript in many respects,\n * and these differences should be encapsulated below.\n * For example, in Scratch, add(1, join(\"hello\", world\")) -> 1.\n * This is because \"hello world\" is cast to 0.\n * In JavaScript, 1 + Number(\"hello\" + \"world\") would give you NaN.\n * Use when coercing a value before computation.\n */\n\nclass Cast {\n    /**\n     * Scratch cast to number.\n     * Treats NaN as 0.\n     * In Scratch 2.0, this is captured by `interp.numArg.`\n     * @param {*} value Value to cast to number.\n     * @return {number} The Scratch-casted number value.\n     */\n    static toNumber (value) {\n        // If value is already a number we don't need to coerce it with\n        // Number().\n        if (typeof value === 'number') {\n            // Scratch treats NaN as 0, when needed as a number.\n            // E.g., 0 + NaN -> 0.\n            if (Number.isNaN(value)) {\n                return 0;\n            }\n            return value;\n        }\n        const n = Number(value);\n        if (Number.isNaN(n)) {\n            // Scratch treats NaN as 0, when needed as a number.\n            // E.g., 0 + NaN -> 0.\n            return 0;\n        }\n        return n;\n    }\n\n    /**\n     * Scratch cast to boolean.\n     * In Scratch 2.0, this is captured by `interp.boolArg.`\n     * Treats some string values differently from JavaScript.\n     * @param {*} value Value to cast to boolean.\n     * @return {boolean} The Scratch-casted boolean value.\n     */\n    static toBoolean (value) {\n        // Already a boolean?\n        if (typeof value === 'boolean') {\n            return value;\n        }\n        if (typeof value === 'string') {\n            // These specific strings are treated as false in Scratch.\n            if ((value === '') ||\n                (value === '0') ||\n                (value.toLowerCase() === 'false')) {\n                return false;\n            }\n            // All other strings treated as true.\n            return true;\n        }\n        // Coerce other values and numbers.\n        return Boolean(value);\n    }\n\n    /**\n     * Scratch cast to string.\n     * @param {*} value Value to cast to string.\n     * @return {string} The Scratch-casted string value.\n     */\n    static toString (value) {\n        return String(value);\n    }\n\n    /**\n     * Cast any Scratch argument to an RGB color array to be used for the renderer.\n     * @param {*} value Value to convert to RGB color array.\n     * @return {Array.<number>} [r,g,b], values between 0-255.\n     */\n    static toRgbColorList (value) {\n        const color = Cast.toRgbColorObject(value);\n        return [color.r, color.g, color.b];\n    }\n\n    /**\n     * Cast any Scratch argument to an RGB color object to be used for the renderer.\n     * @param {*} value Value to convert to RGB color object.\n     * @return {import(\"../typescript-support/types\").RGBObject} [r,g,b], values between 0-255.\n     */\n    static toRgbColorObject (value) {\n        let color;\n        if (typeof value === 'string' && value.substring(0, 1) === '#') {\n            color = Color.hexToRgb(value);\n            // If the color wasn't *actually* a hex color, cast to black\n            if (!color) color = {r: 0, g: 0, b: 0, a: 255};\n        } else {\n            color = Color.decimalToRgb(Cast.toNumber(value));\n        }\n        return color;\n    }\n\n    /**\n     * Determine if a Scratch argument is a white space string (or null / empty).\n     * @param {*} val value to check.\n     * @return {boolean} True if the argument is all white spaces or null / empty.\n     */\n    static isWhiteSpace (val) {\n        return val === null || (typeof val === 'string' && val.trim().length === 0);\n    }\n\n    /**\n     * Compare two values, using Scratch cast, case-insensitive string compare, etc.\n     * In Scratch 2.0, this is captured by `interp.compare.`\n     * @param {*} v1 First value to compare.\n     * @param {*} v2 Second value to compare.\n     * @returns {number} Negative number if v1 < v2; 0 if equal; positive otherwise.\n     */\n    static compare (v1, v2) {\n        let n1 = Number(v1);\n        let n2 = Number(v2);\n        if (n1 === 0 && Cast.isWhiteSpace(v1)) {\n            n1 = NaN;\n        } else if (n2 === 0 && Cast.isWhiteSpace(v2)) {\n            n2 = NaN;\n        }\n        if (isNaN(n1) || isNaN(n2)) {\n            // At least one argument can't be converted to a number.\n            // Scratch compares strings as case insensitive.\n            const s1 = String(v1).toLowerCase();\n            const s2 = String(v2).toLowerCase();\n            if (s1 < s2) {\n                return -1;\n            } else if (s1 > s2) {\n                return 1;\n            }\n            return 0;\n        }\n        // Handle the special case of Infinity\n        if (\n            (n1 === Infinity && n2 === Infinity) ||\n            (n1 === -Infinity && n2 === -Infinity)\n        ) {\n            return 0;\n        }\n        // Compare as numbers.\n        return n1 - n2;\n    }\n\n    /**\n     * Determine if a Scratch argument number represents a round integer.\n     * @param {*} val Value to check.\n     * @return {boolean} True if number looks like an integer.\n     */\n    static isInt (val) {\n        // Values that are already numbers.\n        if (typeof val === 'number') {\n            if (isNaN(val)) { // NaN is considered an integer.\n                return true;\n            }\n            // True if it's \"round\" (e.g., 2.0 and 2).\n            return val === parseInt(val, 10);\n        } else if (typeof val === 'boolean') {\n            // `True` and `false` always represent integer after Scratch cast.\n            return true;\n        } else if (typeof val === 'string') {\n            // If it contains a decimal point, don't consider it an int.\n            return val.indexOf('.') < 0;\n        }\n        return false;\n    }\n\n    static get LIST_INVALID () {\n        return 'INVALID';\n    }\n\n    static get LIST_ALL () {\n        return 'ALL';\n    }\n\n    /**\n     * Compute a 1-based index into a list, based on a Scratch argument.\n     * Two special cases may be returned:\n     * LIST_ALL: if the block is referring to all of the items in the list.\n     * LIST_INVALID: if the index was invalid in any way.\n     * @param {*} index Scratch arg, including 1-based numbers or special cases.\n     * @param {number} length Length of the list.\n     * @param {boolean} acceptAll Whether it should accept \"all\" or not.\n     * @return {(number|string)} 1-based index for list, LIST_ALL, or LIST_INVALID.\n     */\n    static toListIndex (index, length, acceptAll) {\n        if (typeof index !== 'number') {\n            if (index === 'all') {\n                return acceptAll ? Cast.LIST_ALL : Cast.LIST_INVALID;\n            }\n            if (index === 'last') {\n                if (length > 0) {\n                    return length;\n                }\n                return Cast.LIST_INVALID;\n            } else if (index === 'random' || index === 'any') {\n                if (length > 0) {\n                    return 1 + Math.floor(Math.random() * length);\n                }\n                return Cast.LIST_INVALID;\n            }\n        }\n        index = Math.floor(Cast.toNumber(index));\n        if (index < 1 || index > length) {\n            return Cast.LIST_INVALID;\n        }\n        return index;\n    }\n}\n\nmodule.exports = Cast;\n","import { ArgumentType } from \"./enums\";\nimport { RGBObject, TypeByArgumentType, ValueOf } from \"./types\";\nimport Cast from '$scratch-vm/util/cast';\n\nexport const castToType = (argumentType: ValueOf<typeof ArgumentType>, value: any) => {\n  switch (argumentType) {\n    case ArgumentType.String:\n      return `${value}`;\n    case ArgumentType.Number:\n      return parseFloat(value);\n    case ArgumentType.Boolean:\n      return JSON.parse(value);\n    case ArgumentType.Note:\n      return parseInt(value);\n    case ArgumentType.Angle:\n      return parseInt(value);\n    case ArgumentType.Matrix:\n      return toMatrix(value);\n    case ArgumentType.Color:\n      return Cast.toRgbColorObject(value) as RGBObject;\n    default:\n      throw new Error(`Method not implemented for value of ${value} and type ${argumentType}`);\n  }\n}\n\nexport const tryCastToArgumentType = <T extends ValueOf<typeof ArgumentType>>(\n  argumentType: T,\n  value: any,\n  onFailure: (value: any) => TypeByArgumentType<T>\n): TypeByArgumentType<T> => {\n  try {\n    const casted = castToType(argumentType, value);\n    return casted as TypeByArgumentType<T>;\n  }\n  catch {\n    return onFailure(value);\n  }\n}\n\nconst toFlag = (value: string): boolean => parseInt(value) === 1;\n\nconst toMatrix = (matrixString: string): boolean[][] => {\n  if (matrixString.length !== 25) return new Array(5).fill(new Array(5).fill(false));\n\n  const entries = matrixString.split('');\n  const matrix = entries.map(toFlag).reduce((matrix, flag, index) => {\n    const row = Math.floor(index / 5);\n    const column = index % 5;\n    (column === 0) ? matrix[row] = [flag] : matrix[row].push(flag);\n    return matrix;\n  }, new Array<boolean[]>(5));\n\n  return matrix;\n}","export const openUIEvent = \"OPEN_UI_FROM_EXTENSION\";\nexport const registerButtonCallbackEvent = \"REGISTER_BUTTON_CALLBACK_FROM_EXTENSION\";\nexport const FrameworkID = \"ExtensionFramework\";\n\nexport const customArgumentFlag = \"internal_IsCustomArgument\";\nexport const customArgumentCheck = \"isCustomArgumentHack\";\nexport const dropdownStateFlag = \"dropdownState\";\nexport const dropdownEntryFlag = \"dropdownEntry\";\nexport const initDropdownState = \"init\";\nexport const openDropdownState = \"open\";\nexport const closeDropdownState = \"close\"; ","import Runtime from \"$scratch-vm/engine/runtime\";\nimport { Extension as BaseExtension } from \"./extension/Extension\";\nimport { openUIEvent, registerButtonCallbackEvent } from \"./globals\";\n\nexport type ReactivityDependency = any | any[];\n\nexport const activeClass = true;\n\nexport const px = (numberOf: number) => `${numberOf}px`;\n\ntype UniqueKeys<Extension> = Exclude<keyof Extension, keyof BaseExtension<any, any>>;\ntype Methods<Extension> = { [K in UniqueKeys<Extension>]-?: Extension[K] extends (...args: any) => any ? K : never };\ntype Properties<Extension> = { [K in UniqueKeys<Extension>]-?: Extension[K] extends (...args: any) => any ? never : K };\ntype MethodParams<Extension> = { [Key in UniqueKeys<Extension>]: Extension[Key] extends (...args: any) => any ? Parameters<Extension[Key]> : never };\ntype MethodReturns<Extension> = { [Key in UniqueKeys<Extension>]: Extension[Key] extends (...args: any) => any ? ReturnType<Extension[Key]> : never };\n\nexport type ReactiveInvoke<Extension> = <T extends keyof Methods<Extension>>(funcName: Methods<Extension>[T] extends never ? never : T, ...args: MethodParams<Extension>[T]) => MethodReturns<Extension>[T];\nexport type ReactiveSet<Extension> = <T extends keyof Properties<Extension>>(propertyName: Properties<Extension>[T] extends never ? never : T, value: Extension[T]) => void;\n\nexport type ReactiveMethods<Extension> = {\n  invoke: ReactiveInvoke<Extension>;\n  set: ReactiveSet<Extension>;\n}\n\nexport const reactiveInvoke = <Extension, T extends keyof Methods<Extension>>(extensionAssignment: Extension, funcName: T, args: MethodParams<Extension>[T]): MethodReturns<Extension>[T] => {\n  return (extensionAssignment[funcName] as Function)(...args as []);\n}\n\nexport const reactiveSet = <Extension, T extends keyof Properties<Extension>>(extensionAssignment: Extension, propertyName: T, value: Extension[T]): void => {\n  extensionAssignment[propertyName] = value;\n}\n\nexport const openUI = (runtime: Runtime, details: { id: string, name: string, component: string, label?: string }) => runtime.emit(openUIEvent, details);\n\nexport const registerButtonCallback = (runtime: Runtime, buttonID: string, callback: (...args: any[]) => void) => {\n  runtime.emit(registerButtonCallbackEvent, buttonID);\n  runtime.on(buttonID, callback);\n}\n\nconst enum Color {\n  ui = \"ui\",\n  text = \"text\",\n  motion = \"motion\",\n  red = \"red\",\n  sound = \"sound\",\n  control = \"control\",\n  data = \"data\",\n  pen = \"pen\",\n  error = \"error\",\n  extensions = \"extensions\",\n  drop = \"drop\"\n}\n\n/**\n * Makes it easier to reference the css color variables defined in prg-extension-boilerplate/packages/scratch-gui/src/components/programmatic-modal/programmatic-modal.jsx\n */\nclass CssVar {\n  root: Color;\n\n  constructor(root: Color) { this.root = root }\n\n  get(...parts: string[]) { return `var(--${this.root}-${parts.join(\"-\")})` }\n  primary(...parts: string[]) { return this.get(\"primary\", ...parts) }\n  secondary(...parts: string[]) { return this.get(\"secondary\", ...parts) }\n  tertiary(...parts: string[]) { return this.get(\"tertiary\", ...parts) }\n  transparent(...parts: string[]) { return this.get(\"transparent\", ...parts) }\n  light(...parts: string[]) { return this.get(\"light\", ...parts) }\n}\n\nconst ui = new CssVar(Color.ui);\nconst text = new CssVar(Color.text);\nconst motion = new CssVar(Color.motion);\nconst red = new CssVar(Color.red);\nconst sound = new CssVar(Color.sound);\nconst control = new CssVar(Color.control);\nconst data = new CssVar(Color.data);\nconst pen = new CssVar(Color.pen);\nconst error = new CssVar(Color.error);\nconst extensions = new CssVar(Color.extensions);\nconst drop = new CssVar(Color.extensions);\n\n/**\n * Color variable references corresponding to the css variables defined in prg-extension-boilerplate/packages/scratch-gui/src/components/programmatic-modal/programmatic-modal.jsx\n */\nexport const color = {\n  \"ui\": {\n    primary: ui.primary(),\n    secondary: ui.secondary(),\n    tertiary: ui.tertiary(),\n    modalOverlay: ui.get(\"modal\", \"overlay\"),\n    white: ui.get(\"white\"),\n    whiteDim: ui.get(\"white\", \"dim\"),\n    whiteTransparent: ui.get(\"white\", \"transparent\"),\n    transparent: ui.transparent(),\n    blackTransparent: ui.get(\"black\", \"transparent\"),\n  },\n  \"text\": {\n    primary: text.primary(),\n    primaryTransparent: text.transparent(),\n  },\n  \"motion\": {\n    primary: motion.primary(),\n    tertiary: motion.tertiary(),\n    transparent: motion.get(\"transparent\"),\n    lightTansparent: motion.light(\"transparent\"),\n  },\n  \"red\": {\n    primary: red.primary(),\n    tertiary: red.tertiary(),\n  },\n  \"sound\": {\n    primary: sound.primary(),\n    tertiary: sound.tertiary(),\n  },\n  \"control\": {\n    primary: control.primary(),\n  },\n  \"data\": {\n    primary: data.primary(),\n  },\n  \"pen\": {\n    primary: pen.primary(),\n    transparent: pen.transparent(),\n  },\n  \"error\": {\n    primary: error.primary(),\n    light: error.light(),\n    transparent: error.transparent(),\n  },\n  \"extensions\": {\n    primary: extensions.primary(),\n    tertiary: extensions.tertiary(),\n    light: extensions.light(),\n    transparent: extensions.transparent(),\n  },\n  \"drop\": {\n    highlight: drop.get(\"highlight\")\n  }\n}","import { MenuItem, Primitive } from \"./types\"\n\ntype FetchParams = {\n  request: Parameters<typeof fetch>[0],\n  options: Parameters<typeof fetch>[1]\n}\n\nexport const getValueFromMenuItem = <T>(item: MenuItem<T>) => typeof item === \"object\" ? (item as { value: T }).value : item;\n\nexport const getTextFromMenuItem = <T>(item: MenuItem<T>) => typeof item === \"object\" ? (item as { text: string }).text : item;\n\nexport async function fetchWithTimeout(\n  resource: FetchParams[\"request\"],\n  options: FetchParams[\"options\"] & { timeout: number }\n) {\n  const { timeout } = options;\n\n  const controller = new AbortController();\n  const id = setTimeout(() => controller.abort(), timeout);\n\n  const response = await fetch(resource, {\n    ...options,\n    signal: controller.signal\n  });\n\n  clearTimeout(id);\n\n  return response;\n}\n\nexport async function untilObject<T>(getter: () => T, delay: number = 100): Promise<T> {\n  let timeout: NodeJS.Timeout;\n  let value: T = getter();\n  while (!value) {\n    await new Promise(resolve => {\n      clearTimeout(timeout);\n      timeout = setTimeout(resolve, delay);\n    });\n    value = getter();\n  }\n  clearTimeout(timeout);\n  return value;\n}\n\nexport async function untilCondition(condition: () => boolean, delay: number = 100): Promise<void> {\n  let timeout: NodeJS.Timeout;\n  while (!condition()) {\n    await new Promise(resolve => {\n      clearTimeout(timeout);\n      timeout = setTimeout(resolve, delay);\n    });\n  }\n  clearTimeout(timeout);\n};\n\nexport async function untilReady<T extends { ready: boolean }>(obj: T, delay: number = 100): Promise<void> {\n  let timeout: NodeJS.Timeout;\n  while (!obj.ready) {\n    await new Promise(resolve => {\n      clearTimeout(timeout);\n      timeout = setTimeout(resolve, delay);\n    });\n  }\n  clearTimeout(timeout);\n};\n\nexport const isString = (query: any): query is string => typeof query === 'string' || query instanceof String;\n\nexport const isFunction = (query: any): query is (...args: any[]) => any =>\n  Object.prototype.toString.call(query) === \"[object Function]\"\n  || \"function\" === typeof query\n  || query instanceof Function;\n\nexport const isPrimitive = (query: any): query is Primitive => query !== Object(query);\n\nexport const splitOnCapitals = (query: string) => query.split(/(?=[A-Z])/);\n\n/**\n * A type safe utility function for copy values from one object to another\n * @param param0 object containing the target to copy values to and the source of the values to copy\n */\nexport const copyTo = <TTarget extends object, TSource extends { [k in keyof TTarget]?: TTarget[k] }>({ target, source }: { target: TTarget, source: TSource }) => {\n  for (const key in source) {\n    if (!(key in target)) continue;\n    // @ts-ignore -- the types of the function should ensure this is valid TS\n    target[key] = source[key]\n  }\n}\n\nexport const identity = (x: any) => x;\n\nexport const loadExternalScript = (url: string, onLoad: () => void, onError?: () => void) => {\n  const script = document.createElement('script');\n\n  script.onload = onLoad;\n\n  script.onerror = onError ?? (() => {\n    throw new Error(`Error loading endpoint: ${url}`)\n  });\n\n  script.src = url;\n  script.async = true;\n\n  document.body.appendChild(script);\n}\n\n/**\n * \n * @param url \n * @returns \n */\nexport const untilExternalScriptLoaded = async (url: string): Promise<void> => {\n  const scriptLoaded = new Promise((resolve, reject) => {\n    const script = document.createElement('script');\n    script.onload = resolve;\n    script.onerror = reject;\n    script.async = true;\n    script.src = url;\n    document.body.appendChild(script);\n  });\n  await scriptLoaded;\n  return;\n}\n\n/**\n * \n * @param url \n * @param globalVariableName \n * @returns \n */\nexport const untilExternalGlobalVariableLoaded = async <T>(url: string, globalVariableName: string): Promise<T> => {\n  if (window[globalVariableName]) return window[globalVariableName];\n  await untilExternalScriptLoaded(url);\n  return window[globalVariableName];\n}\n\n/**\n * Utilize javascript's \"call\" method (on Function.prototype) in a typesafe manner\n * @param fn \n * @param _this \n * @param args \n * @returns \n */\nexport const typesafeCall = <Args extends any[], Return, This, Fn extends (this: This, ...args: Args) => Return>(fn: Fn, _this: This, ...args: Args) => fn.call(_this, ...args) as Return;","import { castToType } from \"$common/cast\";\nimport CustomArgumentManager from \"$common/customArguments/CustomArgumentManager\";\nimport { ArgumentType, BlockType } from \"$common/enums\";\nimport { BlockOperation, Argument, ValueOf, VerboseArgument, Menu, ExtensionMetadata, ExtensionBlockMetadata, ExtensionMenuMetadata, DynamicMenu, MenuItem, ExtensionArgumentMetadata, MenuThatAcceptsReporters, DynamicMenuThatAcceptsReporters, ValidKey } from \"$common/types\";\nimport { registerButtonCallback } from \"$common/ui\";\nimport { isPrimitive, isString, isFunction, identity, typesafeCall } from \"$common/utils\";\nimport { BlockMetadata, ExtensionBaseConstructor, DecoratedExtension } from \"$common/extension/Extension\";\nimport customArguments from \"$common/extension/mixins/customArguments\";\nimport type BlockUtility from \"$root/packages/scratch-vm/src/engine/block-utility\";\n\nexport type BlockGetter<This, Fn extends BlockOperation> = (this: This, self: This) => BlockMetadata<Fn>;\ntype BlockDefinition<T, Fn extends BlockOperation> = BlockMetadata<Fn> | BlockGetter<T, Fn>;\n\nexport const getArgumentType = <T>(arg: Argument<T>): ValueOf<typeof ArgumentType> =>\n  isPrimitive(arg) ? arg as ValueOf<typeof ArgumentType> : (arg as VerboseArgument<T>).type;\n\nexport const extractArgNamesFromText = (text: string): string[] => {\n  const textAndNumbersInBrackets = /\\[([A-Za-z0-9]+)\\]/gm;\n  const argNames: string[] = [];\n  for (const [_, result] of text.matchAll(textAndNumbersInBrackets)) {\n    argNames.push(result);\n  }\n  return argNames;\n}\n\nexport const getImplementationName = (opcode: string) => `internal_${opcode}`;\n\nexport const wrapOperation = (context: any, operation: BlockOperation, args: { name: string, type: ValueOf<typeof ArgumentType>, handler: Handler }[]) => {\n  return function (this: DecoratedExtension, argsFromScratch: Record<string, any>, blockUtility: BlockUtility) {\n    const castedArguments = args.map(({ name, type, handler }) => {\n      const param = argsFromScratch[name];\n      switch (type) {\n        case ArgumentType.Custom:\n          const isIdentifier = isString(param) && CustomArgumentManager.IsIdentifier(param);\n          const value = isIdentifier ? this.customArgumentManager.getEntry(param).value : param;\n          return handler(value);\n        default:\n          return castToType(type, handler(param));\n      }\n    });\n    return operation.call(context, ...castedArguments, blockUtility);\n  }\n}\n\nexport default function <T extends ExtensionBaseConstructor & ReturnType<typeof customArguments>>(Ctor: T) {\n  type BlockEntry = { definition: BlockDefinition<_, BlockOperation>, operation: BlockOperation };\n  type BlockMap = Map<string, BlockEntry>;\n  abstract class _ extends Ctor {\n    private readonly blockMap: BlockMap = new Map();\n\n    private readonly menus: Menu<any>[] = [];\n    private info: ExtensionMetadata;\n\n    pushBlock<Fn extends BlockOperation>(opcode: string, block: BlockDefinition<any, Fn>, operation: BlockOperation) {\n      if (this.blockMap.has(opcode)) throw new Error(`Attempt to push block with opcode ${opcode}, but it was already set. This is assumed to be a mistake.`)\n      this.blockMap.set(opcode, { definition: block, operation });\n    }\n\n    protected getInfo(): ExtensionMetadata {\n      if (!this.info) {\n        const { id, name, blockIconURI } = this;\n        const blocks = Array.from(this.blockMap.entries()).map(entry => this.convertToInfo(entry));\n        this.info = { id, blocks, name, blockIconURI, menus: this.collectMenus() };\n      }\n      return this.info;\n    }\n\n    private convertToInfo(details: [opcode: string, entry: BlockEntry]) {\n      const [opcode, entry] = details;\n      const { definition, operation } = entry;\n\n      // Utilize explicit casting to appease test framework's typechecker\n      const block = isBlockGetter(definition)\n        ? typesafeCall(definition, this, this) as BlockMetadata<BlockOperation>\n        : definition as BlockMetadata<BlockOperation>;\n\n      const { type, text } = block;\n\n      const args = extractArgs(block);\n\n      const { id, runtime, menus } = this;\n\n      const displayText = convertToDisplayText(opcode, text, args);\n      const argumentsInfo = convertToArgumentInfo(opcode, args, menus);\n\n      const info: ExtensionBlockMetadata = { opcode, text: displayText, blockType: type, arguments: argumentsInfo };\n\n      if (type === BlockType.Button) {\n        const buttonID = getButtonID(id, opcode);\n        registerButtonCallback(runtime, buttonID, operation.bind(this));\n        info.func = buttonID;\n      } else {\n        const implementationName = getImplementationName(opcode);\n        this[implementationName] = wrapOperation(this, operation, zipArgs(args));\n      }\n\n      return info;\n    }\n\n    private collectMenus() {\n      const { isSimpleStatic, isSimpleDynamic, isStaticWithReporters, isDynamicWithReporters } = menuProbe;\n      return Object.fromEntries(\n        this.menus\n          .map((menu, index) => {\n            if (isSimpleStatic(menu)) return asStaticMenu(menu, false);\n            if (isSimpleDynamic(menu)) return this.registerDynamicMenu(menu, false, index);\n            if (isStaticWithReporters(menu)) return asStaticMenu(menu.items, true);\n            if (isDynamicWithReporters(menu)) return this.registerDynamicMenu(menu.getItems, true, index);\n            throw new Error(\"Unable to process menu\");\n          })\n          .reduce((map, menu, index) => map.set(getMenuName(index), menu), new Map<string, ExtensionMenuMetadata>())\n      );\n    }\n\n    private registerDynamicMenu(getItems: DynamicMenu<any>, acceptReporters: boolean, menuIndex: number) {\n      const key = `internal_dynamic_${menuIndex}`; // legacy support?\n      this[key] = () => getItems().map(item => item).map(convertMenuItemsToString);\n      return { acceptReporters, items: key } satisfies ExtensionMenuMetadata\n    }\n  }\n\n  return _;\n}\n\nconst extractArgs = (block: BlockMetadata<BlockOperation>) => {\n  const argKey: ValidKey<Block.OneArg> = \"arg\";\n  const argsKey: ValidKey<Block.MultipleArgs> = \"args\";\n  if (argKey in block && block[argKey]) return [(block as Block.OneArg).arg];\n  if (argsKey in block && (block[argsKey]?.length ?? 0) > 0) return (block as Block.MultipleArgs).args;\n  return [];\n}\n\nconst zipArgs = (args: Argument<any>[], names?: string[]) => {\n  const types = args.map(getArgumentType);\n  const handlers = extractHandlers(args);\n  names ??= types.map((_, index) => getArgName(index));\n  assertSameLength(types, handlers, names);\n  return types.map((type, index) => ({ type, name: names[index], handler: handlers[index] }));\n}\n\nconst assertSameLength = (...collections: any[][]) => {\n  const { size } = collections.reduce((set, { length }) => set.add(length), new Set<number>());\n  if (size !== 1) throw new Error(\"Zip failed because collections weren't equal length\");\n}\n\nconst isBlockGetter = <T, Fn extends BlockOperation>(details: BlockDefinition<any, Fn>): details is BlockGetter<T, Fn> => isFunction(details);\n\nconst format = (text: string, identifier: string, description: string): string => {\n  return text; // make use of formatMessage in the future\n}\n\nconst isDynamicText = (text: Block.Any[\"text\"]): text is (Block.OneArg[\"text\"] | Block.MultipleArgs[\"text\"]) => !isString(text);\n\nconst convertMenuItemsToString = (item: any | MenuItem<any>) =>\n  isPrimitive(item) ? `${item}` : { ...item, value: `${item.value}` };\n\nconst getArgTranslationID = (blockname: string, index: number) => `${blockname}-arg${index}-default`;\n\nconst getButtonID = (id: string, opcode: string) => `${id}_${opcode}`;\n\nconst convertToDisplayText = (opcode: string, text: Block.Any[\"text\"], args: Argument<any>[]) => {\n  if (!args || args.length === 0) return text as string;\n\n  validateText(text, args.length);\n\n  if (!isDynamicText(text)) return format(text, opcode, `Block text for '${opcode}'`);\n\n  const textFunc: (...args: any[]) => string = text;\n  const argPlaceholders = args.map((_, index) => `[${getArgName(index)}]`);\n  return format(textFunc(...argPlaceholders), opcode, `Block text for '${opcode}'`);\n}\n\nconst convertToArgumentInfo = (opcode: string, args: Argument<any>[], menus: Menu<any>[]) => {\n  if (!args || args.length === 0) return undefined;\n\n  return Object.fromEntries(\n    args\n      .map((element, index) => {\n        const entry = {} as ExtensionArgumentMetadata;\n        entry.type = getArgumentType(element);\n\n        if (isPrimitive(element)) return entry;\n\n        const { defaultValue, options } = element as VerboseArgument<any>;\n\n        setDefaultValue(entry, opcode, index, defaultValue);\n        setMenu(entry, options, menus);\n\n        return entry;\n      })\n      .reduce(\n        (accumulation, entry, index) => accumulation.set(getArgName(index), entry),\n        new Map<string, ExtensionArgumentMetadata>\n      )\n  );\n}\n\n\nexport const getArgName = (index: number) => `${index}`;\nconst getMenuName = (index: number) => `${index}`;\n\nconst getDefaultValue = (defaultValue: any, opcode: string, index: number) => isString(defaultValue)\n  ? format(defaultValue, getArgTranslationID(opcode, index), `Default value for arg ${index + 1} of ${opcode} block`)\n  : defaultValue;\n\nconst setDefaultValue = (entry: ExtensionArgumentMetadata, opcode: string, index: number, defaultValue: any,) => {\n  if (defaultValue === undefined) return;\n  entry.defaultValue = getDefaultValue(defaultValue, opcode, index)\n}\n\nconst addOptionsAndGetMenuName = (options: Menu<any>, menus: Menu<any>[],) => {\n  const alreadyAddedIndex = menus.indexOf(options);\n  const menuIndex = alreadyAddedIndex >= 0 ? alreadyAddedIndex : menus.push(options) - 1;\n  return `${getMenuName(menuIndex)}`;\n}\n\nconst setMenu = (entry: ExtensionArgumentMetadata, options: Menu<any>, menus: Menu<any>[]) =>\n  options ? entry.menu = addOptionsAndGetMenuName(options, menus) : null;\n\nconst validateText = (text: Block.Any[\"text\"], argCount: number) => {\n  // TODO: Check that no numbers within square brackets appear in text\n  return true;\n}\n\ntype Handler = (MenuThatAcceptsReporters<any>['handler']);\nconst isVerbose = (arg: Argument<any>): arg is VerboseArgument<any> => !isPrimitive(arg);\nconst handlerKey: keyof MenuThatAcceptsReporters<any> = 'handler';\nconst hasHandler = (options: Menu<any>): options is MenuThatAcceptsReporters<any> | DynamicMenuThatAcceptsReporters<any> => options && handlerKey in options;\n\nconst extractHandlers = (args: Argument<any>[]): Handler[] => args.map(element => {\n  if (!isVerbose(element)) return identity;\n  const { options } = element;\n  if (!hasHandler(options)) return identity;\n  return options.handler;\n});\n\nconst reporterItemsKey: keyof MenuThatAcceptsReporters<any> = \"items\";\nconst reporterItemsGetterKey: keyof DynamicMenuThatAcceptsReporters<any> = \"getItems\";\n\nconst menuProbe = {\n  isSimpleStatic: (menu: Menu<any>): menu is any[] | MenuItem<any>[] => Array.isArray(menu),\n  isSimpleDynamic: (menu: Menu<any>): menu is DynamicMenu<any> => isFunction(menu),\n  isStaticWithReporters: (menu: Menu<any>): menu is MenuThatAcceptsReporters<any> => reporterItemsKey in menu,\n  isDynamicWithReporters: (menu: Menu<any>): menu is DynamicMenuThatAcceptsReporters<any> => reporterItemsGetterKey in menu,\n}\n\nconst asStaticMenu = (items: MenuItem<any>[], acceptReporters: boolean) => ({\n  acceptReporters,\n  items: items\n    .map(item => item /**TODO figure out how to format */)\n    .map(convertMenuItemsToString)\n} satisfies ExtensionMenuMetadata);\n\nnamespace Block {\n  export type NoArgs = BlockMetadata<() => any>;\n  export type OneArg = BlockMetadata<(arg: any, utility: BlockUtility) => any>;\n  export type MultipleArgs = BlockMetadata<(arg1: any, arg2: any, utility: BlockUtility) => any>;\n  export type WithArgs = BlockMetadata<(...args: any[]) => any>;\n  export type Any = NoArgs | OneArg | MultipleArgs;\n}","import { Extension } from \"$common/extension/Extension\";\nimport { untilObject } from \"$common/utils\";\nimport { ArgumentEntry, ArgumentEntrySetter } from \"./CustomArgumentManager\";\n\n/** Constructed based on Svelte documentation: https://svelte.dev/docs#run-time-client-side-component-api-creating-a-component */\ntype CreateComponentOptions = {\n  target: Element | HTMLElement;\n  anchor?: Element | HTMLElement;\n  props: {};\n}\n\nexport type CustomArgumentUIConstructor = (options: CreateComponentOptions) => void;\n\nexport const renderToDropdown = async <T>(\n  compononentConstructor: CustomArgumentUIConstructor,\n  props: {\n    extension: Extension<any, any>,\n    setter: ArgumentEntrySetter<T>,\n    current: ArgumentEntry<T>\n  }\n) => {\n  const dropdownContainerClass = \"blocklyDropDownContent\";\n  const elements = document.getElementsByClassName(dropdownContainerClass);\n  if (elements.length !== 1) return console.error(`Uh oh! Expected 1 element with class '${dropdownContainerClass}', but found ${elements.length}`);\n  const [target] = elements;\n  const anchor = await untilObject(() => target.children[0]);\n  const component = new compononentConstructor({ target, anchor, props });\n  centerDropdownButton(anchor);\n}\n\nconst centerDropdownButton = (container: Element) => {\n  type ClassAndStyleModification = [string, (syle: CSSStyleDeclaration) => void];\n\n  const findElementAndModifyStyle = ([className, styleMod]: ClassAndStyleModification) => {\n    const elements = container.getElementsByClassName(className);\n    console.assert(elements.length === 1, `Incorrect number of elements found with class: ${className}`);\n    styleMod((elements[0] as HTMLElement).style);\n  };\n\n  const elements = [\n    [\n      \"goog-menuitem goog-option\",\n      (style) => {\n        style.margin = \"auto\";\n        style.paddingLeft = style.paddingRight = \"0px\";\n      }\n    ],\n    [\n      \"goog-menuitem-content\",\n      (style) => style.textAlign = \"center\"\n    ]\n  ] satisfies ClassAndStyleModification[];\n\n  elements.forEach(findElementAndModifyStyle);\n}","import { ExtensionBaseConstructor } from \"$common/extension/Extension\";\nimport type Runtime from \"$scratch-vm/engine/runtime\";\nimport CustomArgumentManager, { ArgumentEntry } from \"$common/customArguments/CustomArgumentManager\";\nimport { CustomArgumentUIConstructor, renderToDropdown } from \"$common/customArguments/dropdownOverride\";\nimport { ArgumentType } from \"$common/enums\";\nimport { openDropdownState, closeDropdownState, initDropdownState, customArgumentFlag, customArgumentCheck, dropdownStateFlag, dropdownEntryFlag } from \"$common/globals\";\nimport { Argument, BaseExtension } from \"$common/types\";\n\ntype ComponentGetter = (id: string, componentName: string) => CustomArgumentUIConstructor;\n\nconst callingContext = {\n  DrowpdownOpen: openDropdownState,\n  DropdownClose: closeDropdownState,\n  Init: initDropdownState,\n} as const;\n\n/**\n * Mixin the ability for extensions to create custom argument types with their own specific UIs\n * @param Ctor \n * @returns \n */\nexport default function <T extends ExtensionBaseConstructor>(Ctor: T) {\n  abstract class _ extends Ctor {\n\n    /**\n     * Create a custom argument for one of this block's arguments\n     * @param param0 \n     * - component: The svelte component to render the custom argument UI\n     * - initial: The starting value of the the custom argument (including both its value and text representation)\n     * - acceptReportersHandler: A function that must be defined if you'd like for your custom argument to accept reporters\n     * @returns \n     */\n    protected makeCustomArgument = <T>({ component, initial, acceptReportersHandler: handler }: { component: string, initial: ArgumentEntry<T>, acceptReportersHandler?: (x: any) => ArgumentEntry<T> }): Argument<T> => {\n      this.argumentManager ??= new CustomArgumentManager();\n      const id = this.argumentManager.add(initial);\n      const getItems = () => [{ text: customArgumentFlag, value: JSON.stringify({ component, id }) }];\n      return {\n        type: ArgumentType.Custom,\n        defaultValue: id,\n        options: handler === undefined ? getItems : { acceptsReports: true, getItems, handler },\n      } as Argument<T>\n    }\n\n    protected argumentManager: CustomArgumentManager = null;\n\n    public get customArgumentManager(): CustomArgumentManager {\n      return this.argumentManager\n    }\n\n    /**\n     * Utilized externally by scratch-vm to check if a given argument should be treated as a 'custom argument'.\n     * Checks if the value returned by a dyanmic menu indicates that it should be treated as a 'custom argument'\n     */\n    private [customArgumentCheck](arr: Array<string | { text: string }>) {\n      if (arr.length !== 1) return false;\n      const item = arr[0];\n      if (typeof item !== \"object\") return false;\n      const { text } = item;\n      return text === customArgumentFlag;\n    };\n\n    /**\n     * Utilized externally by scratch-vm to process custom arguments\n     * @param runtime NOTE: once we switch to V2, we can remove this and instead use the extension's runtime\n     * @param param1 \n     * @param getComponent \n     * @returns \n     */\n    private processCustomArgumentHack(runtime: Runtime, [{ value }]: { value: string }[], getComponent: ComponentGetter): (readonly [string, string])[] {\n\n      const { id: extensionID, customArgumentManager: argumentManager } = this;\n      const { component, id: initialID } = JSON.parse(value) as { component: string, id: string };\n      const context = runtime[dropdownStateFlag];\n\n      switch (context) {\n        case callingContext.Init:\n          return argumentManager.getCurrentEntries();\n        case callingContext.DropdownClose: {\n          const result = argumentManager.tryResolve();\n          return result ? [[result.entry.text, result.id]] : argumentManager.getCurrentEntries();\n        }\n        case callingContext.DrowpdownOpen: {\n          const currentEntry = runtime[dropdownEntryFlag] as ArgumentEntry<any>;\n          const prevID = currentEntry?.value ?? initialID;\n          const current = argumentManager.getEntry(prevID);\n          const [id, setEntry] = argumentManager.request();\n          renderToDropdown(getComponent(extensionID, component), { setter: setEntry, current, extension: this as any as BaseExtension });\n          return [[\"Apply\", id]];\n        }\n      }\n\n      throw new Error(\"Error during processing -- Context:\" + callingContext);\n    };\n\n  }\n\n  return _;\n}","import type Runtime from \"$scratch-vm/engine/runtime\";\nimport type BlockUtility from \"$scratch-vm/engine/block-utility\";\nimport customSaveData from \"$common/extension/mixins/customSaveData\";\nimport scratchInfo, { getImplementationName } from \"$common/extension/mixins/scratchInfo\";\nimport customArgumentSupport from \"$common/extension/mixins/customArguments\";\nimport uiSupport from \"$common/extension/mixins/ui\";\nimport { BlockOperation, Block, BaseExtension, Environment, ExtensionMenuDisplayDetails, ExtensionBlocks, BlockDefinitions, Translations } from \"$common/types\";\nimport { isFunction } from \"$common/utils\";\n\nexport type BlockMetadata<Fn extends BlockOperation> = Parameters<Fn> extends [...infer R extends any[], BlockUtility]\n  ? Omit<Block<BaseExtension, (...args: R) => ReturnType<Fn>>, \"operation\">\n  : Omit<Block<BaseExtension, Fn>, \"operation\">;\n\nexport type CodeGenArgs = {\n  name: never,\n  id: never,\n  blockIconURI: never,\n}\n\ntype ExlcudeFirst<F> = F extends [any, ...infer R] ? R : never;\nexport type CodeGenParams = ExlcudeFirst<ConstructorParameters<typeof ExtensionBase>>;\n\nexport abstract class ExtensionBase {\n  /**\n   * @summary This member function (or 'method') will be called when a user adds your extension via the Extensions Menu (i.e. when your extension is instantiated)\n   * @example\n   * // Initialize class field(s)\n   * private count: number;\n   * \n   * init() {\n   *  count = 0;\n   * }\n   * @example \n   * // Interact with environment's runtime \n   * init(env: Environment) {\n   *  env.runtime.emit(RuntimeEvent.ProjectStart);\n   * }\n   * @example \n   * // Nothing to initialize\n   * init() {}\n   * @description This function is intended to behave exactly like a constructor, used to initialize the state of your extension.\n   * \n   * The reason we use this function INSTEAD of a constructor is so that the base Extension class can manage the construction of this class.\n   * @param {Environment} env An object that allows your Extension to interact with the Scratch Environment. Currently is a little bare, but will be expanded soon.\n   * Can be ommitted if not needed.\n   * \n   * For Scratch developers: The `runtime` property on env is the same as the runtime passed to non-Typescript-Framework Extension constructors\n   */\n  abstract init(env: Environment): void;\n\n  protected internal_init() {\n    this.init({ runtime: this.runtime, videoFeed: this.runtime.ioDevices?.video });\n  }\n\n  /**\n   * \n   * @param runtime The 'runtime' connected to the scratch-vm that enables your extension to interact with the scratch workspace\n   * @param name The name of this extension.\n   * @param id The ID of this extension.\n   * @param blockIconURI \n   */\n  constructor(readonly runtime: Runtime, readonly name: string, readonly id: string, readonly blockIconURI: string) { }\n}\n\nexport type AbstractConstructor<T> = abstract new (...args: any[]) => T;\nexport type NonAbstractConstructor<T> = new (...args: any[]) => T;\nexport type TypedConstructor<T> = new (...args: any[]) => T;\nexport type ExtensionBaseConstructor = AbstractConstructor<ExtensionBase>;\n\nconst applyAllMixins = (base: ExtensionBaseConstructor) =>\n  scratchInfo(\n    customSaveData(\n      customArgumentSupport(\n        uiSupport(\n          (\n            base\n          )\n        )\n      )\n    )\n  );\n\nexport const extensionsMap = new Map<string, DecoratedExtension>();\n\nexport abstract class ExtensionCommon extends applyAllMixins(ExtensionBase) {\n  abstract readonly version: \"decorated\" | \"generic\";\n\n  /**\n   * Prevent developers from implementing the constructor.\n   * This must be controlled by the framework since Scratch is the one who calls the extension's constructor.\n   * @param FORBIDDEN \n   */\n  constructor(FORBIDDEN: never) {\n    super(...arguments);\n  }\n}\n\nexport abstract class DecoratedExtension extends ExtensionCommon {\n  readonly version = \"decorated\" as const;\n}\n\nexport const getAlternativeOpcodeName = (opcode: string) => `__block_${opcode}`;\n\n/**\n * @summary Base class for all extensions implemented via the Typescript Extension Framework.\n * @example \n * class MyExtension extends Extension<\n *  { // Display details\n *    name: \"My Extension\",\n *    description: \"This is my extension\",\n *    iconURL: \"example.png\",\n *    insetIconURL: \"example.svg\"\n *  },\n *  { // Blocks\n *    myBlock: (someArg: number) => void;\n *  }\n * > {\n *  init(env: Environment): { ... };\n *  defineBlocks(): MyExtension[\"BlockDefinitions\"] { return ... }\n * }\n * @description Extension developers will create Typescript classes that `extend` (or 'inherit', or 'implement') this `Extension` class.\n * \n * In order to `extend` this class, you must first specify 2 generic type arguments, which effectively describe what kind of Extension you're implementing.\n * \n * More specifically, the 2 generic type arguments describe how this extension is presented to the user (by specifyng the details displayed in the Extensions Menu),\n * and what this Extension actually does (by specifying the blocks it will define).\n * \n * By declaring that we're extending an `Extension` with our specific generic type arguments,\n * Typescript holds us accountable to implement exactly what we said we would (all in order to make a working extension).\n *  \n * This includes:\n * * Defining an `init` method, which is used INSTEAD of a constructor\n * * Defining a `defineBlocks` method that does just that: defines this extension's blocks \n * @template MenuDetails How the extension should display in the extensions menu \n * @template Blocks What kind of blocks this extension implements\n * @link https://www.typescriptlang.org/docs/handbook/2/generics.html Learn more about generics! \n */\nexport abstract class Extension\n  <\n    MenuDetails extends ExtensionMenuDisplayDetails,\n    Blocks extends ExtensionBlocks\n  > extends ExtensionCommon {\n\n  readonly BlockFunctions: Blocks;\n  readonly BlockDefinitions: BlockDefinitions<typeof this>;\n  readonly Translations: Translations<typeof this>;\n\n  readonly version = \"generic\" as const;\n\n  /**\n   * @summary Extension member method that returns an object defining all blocks that belong to the extension.\n   * @description Every block your extension implements (defined by the second generic argument of the Extension class), will have an entry in the object return by this function.\n   * Each entry will either be an object or a function that returns an object that provides the:\n   * - type: the type of block\n   * - text: what is displayed on the block\n   * - arg or args: the arguments the block accepts\n   * - operation: the function that is called when the blocked is executed\n   * @example\n   * // Returning an object with two block definition function for 'someBlock'\n   * defineBlocks(): ExampleExtension[\"BlockDefinitions\"] {\n   *  return {\n   *    // Using object syntax\n   *    someBlock: {\n   *      type: BlockType.Reporter,\n   *      arg: ArgumentType.String,\n   *      text: (argument) => `Some text about ${argument}`,\n   *      operation: (argument) => {\n   *        // do something\n   *      }\n   *    },\n   *    // Using arrow function syntax\n   *    someBlock: (self: MyExtension) => ({\n   *      type: BlockType.Reporter,\n   *      arg: ArgumentType.String,\n   *      text: (argument) => `Some text about ${argument}`,\n   *      operation: (argument) => {\n   *        // do something\n   *      }\n   *    }),\n   *    // Using method function syntax\n   *    someOtherBlock(self: MyExtension) {\n   *      const type = BlockType.Reporter;\n   *      const arg = ArgumentType.String;\n   *      return {\n   *        arg, type,\n   *        text: (argument) => `Some text about ${argument}`,\n   *        operation: (argument) => {\n   *          // do something\n   *        }\n   *      }\n   *    }\n   *  }\n   * }\n   * @see BlockDefinitions\n   * @returns {BlockDefinitions<Blocks>} An object defining 'block definition' objects / functions for each block associated with this Extension.\n   */\n  abstract defineBlocks(): BlockDefinitions<Extension<MenuDetails, Blocks>>;\n\n  protected internal_init(): void {\n    super.internal_init();\n    const blocks = this.defineBlocks();\n    const self = this;\n    for (const opcode in blocks) {\n      const block = blocks[opcode];\n      const validOpcode = opcode in this ? getAlternativeOpcodeName(opcode) : opcode;\n      const { operation, text, arg, args, type } = isFunction(block) ? block.call(this, this) : block;;\n      this.pushBlock(validOpcode, { text, arg, args, type }, operation);\n      const internalFuncName = getImplementationName(validOpcode);\n      (this as any)[validOpcode] = function () { return self[internalFuncName].call(self, ...arguments) };\n    }\n  }\n};","import { openUI } from \"$common/ui\";\nimport { ExtensionBaseConstructor } from \"$common/extension/Extension\";\n\nexport default function <T extends ExtensionBaseConstructor>(Ctor: T) {\n  abstract class _ extends Ctor {\n\n    /**\n     * Howdy Hi\n     * @param component \n     * @param label \n     */\n    openUI(component: string, label?: string) {\n      const { id, name, runtime } = this;\n      openUI(runtime, { id, name, component: component.replace(\".svelte\", \"\"), label });\n    }\n\n  }\n\n  return _;\n}\n","const validRegEx = new RegExp('^[a-z0-9]+$', 'i');\nconst invalidRegEx = new RegExp('[^a-z0-9]+', 'gi');\n\nexport const isValidID = (id) => validRegEx.test(id);\n\nconst guard = 'prg';\nconst guards = [guard, guard.split(\"\").reverse().join(\"\")];\n\nconst guardsRegEx = new RegExp(`${guards[0]}([0-9]+)${guards[1]}`, 'g');\n\nconst wrap = (str) => `${guards[0]}${str}${guards[1]}`;\n\nconst replaceAll = (query, current, desired) => query.replaceAll(current, desired);\n\nexport const encode = (query: string): string => {\n  const matches = [...query.matchAll(invalidRegEx)];\n  const invalidCharacters = matches.reduce((set, current) => {\n    current[0].split(\"\").forEach(char => set.add(char));\n    return set;\n  }, new Set<string>());\n  const replacements = [...invalidCharacters].map(char => ({ char, code: char.charCodeAt(0) }));\n  return replacements.reduce((modified, { char, code }) => replaceAll(modified, char, wrap(code)), `${query}`);\n}\n\nexport const decode = (query: string): string => {\n  const matches = [...query.matchAll(guardsRegEx)];\n  const replacements = matches.reduce((replacements, match) => {\n    const [key, code] = match;\n    return replacements.set(key, String.fromCharCode(code as any as number));\n  }, new Map());\n  return [...replacements].reduce((modified, [current, desired]) => replaceAll(modified, current, desired), `${query}`);\n}","import { BaseExtension, Block, ExtensionBlockMetadata, ExtensionMetadata, ExtensionMenuItems, DynamicMenu, DynamicMenuThatAcceptsReporters, MenuItem, MenuThatAcceptsReporters, TypeByArgumentType, ValueOf, VerboseArgument, Argument } from \"./types\";\nimport { ArgumentType } from \"./enums\";\nimport { isFunction, isPrimitive, isString } from \"./utils\";\n\nexport type SerializedBlockData = Pick<ExtensionMetadata, \"blocks\" | \"menus\">;\n\nexport const mockFormatMessage = (args: { id: string, default: string, description: string }): string => \"\";\n\ntype Opcodes<T extends SerializedBlockData> = { [k in keyof T[\"blocks\"]]: T[\"blocks\"][k] extends ExtensionBlockMetadata ? T[\"blocks\"][k][\"opcode\"] : never }[number];\n\ntype Arguments<A extends ExtensionMetadata[\"blocks\"], Opcode extends string> = {\n  [E in keyof A as A[E] extends { opcode: infer K extends Opcode } ? K : never]: A[E] extends ExtensionBlockMetadata ? A[E]['arguments'] : never;\n};\n\ntype Type<A extends ExtensionMetadata[\"blocks\"], Opcode extends string> = {\n  [E in keyof A as A[E] extends { opcode: infer K extends Opcode } ? K : never]: A[E] extends ExtensionBlockMetadata ? A[E]['blockType'] : never;\n}\n\ntype MappedToBlockDefinition<T extends SerializedBlockData> = { [k in Opcodes<T>]:\n  {\n    type: Type<T[\"blocks\"], k>[keyof Type<T[\"blocks\"], k>],\n  } & (TsMagic.ObjValueTuple<Arguments<T[\"blocks\"], k>[keyof Arguments<T[\"blocks\"], k>]> extends { length: 0 }\n    ? {}\n    : TsMagic.ObjValueTuple<Arguments<T[\"blocks\"], k>[keyof Arguments<T[\"blocks\"], k>]> extends { length: 1 }\n    ? { arg: MapToArgument<TsMagic.ObjValueTuple<Arguments<T[\"blocks\"], k>[keyof Arguments<T[\"blocks\"], k>]>>[0], }\n    : { args: MapToArgument<TsMagic.ObjValueTuple<Arguments<T[\"blocks\"], k>[keyof Arguments<T[\"blocks\"], k>]>>, })\n};\n\ntype WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] }\n\ntype MapToArgument<T extends unknown[]> = T extends [] ? [] :\n  T extends [infer H, ...infer R] ?\n  H extends { type: infer X extends ValueOf<typeof ArgumentType> }\n  ? H extends { menu: string }\n  ? [WithRequired<VerboseArgument<TypeByArgumentType<X>>, \"options\">, ...MapToArgument<R>]\n  : [VerboseArgument<TypeByArgumentType<X>>, ...MapToArgument<R>]\n  : MapToArgument<R> : T\n\ntype WithName = { name: string };\n\nconst processArg = (arg: VerboseArgument<any> & WithName, argName: string, menuName: string, menus: ExtensionMetadata[\"menus\"], blockName: string) => {\n  arg.name = argName;\n  if (!menuName) return;\n\n  (arg.options as WithName).name = menuName;\n  const menuEntry = menus[menuName];\n  if (!menuEntry) return;\n\n  const legacyAcceptReporters = (menuEntry as ExtensionMenuItems).acceptReporters;\n  const updatedAcceptReporters = (arg.options as MenuThatAcceptsReporters<any>).acceptsReporters ?? false;\n  if (legacyAcceptReporters !== updatedAcceptReporters) {\n    throw new Error(`The new options provided for the legacy block '${blockName}' for legacy argument '${argName}' ${legacyAcceptReporters ? \"should\" : \"should NOT\"} accept reporters`);\n  }\n\n  const oldItems = (menuEntry as ExtensionMenuItems).items as MenuItem<any>[];\n  if (!oldItems || oldItems.length === 0) return;\n\n  const newItems: MenuItem<any>[] = Array.isArray(arg.options)\n    ? (arg.options as MenuItem<any>[])\n    : isFunction(arg.options)\n      ? (arg.options as DynamicMenu<any>)()\n      : (arg.options as MenuThatAcceptsReporters<any>).items\n        ? (arg.options as MenuThatAcceptsReporters<any>).items\n        : (arg.options as DynamicMenuThatAcceptsReporters<any>).getItems();\n\n  const expand = (item: MenuItem<any>) => isPrimitive(item) ? ({ text: `${item}`, value: item }) : item as { value: any; text: string; };\n  const serialize = (item: any) => JSON.stringify(item);\n\n  const oldItemsExpanded = oldItems.map(expand).map(serialize);\n  const newItemsExpand = newItems.map(expand).map(serialize);\n\n  for (const oldItem of oldItemsExpanded) {\n    if (!newItemsExpand.includes(oldItem)) {\n      throw new Error(`Mismatch in old and new menus for block ${blockName}: arg ${argName}. Old entry: ${oldItem}, new entries: [${newItemsExpand.join(\", \")}]`)\n    }\n  }\n}\n\nconst attachNames = <T extends SerializedBlockData, TKey extends Opcodes<T>, TBlock>(\n  name: TKey,\n  block: TBlock & MappedToBlockDefinition<T>[TKey],\n  legacyBlock: ExtensionBlockMetadata,\n  menus: ExtensionMetadata[\"menus\"]\n): TBlock => {\n  type AnyBlock = Block<BaseExtension, ((...args: any[]) => any) | ((arg: any) => any) | (() => any)>;\n  const asBlock = block as any as AnyBlock;\n  (block as any as WithName).name = name;\n\n  if (\"arg\" in asBlock) {\n    const [key, { menu }] = Object.entries(legacyBlock.arguments)[0];\n    processArg(asBlock.arg, key, menu, menus, name);\n  }\n  else if (\"args\" in asBlock) {\n    const entries = Object.entries(legacyBlock.arguments);\n    for (let index = 0; index < entries.length; index++) {\n      const [key, { menu }] = entries[index];\n      processArg(asBlock.args[index], key, menu, menus, name);\n    }\n  }\n\n  return block;\n}\n\ntype LegacySupport<T extends SerializedBlockData> =\n  { [k in Opcodes<T>]: <TBlock extends MappedToBlockDefinition<T>[k]>(block: TBlock) => TBlock }\n  & { tsIgnore: { [k in Opcodes<T>]: <TBlock>(block: TBlock) => TBlock } }\n  & { legacyBlocksForTests: { [k in Opcodes<T>]: ExtensionBlockMetadata } }\n\n/**\n * \n * @param data The object returned by a vanilla-javascript extension's `getInfo` method\n * @returns An object where the keys are the 'opcodes' of the blocks provided as an argument this function. \n * The value for each key is a function that, when applied to a block definition, \n * adds the necessary legacy support so old projects will load correctly. \n */\nexport const extractLegacySupportFromOldGetInfo = <T extends SerializedBlockData>(data: T): LegacySupport<T> => {\n  const { blocks, menus } = data;\n\n  const mapper: LegacySupport<T> = ((blocks as ExtensionBlockMetadata[]).filter(block => !isString(block)) as ExtensionBlockMetadata[])\n    .map(block => {\n      const opcode = block.opcode as Opcodes<T>;\n      return [opcode, (b) => attachNames<T, typeof opcode, typeof b>(block.opcode as Opcodes<T>, b, block, menus)];\n    })\n    .reduce((acc, [key, func]) => {\n      acc[key] = func;\n      return acc;\n    }, {} as any);\n\n  mapper[\"tsIgnore\"] = mapper as any as LegacySupport<T>[\"tsIgnore\"];\n\n  mapper.legacyBlocksForTests = (blocks as ExtensionBlockMetadata[]).reduce((acc, block) => {\n    acc[block.opcode] = block;\n    return acc;\n  }, {} as LegacySupport<T>[\"legacyBlocksForTests\"]);\n\n  return mapper;\n};\n\n/**\n * As is made very clear in the stack overflow from which this code is taken, \n * THIS IS AN ABUSE OF TYPESCRIPT:\n * https://stackoverflow.com/questions/55127004/how-to-transform-union-type-to-tuple-type/55128956#55128956\n * https://stackoverflow.com/questions/52855145/typescript-object-type-to-array-type-tuple\n */\nnamespace TsMagic {\n  export type UnionToIntersection<U> =\n    (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never\n  type LastOf<T> =\n    UnionToIntersection<T extends any ? () => T : never> extends () => (infer R) ? R : never\n\n  export type Push<T extends any[], V> = [...T, V];\n\n  export type TuplifyUnion<T, L = LastOf<T>, N = [T] extends [never] ? true : false> =\n    true extends N ? [] : Push<TuplifyUnion<Exclude<T, L>>, L>\n\n  export type ObjValueTuple<T, KS extends any[] = TuplifyUnion<keyof T>, R extends any[] = []> =\n    KS extends [infer K, ...infer KT]\n    ? ObjValueTuple<T, KT, [...R, T[K & keyof T]]>\n    : R\n}\n\n","import type BlockUtility from \"$scratch-vm/engine/block-utility\";\nimport { TypedMethodDecorator } from \".\";\nimport { BlockMetadata, DecoratedExtension } from \"$common/extension/Extension\";\nimport { getImplementationName } from \"$common/extension/mixins/scratchInfo\";\nimport { BlockType } from \"$common/enums\";\n\ntype BlockFromArgsAndReturn<Args extends any[], Return> = Args extends [...infer R extends any[], BlockUtility]\n  ? BlockMetadata<(...args: R) => Return> : BlockMetadata<(...args: Args) => Return>;\n\nexport function block<\n  This extends DecoratedExtension,\n  const Args extends any[],\n  const Return,\n  const Fn extends (...args: Args) => Return,\n  BlockFunction extends BlockMetadata<Fn>\n>\n  (blockInfoOrGetter: BlockFunction | ((this: This, self: This) => BlockFunction)): TypedMethodDecorator<This, Args, Return, (...args: Args) => Return> {\n\n  return function (this: This, target: (this: This, ...args: Args) => Return, context: ClassMethodDecoratorContext<This, Fn>) {\n    const opcode = target.name;\n    const internalFuncName = getImplementationName(opcode);\n    context.addInitializer(function () { this.pushBlock(opcode, blockInfoOrGetter, target) });\n    return (function () { return this[internalFuncName].call(this, ...arguments) }) as Function as Fn;\n  };\n}\n\nexport function buttonBlock<\n  This extends DecoratedExtension,\n>(text: string): TypedMethodDecorator<This, [], void, () => void> {\n  type Args = [] | [BlockUtility];\n  type Return = void;\n  type Fn = (...args: Args) => Return;\n\n  return block<This, Args, Return, Fn, BlockFromArgsAndReturn<Args, Return>>({\n    text,\n    type: BlockType.Button\n  });\n}","import { ExtensionMenuDisplayDetails } from \"$common/types\";\nimport { DecoratedExtension } from \"$common/extension/Extension\";\nimport { TypedClassDecorator } from \".\";\n\nconst registerDetailsIdentifier = \"__registerMenuDetials\";\n\nexport function extension<T extends DecoratedExtension, Args extends any[]>(details: ExtensionMenuDisplayDetails): TypedClassDecorator<T, Args> {\n  return (value) => {\n    const isNode = typeof window === 'undefined';\n    if (isNode) global?.[registerDetailsIdentifier]?.(details);\n  }\n}\n\nexport const registerExtensionDefinitionCallback = (callback: (details: ExtensionMenuDisplayDetails) => void) =>\n  global[registerDetailsIdentifier] = (details) => {\n    callback(details);\n    delete global[registerDetailsIdentifier];\n  };","import { TypedClassDecorator, TypedMethodDecorator } from \".\";\nimport { AbstractConstructor, DecoratedExtension, Extension, ExtensionCommon, NonAbstractConstructor } from \"$common/extension/Extension\";\nimport legacySupport from \"$common/extension/mixins/legacySupport\";\nimport { ArgumentType, BlockType } from \"$common/enums\";\nimport { ExtensionMetadata, ExtensionBlockMetadata, ValueOf, TypeByArgumentType, ExtensionMenuItems, ExtensionMenuDisplayDetails, Block, ReturnTypeByBlockType, BlockOperation, Argument, ExtensionMenuMetadata, ExtensionDynamicMenu, Menu, MenuThatAcceptsReporters, DynamicMenuThatAcceptsReporters, BaseExtension } from \"$common/types\";\nimport { BlockMetadata } from \"$common/extension/Extension\";\nimport BlockUtility from \"$root/packages/scratch-vm/src/engine/block-utility\";\nimport { isString } from \"$common/utils\";\nimport { block } from \"./blocks\";\n\ntype LegacyExtension<TData extends ExtensionMetadata, TStrict extends boolean> = ExtensionCommon\n  & (\n    (DecoratedExtension & (TStrict extends true ? LegacyProbe.LegacyMethods<TData> : {})) |\n    Extension<ExtensionMenuDisplayDetails, (TStrict extends true ? LegacyProbe.LegacyMethods<TData> : {})> & { [k in LegacyProbe.Opcodes<TData>]?: void }\n  )\n  & { [k in LegacyProbe.ReservedMenuNames<TData>]?: void };\n\ntype LegacyExtensionDecorator<TExtension extends LegacyExtension<ExtensionMetadata, boolean>> = TypedClassDecorator<TExtension, ConstructorParameters<typeof ExtensionCommon>>;\n\ntype ArgumentMethods<TData extends ExtensionMetadata, K extends keyof LegacyProbe.LegacyMethods<TData>> = {\n  /**\n   * An object containing the required methods for each argument of a legacy block. \n   * A method will be required for an argument of a legacy block if:\n   * - It accepts reporters (which will require implementing a `handler` function)\n   * - it uses a dynamic menu (which will require implementing a `getItems` function)\n   * \n   * The keys of this object refer to the argument index of the arguments that require methods.\n   * In other words, if the first argument (aka index 0) of a legacy block accepts reporters and thus requires a `handler` method, \n   * then this object will look like the following:\n   * ```ts\n   * argumentMethods: {\n   *    0: { handler: (x: any) => {...} }\n   * }\n   * ```\n   */\n  argumentMethods: TsMagic.TupleToObject<LegacyProbe.OpArgMenus<TData, K>, \"argumentIndex\", \"reservedDynamicMenuName\">\n}\n\ntype BlockDefinitions<TInfo extends ExtensionMetadata, TExtension extends ExtensionCommon> = {\n  [k in keyof LegacyProbe.LegacyMethods<TInfo>]: <TReturn extends LegacyProbe.OpReturn<TInfo, k>>(inputs: {\n    operation: (this: TExtension, ...args: [...Parameters<LegacyProbe.LegacyMethods<TInfo>[k]>, BlockUtility]) => TReturn,\n  } & ArgumentMethods<TInfo, k>\n  ) => Block<BaseExtension, (...args: Parameters<LegacyProbe.LegacyMethods<TInfo>[k]>) => TReturn> & { type: LegacyProbe.BlockType<TInfo, k> }\n};\n\ntype BlockDecorators<TInfo extends ExtensionMetadata> = {\n  [k in keyof LegacyProbe.LegacyMethods<TInfo>]:\n  <This extends DecoratedExtension, Args extends Parameters<LegacyProbe.LegacyMethods<TInfo>[k]>, Return extends any>(\n    ...args: LegacyProbe.OpArgMenus<TInfo, k> extends [] ? [] : [ArgumentMethods<TInfo, k>]\n  ) => TypedMethodDecorator<This, Args, Return, (...args: Args) => Return>\n}\n\ntype LegacySupport<TInfo extends ExtensionMetadata, TStrict extends boolean> = {\n  /**\n   * The for\n   * @returns \n   */\n  for: <TExtension extends LegacyExtension<TInfo, TStrict>>() => {\n    /**\n     * The decorator\n     */\n    legacyExtension(): TypedClassDecorator<TExtension, ConstructorParameters<typeof ExtensionCommon>>,\n    /**\n     * \n     */\n    legacyDefinition: BlockDefinitions<TInfo, TExtension>,\n    /**\n     * \n     */\n    legacyBlock: BlockDecorators<TInfo>,\n    /**\n     * \n     */\n    ReservedNames: {\n      Menus: TsMagic.TuplifyUnion<LegacyProbe.ReservedMenuNames<TInfo>>,\n      Blocks: TsMagic.TuplifyUnion<LegacyProbe.Opcodes<TInfo>>\n    },\n  }\n}\n\n/**\n * \n * @param info \n * @param flags \n * @returns \n */\nexport const legacy = <\n  const TInfo extends ExtensionMetadata,\n  TFlags extends { incrementalDevelopment: boolean } = undefined,\n  const TStrict extends boolean = TFlags extends { incrementalDevelopment: false } | undefined ? true : false\n>(info: TInfo, flags?: TFlags): LegacySupport<TInfo, TStrict> => ({\n\n  for<TExtension extends LegacyExtension<TInfo, TStrict>>() {\n\n    const legacyExtension = (): LegacyExtensionDecorator<TExtension> => (value, context) => {\n      abstract class LegacySupport extends legacySupport(value as AbstractConstructor<ExtensionCommon>, info) {\n        readonly originalClassName = context.name;\n      };\n\n      return LegacySupport as AbstractConstructor<ExtensionCommon> as NonAbstractConstructor<TExtension>\n    };\n\n    const blockMetaData = getBlockMetaData(info);\n\n    const legacyDefinition = blockMetaData.reduce((acc, [opcode, block]) => {\n      const key = opcode as keyof BlockDefinitions<TInfo, TExtension>;\n\n      acc[key] = ({ operation, argumentMethods }) => {\n        if (argumentMethods) attachArgumentMethods(block, argumentMethods);\n        return { ...block, operation } as any;\n      };\n\n      return acc;\n    }, {} as BlockDefinitions<TInfo, TExtension>);\n\n    const legacyBlock = blockMetaData.reduce((acc, [opcode, metadata]) => {\n      const key = opcode as keyof BlockDefinitions<TInfo, TExtension>;\n\n      acc[key] = (({ argumentMethods }) => {\n        if (argumentMethods) attachArgumentMethods(metadata, argumentMethods);\n        return block(metadata as any);\n      }) as any;\n\n      return acc;\n    }, {} as BlockDecorators<TInfo>);\n\n    return {\n      legacyExtension, legacyDefinition, legacyBlock,\n      ReservedNames: {\n        get Menus(): any { throw new Error(\"This property is not meant to be accessed, and is instead solely for documentation purposes.\") },\n        get Blocks(): any { throw new Error(\"This property is not meant to be accessed, and is instead solely for documentation purposes.\") }\n      }\n    };\n  }\n})\n\nconst attachArgumentMethods = (\n  block: ReturnType<BlockMap[\"get\"]>,\n  argumentMethods: Record<number, Partial<DynamicMenuThatAcceptsReporters<unknown>>>\n) => {\n  const args = block.args ? block.args : block.arg ? [block.arg] : [];\n\n  Object.entries(argumentMethods).forEach(([indexKey, { handler, getItems }]) => {\n    const arg = args[parseInt(indexKey)];\n    tryUpdateKey(arg, \"handler\", handler);\n    tryUpdateKey(arg, \"getItems\", getItems);\n  });\n}\n\nconst tryUpdateKey = <T>(obj, key: string, value: T) => {\n  // more checks?\n  obj[key] = value;\n}\n\nconst asBlockMetaData = (block: ExtensionBlockMetadata | string) => {\n  if (isString(block)) throw new Error(`Block defined as string, unexpected! ${block}`)\n  return block as ExtensionBlockMetadata;\n}\n\ntype BlockMap = Map<string, BlockMetadata<BlockOperation>>;\n\nconst convertAndInsertBlock = (map: BlockMap, block: ExtensionBlockMetadata, metadata: ExtensionMetadata) => {\n  const { opcode, arguments: _arguments, blockType: type } = block;\n  const { text, orderedNames } = parseText(block);\n\n  const args = Object.entries(_arguments)\n    .map(([name, { menu, ...rest }]) => ({ options: extractMenuOptions(metadata, menu), name, menu, ...rest }))\n    .sort(({ name: a }, { name: b }) => orderedNames.indexOf(a) < orderedNames.indexOf(b) ? -1 : 1)\n    .map(({ name, ...details }) => details satisfies Argument<any> as Argument<unknown>);\n\n  const { length } = args;\n  const argsEntry = length >= 2 ? { args: args as [Argument<unknown>] } : length === 1 ? { arg: args[0] } : {};\n\n  return map.set(opcode, { type, text, ...argsEntry });\n}\n\nconst getBlockMetaData = (metadata: ExtensionMetadata) => Array.from(\n  metadata.blocks\n    .map(asBlockMetaData)\n    .reduce((map, block) => convertAndInsertBlock(map, block, metadata), new Map() as BlockMap)\n    .entries()\n);\n\nexport const parseText = ({ arguments: _arguments, text }: ExtensionBlockMetadata) => {\n  const args = Object.keys(_arguments)\n    .map(name => ({ name, template: `[${name}]` }))\n    .sort(({ template: a }, { template: b }) => text.indexOf(a) < text.indexOf(b) ? -1 : 1);\n\n  const placeholder = \"Error: This should have been overridden by legacy support\";\n\n  return args.length === 0\n    ? { orderedNames: null as null, text: placeholder }\n    : { orderedNames: args.map(({ name }) => name), text: () => placeholder }\n}\n\nconst getItemsPlaceholder = { getItems: () => (\"Error: This should have been filled in.\" as any) };\nconst handlerPlaceholder = { handler: () => (\"Error: This should have been filled in.\" as any) };\nconst isDynamicMenu = (menu: ExtensionMenuMetadata | ExtensionMenuItems[\"items\"]): menu is ExtensionDynamicMenu => isString(menu);\n\nconst extractMenuOptions = (data: ExtensionMetadata, menuName: string): Menu<any> => {\n  const menu = menuName ? data.menus[menuName] : undefined;\n\n  if (!menu) return undefined;\n  if (isDynamicMenu(menu)) return getItemsPlaceholder.getItems;\n\n  const { items, acceptReporters: acceptsReporters } = menu;\n\n  if (!isDynamicMenu(items)) return acceptsReporters ? { acceptsReporters, items: [...items], ...handlerPlaceholder } : [...items];\n\n  return acceptsReporters ? { acceptsReporters, ...handlerPlaceholder, ...getItemsPlaceholder } : getItemsPlaceholder.getItems;\n}\n\n/**\n * Types to assist in extracting information from the return type of the old 'getInfo' method\n */\nexport namespace LegacyProbe {\n  export type Blocks = ExtensionMetadata[\"blocks\"];\n  export type Block = ExtensionMetadata[\"blocks\"];\n\n  export type Arguments<A extends ExtensionMetadata[\"blocks\"], Opcode extends string> = {\n    [E in keyof A as A[E] extends { opcode: infer K extends Opcode } ? K : never]: A[E] extends ExtensionBlockMetadata ? A[E]['arguments'] : never;\n  };\n\n  export type Types<A extends ExtensionMetadata[\"blocks\"], Opcode extends string> = {\n    [E in keyof A as A[E] extends { opcode: infer K extends Opcode } ? K : never]: A[E] extends ExtensionBlockMetadata ? A[E]['blockType'] : never;\n  }\n\n  export type Opcodes<T extends ExtensionMetadata> = { [k in keyof T[\"blocks\"]]: T[\"blocks\"][k] extends ExtensionBlockMetadata ? T[\"blocks\"][k][\"opcode\"] : never }[number];\n\n  export type OpArgs<T extends ExtensionMetadata, K extends Opcodes<T>> = ArgsArray<TsMagic.ObjValueTuple<Arguments<T[\"blocks\"], K>[keyof Arguments<T[\"blocks\"], K>]>>;\n  export type OpArgMenus<T extends ExtensionMetadata, K extends Opcodes<T>> = ArgsToMenusArray<TsMagic.ObjValueTuple<Arguments<T[\"blocks\"], K>[keyof Arguments<T[\"blocks\"], K>]>, T>;\n\n  export type BlockType<T extends ExtensionMetadata, K extends Opcodes<T>> = Types<T[\"blocks\"], K>[keyof Types<T[\"blocks\"], K>] extends ValueOf<typeof BlockType> ? Types<T[\"blocks\"], K>[keyof Types<T[\"blocks\"], K>] : never;\n  export type OpReturn<T extends ExtensionMetadata, K extends Opcodes<T>, TBlockType extends BlockType<T, K> = BlockType<T, K>> = ReturnTypeByBlockType<TBlockType>;\n\n  export type ReservedMenuNames<T extends ExtensionMetadata> = ValueOf<{\n    [Op in Opcodes<T>]: ValueOf<{\n      [Arg in OpArgMenus<T, Op>[number]as Arg[\"argumentIndex\"]]: Arg extends { reservedDynamicMenuName: infer Name extends string } ? Name : never;\n    }>\n  }> & string;\n\n  type ArgsArray<T extends unknown[]> = T extends [] ? [] :\n    T extends [infer H, ...infer R]\n    ? H extends { type: infer X extends ValueOf<typeof ArgumentType> }\n    ? [TypeByArgumentType<X>, ...ArgsArray<R>]\n    : ArgsArray<R>\n    : T\n\n  type ConditionalHandler<AcceptsReporters extends boolean, ArgumentType extends ValueOf<typeof ArgumentType>> = AcceptsReporters extends true\n    ? { handler: MenuThatAcceptsReporters<TypeByArgumentType<ArgumentType>>[\"handler\"] }\n    : {};\n\n  /**\n   * Fields of elements in returned tuple:\n   * - argumentIndex: an index value (number) that corresponds to the index of Item within T (see below)\n   * - reservedDynamicMenuName: the name of a dynamic menu method\n   * - getItems: a function that returns menu items (i.e. a dynamic menu)\n   * - handler: an function used to validate the inputs of fields that accept reporters\n   */\n  type ArgsToMenusArray<T extends unknown[], TData extends ExtensionMetadata> = T extends []\n    ? []\n    // If T is a Variadic Tuple Type, extract the types of the elements before the final element (Rest) and type of final element (Item)\n    : T extends [...infer Rest, infer Item]\n    // If the final item matches the shape of an argument, extract the types of the menu field (MenuName) and it's argument type (Type)\n    ? Item extends { menu: infer MenuName extends keyof TData[\"menus\"], type: infer Type extends ValueOf<typeof ArgumentType> }\n    // If the menu (accessed by indexing the 'menus' object with MenuName) is a string value, the menu must be dynamic\n    ? TData[\"menus\"][MenuName] extends string\n    // Return a tuple where the last element is Item mapped to an object with 'argumentIndex' and 'getOptions' + 'reservedDynamicMenuName' fields (described above)\n    ? [\n      ...ArgsToMenusArray<Rest, TData>,\n      { reservedDynamicMenuName: MenuName, getItems: DynamicMenuThatAcceptsReporters<TypeByArgumentType<Type>>[\"getItems\"], } &\n      { argumentIndex: Rest[\"length\"] }\n    ]\n    // If the menu matches the shape of a verbose menu (i.e. defines 'acceptReporters') extract the value of 'acceptReporters'\n    : TData[\"menus\"][MenuName] extends { acceptReporters: infer Accepts extends boolean }\n    // If the verbose menu's 'items' field is a string value, it must be a dynamic menu\n    ? TData[\"menus\"][MenuName] extends { items: infer DynamicMenuName extends string }\n    // Return a tuple where the last element Item is mapped to an object with 'argumentIndex' 'getOptions' + 'reservedDynamicMenuName', and potentially 'handler' fields (described above)\n    ? [\n      ...ArgsToMenusArray<Rest, TData>,\n      { reservedDynamicMenuName: DynamicMenuName, getItems: DynamicMenuThatAcceptsReporters<TypeByArgumentType<Type>>[\"getItems\"], } &\n      ConditionalHandler<Accepts, Type> &\n      { argumentIndex: Rest[\"length\"] }\n    ]\n    // If the menu does accept reporters (and by this point, we know the menu is NOT dynamic)\n    : Accepts extends true\n    // Return a tuple where the last element is Item mapped to an object with 'argumentIndex' and 'handler' fields (described above)\n    ? [...ArgsToMenusArray<Rest, TData>, ConditionalHandler<Accepts, Type> & { argumentIndex: Rest[\"length\"] }]\n    // Exclude Item from returned (e.g. argument didn't have a menu, or menu was static and didn't accept reporters)\n    : ArgsToMenusArray<Rest, TData>\n    // Exclude Item from returned (e.g. argument didn't have a menu, or menu was static and didn't accept reporters)\n    : ArgsToMenusArray<Rest, TData>\n    // Exclude Item from returned (e.g. argument didn't have a menu, or menu was static and didn't accept reporters)\n    : ArgsToMenusArray<Rest, TData>\n    // <Base case> (reached when T doesn't match a Variadic Tuple Type)\n    : T;\n\n  export type LegacyMethods<T extends ExtensionMetadata> = { [k in Opcodes<T>]: (...args: OpArgs<T, k>) => OpReturn<T, k> };\n\n  export type Menus = ExtensionMetadata[\"menus\"];\n  export type Items = ExtensionMenuItems[\"items\"];\n}\n\n/**\n * As is made very clear in the stack overflow from which this code is taken, \n * THIS IS AN ABUSE OF TYPESCRIPT:\n * https://stackoverflow.com/questions/55127004/how-to-transform-union-type-to-tuple-type/55128956#55128956\n * https://stackoverflow.com/questions/52855145/typescript-object-type-to-array-type-tuple\n */\nnamespace TsMagic {\n  export type UnionToIntersection<U> =\n    (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never\n  type LastOf<T> =\n    UnionToIntersection<T extends any ? () => T : never> extends () => (infer R) ? R : never\n\n  export type Push<T extends any[], V> = [...T, V];\n\n  export type TuplifyUnion<T, L = LastOf<T>, N = [T] extends [never] ? true : false> =\n    true extends N ? [] : Push<TuplifyUnion<Exclude<T, L>>, L>\n\n  export type ObjValueTuple<T, KS extends any[] = TuplifyUnion<keyof T>, R extends any[] = []> =\n    KS extends [infer K, ...infer KT]\n    ? ObjValueTuple<T, KT, [...R, T[K & keyof T]]>\n    : R;\n\n  export type TupleToObject<T extends any[], TKey extends string | number | symbol, TExclude extends string = undefined> = {\n    [K in T[number]as K[TKey]]: TExclude extends undefined ? Omit<K, TKey> : Omit<K, TKey | TExclude>;\n  }\n}\n","import { AbstractConstructor, ExtensionCommon } from \"$common/extension/Extension\";\nimport { ExtensionBlockMetadata, ExtensionMetadata } from \"$common/types\";\nimport { isString } from \"$common/utils\";\nimport { parseText } from \"../decorators/legacy\";\nimport { getImplementationName, wrapOperation } from \"./scratchInfo\";\n\ntype WrappedOperation = ReturnType<typeof wrapOperation>;\ntype WrappedOperationParams = Parameters<WrappedOperation>;\n\nexport default function <T extends AbstractConstructor<ExtensionCommon>>(Ctor: T, legacyInfo: ExtensionMetadata) {\n  abstract class _ extends Ctor {\n    private validatedInfo: ExtensionMetadata;\n\n    protected getInfo(): ExtensionMetadata {\n\n      if (!this.validatedInfo) {\n        // @ts-ignore\n        const { getInfo } = ExtensionCommon.prototype;\n        const info = (getInfo.call(this));\n        this.validatedInfo = this.validateAndAttach(info);\n      }\n\n      return this.validatedInfo;\n    }\n\n    private validateAndAttach({ id, blocks, menus, ...metaData }: ExtensionMetadata): ExtensionMetadata {\n      const { id: legacyID, blocks: legacyBlocks, menus: legacyMenus } = legacyInfo;\n      const mutableBlocks = [...blocks as ExtensionBlockMetadata[]];\n\n      if (id !== legacyID) throw new Error(`ID mismatch! Legacy id: ${legacyID} vs. current id: ${id}`);\n\n      const blockMap = mutableBlocks.reduce(\n        (map, { opcode, ...block }, index) => map.set(opcode, { ...block, index }),\n        new Map<string, Omit<ExtensionBlockMetadata, \"opcode\"> & { index: number }>()\n      );\n\n      const menusToAdd = new Array<string>();\n\n      for (const legacyBlock of legacyBlocks) {\n        if (isString(legacyBlock)) throw new Error(\"Block was unexpectedly a string: \" + legacyBlock);\n        const { opcode } = legacyBlock;\n        if (!blockMap.has(opcode)) throw new Error(`Could not find legacy opcode ${legacyBlock} within currently defined blocks`);\n\n        const { index } = blockMap.get(opcode);\n        mutableBlocks[index] = legacyBlock;\n\n        const { orderedNames } = parseText(legacyBlock);\n        const remapper = (args: Record<string, any>) => orderedNames.reduce((remap, current, index) => {\n          remap[`${index}`] = args[current];\n          return remap;\n        }, {})\n\n        const implementation = this[getImplementationName(opcode)] as ReturnType<typeof wrapOperation>;\n        this[opcode] = ((...[args, util]: WrappedOperationParams) => implementation.call(this, remapper(args), util)).bind(this);\n\n        menusToAdd.push(...Object.values(legacyBlock.arguments).map(({ menu }) => menu).filter(Boolean));\n      }\n\n      for (const menu of menusToAdd) {\n        if (menu in menus) throw new Error(`Menu '${menu}' has already been defined and risks being overwritten`);\n        menus[menu] = legacyMenus[menu];\n      }\n\n      return {\n        id, blocks: mutableBlocks, menus, ...metaData\n      };\n    }\n  }\n  return _\n}\n\n"],"names":["ExtensionFramework","exports","CustomArgumentManager","constructor","this","map","Map","pending","clearPending","setPending","update","add","entry","id","GetIdentifier","set","insert","request","tryResolve","getCurrentEntries","Array","from","entries","filter","_","text","getEntry","get","requiresSave","size","saveTo","obj","length","SaveKey","loadFrom","forEach","purgeStaleIDs","IsIdentifier","query","startsWith","IdentifierPrefix","Date","getTime","toString","saveDataKey","BlockType","Boolean","Button","Command","Conditional","Event","Hat","Loop","Reporter","ArgumentType","Angle","Color","Number","String","Matrix","Note","Image","Custom","StageLayering","BackgroundLayer","VideoLayer","PenLayer","SpriteLayer","LayerGroups","Language","Azeri","Bahasa_Indonesia","Cymraeg","Dansk","Deutsch","Eesti","English","Euskara","Gaeilge","Galego","Hrvatski","isiZulu","Italiano","Kiswahili","Magyar","Nederlands","Norsk_Nynorsk","Polski","Rapa_Nui","Suomi","Svenska","LanguageKeys","Object","keys","RGB_BLACK","r","g","b","RGB_WHITE","static","decimal","hex","substr","a","replace","m","result","exec","parseInt","rgb","decimalToHex","rgbToDecimal","hexToRgb","hsv","h","s","Math","max","min","v","i","floor","f","p","q","t","x","rgb0","rgb1","fraction1","fraction0","Cast","value","isNaN","n","toLowerCase","color","toRgbColorObject","substring","decimalToRgb","toNumber","val","trim","v1","v2","n1","n2","isWhiteSpace","NaN","s1","s2","Infinity","indexOf","LIST_INVALID","LIST_ALL","index","acceptAll","random","cast","castToType","argumentType","parseFloat","JSON","parse","toMatrix","Error","toFlag","matrixString","fill","split","reduce","matrix","flag","row","push","openUIEvent","registerButtonCallbackEvent","customArgumentFlag","customArgumentCheck","dropdownStateFlag","dropdownEntryFlag","initDropdownState","openDropdownState","closeDropdownState","openUI","runtime","details","emit","registerButtonCallback","buttonID","callback","on","CssVar","root","parts","join","primary","secondary","tertiary","transparent","light","ui","motion","red","sound","control","data","pen","error","extensions","drop","modalOverlay","white","whiteDim","whiteTransparent","blackTransparent","primaryTransparent","lightTansparent","highlight","async","untilObject","getter","delay","timeout","Promise","resolve","clearTimeout","setTimeout","isString","isFunction","prototype","call","Function","isPrimitive","identity","untilExternalScriptLoaded","url","scriptLoaded","reject","script","document","createElement","onload","onerror","src","body","appendChild","typesafeCall","fn","_this","args","getArgumentType","arg","type","getImplementationName","opcode","wrapOperation","context","operation","argsFromScratch","blockUtility","castedArguments","name","handler","param","customArgumentManager","extractArgs","block","argsKey","zipArgs","names","types","handlers","extractHandlers","getArgName","assertSameLength","collections","Set","isBlockGetter","format","identifier","description","convertMenuItemsToString","item","getButtonID","convertToDisplayText","validateText","isDynamicText","textFunc","argPlaceholders","convertToArgumentInfo","menus","fromEntries","element","defaultValue","options","setDefaultValue","setMenu","accumulation","getMenuName","undefined","getDefaultValue","menu","alreadyAddedIndex","menuIndex","addOptionsAndGetMenuName","argCount","hasHandler","menuProbe","isSimpleStatic","isArray","isSimpleDynamic","isStaticWithReporters","isDynamicWithReporters","asStaticMenu","items","acceptReporters","renderToDropdown","compononentConstructor","props","dropdownContainerClass","elements","getElementsByClassName","console","target","anchor","children","centerDropdownButton","container","style","margin","paddingLeft","paddingRight","textAlign","className","styleMod","assert","callingContext","DrowpdownOpen","DropdownClose","Init","ExtensionBase","internal_init","init","videoFeed","ioDevices","video","blockIconURI","applyAllMixins","base","scratchInfo","Ctor","blockMap","pushBlock","has","definition","getInfo","info","blocks","convertToInfo","collectMenus","blockType","arguments","bind","func","registerDynamicMenu","getItems","key","saveDataHandler","save","toSave","extensionIDs","argumentManager","saveData","hooks","onSave","load","saved","onLoad","customSaveData","makeCustomArgument","component","initial","acceptReportersHandler","stringify","acceptsReports","arr","processCustomArgumentHack","getComponent","extensionID","initialID","currentEntry","prevID","current","setEntry","setter","extension","customArgumentSupport","label","extensionsMap","ExtensionCommon","FORBIDDEN","super","getAlternativeOpcodeName","validRegEx","RegExp","invalidRegEx","guards","reverse","guardsRegEx","replaceAll","desired","processArg","argName","menuName","blockName","menuEntry","legacyAcceptReporters","acceptsReporters","oldItems","newItems","expand","serialize","oldItemsExpanded","newItemsExpand","oldItem","includes","blockInfoOrGetter","internalFuncName","addInitializer","registerDetailsIdentifier","attachArgumentMethods","argumentMethods","indexKey","tryUpdateKey","asBlockMetaData","getBlockMetaData","metadata","_arguments","orderedNames","parseText","rest","extractMenuOptions","sort","argsEntry","convertAndInsertBlock","template","placeholder","getItemsPlaceholder","handlerPlaceholder","isDynamicMenu","Branch","Exit","Enter","First","Second","Third","Fourth","Fifth","Sixth","Seventh","DecoratedExtension","version","Extension","defineBlocks","self","validOpcode","FrameworkID","RuntimeEvent","ScriptGlowOn","ScriptGlowOff","BlockGlowOn","BlockGlowOff","HasCloudDataUpdate","TurboModeOn","TurboModeOff","RecordingOn","RecordingOff","ProjectStart","ProjectRunStart","ProjectRunStop","ProjectStopAll","StopForTarget","VisualReport","ProjectLoaded","ProjectChanged","ToolboxExtensionsNeedUpdate","TargetsUpdate","MonitorsUpdate","BlockDragUpdate","BlockDragEnd","ExtensionAdded","ExtensionFieldAdded","PeripheralListUpdate","PeripheralConnected","PeripheralDisconnected","PeripheralRequestError","PeripheralConnectionLostError","PeripheralScanTimeout","MicListening","BlocksInfoUpdate","RuntimeStarted","RuntimeDisposed","BlocksNeedUpdate","SaveDataHandler","ScratchBlocksConstants","OutputShapeHexagonal","OutputShapeRound","OutputShapeSquare","TargetType","Sprite","Stage","VariableType","Scalar","List","BrooadcastMessage","activeClass","buttonBlock","copyTo","source","decode","matchAll","replacements","match","code","fromCharCode","modified","encode","char","charCodeAt","window","global","extractLegacySupportFromOldGetInfo","mapper","legacyBlock","asBlock","attachNames","acc","legacyBlocksForTests","fetchWithTimeout","resource","controller","AbortController","abort","response","fetch","signal","getTextFromMenuItem","getValueFromMenuItem","isValidID","test","legacy","flags","for","blockMetaData","legacyDefinition","legacyExtension","LegacySupport","legacyInfo","validatedInfo","validateAndAttach","metaData","legacyID","legacyBlocks","legacyMenus","mutableBlocks","menusToAdd","remapper","remap","implementation","util","values","legacySupport","originalClassName","ReservedNames","Menus","Blocks","loadExternalScript","onError","mockFormatMessage","px","numberOf","reactiveInvoke","extensionAssignment","funcName","reactiveSet","propertyName","registerExtensionDefinitionCallback","splitOnCapitals","tryCastToArgumentType","onFailure","untilCondition","condition","untilExternalGlobalVariableLoaded","globalVariableName","untilReady","ready","defineProperty"],"mappings":"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"}