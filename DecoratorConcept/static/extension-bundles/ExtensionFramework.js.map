{"version":3,"file":"ExtensionFramework.js","sources":["../../../../extensions/src/common/enums.ts","../../../scratch-vm/src/util/color.js","../../../scratch-vm/src/util/cast.js","../../../../extensions/src/common/globals.ts","../../../../extensions/src/common/ui.ts","../../../../extensions/src/common/utils.ts","../../../../extensions/src/common/customArguments/dropdownOverride.ts","../../../../extensions/src/common/customArguments/index.ts","../../../../extensions/src/common/customArguments/CustomArgumentManager.ts","../../../../extensions/src/common/Extension.ts","../../../../extensions/src/common/types.ts","../../../../extensions/src/common/IDs.ts","../../../../extensions/src/common/portHelper.ts","../../../../extensions/src/common/SavaDataHandler.ts"],"sourcesContent":["import { ValueOf } from \"./types\";\n\n/**\n * The different kind of blocks that an extension can define\n */\nexport const BlockType = {\n  /**\n   * Boolean reporter with hexagonal shape\n   */\n  Boolean: 'Boolean',\n\n  /**\n   * A button (not an actual block) for some special action, like making a variable\n   */\n  Button: 'button',\n\n  /**\n   * Command block\n   */\n  Command: 'command',\n\n  /**\n   * Specialized command block which may or may not run a child branch\n   * The thread continues with the next block whether or not a child branch ran.\n   */\n  Conditional: 'conditional',\n\n  /**\n   * Specialized hat block with no implementation function\n   * This stack only runs if the corresponding event is emitted by other code.\n   */\n  Event: 'event',\n\n  /**\n   * Hat block which conditionally starts a block stack\n   */\n  Hat: 'hat',\n\n  /**\n   * Specialized command block which may or may not run a child branch\n   * If a child branch runs, the thread evaluates the loop block again.\n   */\n  Loop: 'loop',\n\n  /**\n   * General reporter with numeric or string value\n   */\n  Reporter: 'reporter'\n} as const;\n\nexport const ArgumentType = {\n  /** Numeric value with angle picker. */\n  Angle: \"angle\",\n\n  /** Boolean value with hexagonal placeholder. */\n  Boolean: \"Boolean\",\n\n  /** Numeric value with color picker. */\n  Color: \"color\",\n\n  /** Numeric value with text field. */\n  Number: \"number\",\n\n  /** String value with text field. */\n  String: \"string\",\n\n  /** String value with matrix field. */\n  Matrix: \"matrix\",\n\n  /** MIDI note number with note picker (piano) field. */\n  Note: \"note\",\n\n  /** Inline image on block (as part of the label). */\n  Image: \"image\",\n\n  /** Type added by PRG to support custom arguments */\n  Custom: \"custom\"\n} as const;\n\n/**\n * Default types of Target supported by the VM\n * @enum {string} as const;\n */\nexport const TargetType = {\n  /**\n   * Rendered target which can move, change costumes, etc.\n   */\n  Sprite: 'sprite',\n\n  /**\n   * Rendered target which cannot move but can change backdrops\n   */\n  Stage: 'stage'\n} as const;\n\n/**\n * These constants are copied from scratch-blocks/core/constants.js\n * @TODO find a way to require() these straight from scratch-blocks... maybe make a scratch-blocks/dist/constants.js?\n * @readonly\n * @enum {int} as const;\n */\nexport const ScratchBlocksConstants = {\n  /**\n   * ENUM for output shape: hexagonal (booleans/predicates).\n   * @const\n   */\n  OutputShapeHexagonal: 1,\n\n  /**\n   * ENUM for output shape: rounded (numbers).\n   * @const\n   */\n  OutputShapeRound: 2,\n\n  /**\n   * ENUM for output shape: squared (any/all values; strings).\n   * @const\n   */\n  OutputShapeSquare: 3\n} as const;\n\nexport const StageLayering = {\n  BackgroundLayer: 'background',\n  VideoLayer: 'video',\n  PenLayer: 'pen',\n  SpriteLayer: 'sprite',\n} as const;\n\nexport const LayerGroups: readonly ValueOf<typeof StageLayering>[] = [\n  StageLayering.VideoLayer,\n  StageLayering.SpriteLayer,\n  StageLayering.BackgroundLayer,\n  StageLayering.PenLayer,\n] as const;\n\nexport const VariableType = {\n  /**\n   * Type representation for scalar variables.\n   * This is currently represented as ''\n   * for compatibility with blockly.\n   */\n  Scalar: '',\n  /**\n   * Type representation for list variables.\n   */\n  List: 'list',\n\n  BrooadcastMessage: 'broadcast_msg'\n} as const;\n\nexport const Branch = {\n  Exit: 0,\n  Enter: 1,\n  First: 1,\n  Second: 2,\n  Third: 3,\n  Fourth: 4,\n  Fifth: 5,\n  Sixth: 6,\n  Seventh: 7\n} as const;\n\nexport const Language = {\n  Аҧсшәа: 'ab',\n  العربية: 'ar',\n  አማርኛ: 'am',\n  Azeri: 'az',\n  Bahasa_Indonesia: 'id',\n  Беларуская: 'be',\n  Български: 'bg',\n  Català: 'ca',\n  Česky: 'cs',\n  Cymraeg: 'cy',\n  Dansk: 'da',\n  Deutsch: 'de',\n  Eesti: 'et',\n  Ελληνικά: 'el',\n  English: 'en',\n  Español: 'es',\n  Español_Latinoamericano: 'es-419',\n  Euskara: 'eu',\n  فارسی: 'fa',\n  Français: 'fr',\n  Gaeilge: 'ga',\n  Gàidhlig: 'gd',\n  Galego: 'gl',\n  한국어: 'ko',\n  עִבְרִית: 'he',\n  Hrvatski: 'hr',\n  isiZulu: 'zu',\n  Íslenska: 'is',\n  Italiano: 'it',\n  ქართული_ენა: 'ka',\n  Kiswahili: 'sw',\n  Kreyòl_ayisyen: 'ht',\n  کوردیی_ناوەندی: 'ckb',\n  Latviešu: 'lv',\n  Lietuvių: 'lt',\n  Magyar: 'hu',\n  Māori: 'mi',\n  Nederlands: 'nl',\n  日本語: 'ja',\n  にほんご: 'ja-Hira',\n  Norsk_Bokmål: 'nb',\n  Norsk_Nynorsk: 'nn',\n  Oʻzbekcha: 'uz',\n  ไทย: 'th',\n  ភាសាខ្មែរ: 'km',\n  Polski: 'pl',\n  Português: 'pt',\n  Português_Brasileiro: 'pt-br',\n  Rapa_Nui: 'rap',\n  Română: 'ro',\n  Русский: 'ru',\n  Српски: 'sr',\n  Slovenčina: 'sk',\n  Slovenščina: 'sl',\n  Suomi: 'fi',\n  Svenska: 'sv',\n  Tiếng_Việt: 'vi',\n  Türkçe: 'tr',\n  Українська: 'uk',\n  简体中文: 'zh-cn',\n  繁體中文: 'zh-tw'\n} as const;\n\nexport const LanguageKeys = Object.keys(Language);\n\nexport const RuntimeEvent = {\n  /**\n   * Event name for glowing a script.\n   */\n  ScriptGlowOn: 'SCRIPT_GLOW_ON',\n  /**\n   * Event name for unglowing a script.\n   */\n  ScriptGlowOff: 'SCRIPT_GLOW_OFF',\n  /**\n   * Event name for glowing a block.\n   */\n  BlockGlowOn: 'BLOCK_GLOW_ON',\n  /**\n   * Event name for unglowing a block.\n   */\n  BlockGlowOff: 'BLOCK_GLOW_OFF',\n  /**\n   * Event name for a cloud data update to this project.\n   */\n  HasCloudDataUpdate: 'HAS_CLOUD_DATA_UPDATE',\n  /**\n   * Event name for turning on turbo mode.\n   */\n  TurboModeOn: 'TURBO_MODE_ON',\n  /**\n   * Event name for turning off turbo mode.\n   */\n  TurboModeOff: 'TURBO_MODE_OFF',\n  /**\n   * Event name for turning on turbo mode.\n   */\n  RecordingOn: 'RECORDING_ON',\n  /**\n   * Event name for turning off turbo mode.\n   */\n  RecordingOff: 'RECORDING_OFF',\n  /**\n   * Event name when the project is started (threads may not necessarily be running).\n   */\n  ProjectStart: 'PROJECT_START',\n  /**\n   * Event name when threads start running.\n   * Used by the UI to indicate running status.\n   */\n  ProjectRunStart: 'PROJECT_RUN_START',\n  /**\n   * Event name when threads stop running\n   * Used by the UI to indicate not-running status.\n   */\n  ProjectRunStop: 'PROJECT_RUN_STOP',\n  /**\n   * Event name for project being stopped or restarted by the user.\n   * Used by blocks that need to reset state.\n   */\n  ProjectStopAll: 'PROJECT_STOP_ALL',\n  /**\n   * Event name for target being stopped by a stop for target call.\n   * Used by blocks that need to stop individual targets.\n   */\n  StopForTarget: 'STOP_FOR_TARGET',\n  /**\n   * Event name for visual value report.\n   */\n  VisualReport: 'VISUAL_REPORT',\n  /**\n   * Event name for project loaded report.\n   */\n  ProjectLoaded: 'PROJECT_LOADED',\n  /**\n   * Event name for report that a change was made that can be saved\n   */\n  ProjectChanged: 'PROJECT_CHANGED',\n  /**\n   * Event name for report that a change was made to an extension in the toolbox.\n   */\n  ToolboxExtensionsNeedUpdate: 'TOOLBOX_EXTENSIONS_NEED_UPDATE',\n  /**\n   * Event name for targets update report.\n   */\n  TargetsUpdate: 'TARGETS_UPDATE',\n  /**\n   * Event name for monitors update.\n   */\n  MonitorsUpdate: 'MONITORS_UPDATE',\n  /**\n   * Event name for block drag update.\n   */\n  BlockDragUpdate: 'BLOCK_DRAG_UPDATE',\n  /**\n   * Event name for block drag end.\n   */\n  BlockDragEnd: 'BLOCK_DRAG_END',\n  /**\n   * Event name for reporting that an extension was added.\n   */\n  ExtensionAdded: 'EXTENSION_ADDED',\n  /**\n   * Event name for reporting that an extension as asked for a custom field to be added\n   */\n  ExtensionFieldAdded: 'EXTENSION_FIELD_ADDED',\n  /**\n   * Event name for updating the available set of peripheral devices.\n   * This causes the peripheral connection modal to update a list of available peripherals.\n   */\n  PeripheralListUpdate: 'PERIPHERAL_LIST_UPDATE',\n  /**\n   * Event name for reporting that a peripheral has connected.\n   * This causes the status button in the blocks menu to indicate 'connected'.\n   */\n  PeripheralConnected: 'PERIPHERAL_CONNECTED',\n  /**\n   * Event name for reporting that a peripheral has been intentionally disconnected.\n   * This causes the status button in the blocks menu to indicate 'disconnected'.\n   */\n  PeripheralDisconnected: 'PERIPHERAL_DISCONNECTED',\n  /**\n   * Event name for reporting that a peripheral has encountered a request error.\n   * This causes the peripheral connection modal to switch to an error state.\n   */\n  PeripheralRequestError: 'PERIPHERAL_REQUEST_ERROR',\n  /**\n   * Event name for reporting that a peripheral connection has been lost.\n   * This causes a 'peripheral connection lost' error alert to display.\n   */\n  PeripheralConnectionLostError: 'PERIPHERAL_CONNECTION_LOST_ERROR',\n  /**\n   * Event name for reporting that a peripheral has not been discovered.\n   * This causes the peripheral connection modal to show a timeout state.\n   */\n  PeripheralScanTimeout: 'PERIPHERAL_SCAN_TIMEOUT',\n  /**\n   * Event name to indicate that the microphone is being used to stream audio.\n   */\n  MicListening: 'MIC_LISTENING',\n  /**\n   * Event name for reporting that blocksInfo was updated.\n   */\n  BlocksInfoUpdate: 'BLOCKSINFO_UPDATE',\n  /**\n   * Event name when the runtime tick loop has been started.\n   */\n  RuntimeStarted: 'RUNTIME_STARTED',\n  /**\n   * Event name when the runtime dispose has been called.\n   */\n  RuntimeDisposed: 'RUNTIME_DISPOSED',\n  /**\n   * Event name for reporting that a block was updated and needs to be rerendered.\n   */\n  BlocksNeedUpdate: 'BLOCKS_NEED_UPDATE',\n} as const;\n","class Color {\n    /**\n     * @typedef {object} RGBObject - An object representing a color in RGB format.\n     * @property {number} r - the red component, in the range [0, 255].\n     * @property {number} g - the green component, in the range [0, 255].\n     * @property {number} b - the blue component, in the range [0, 255].\n     */\n\n    /**\n     * @typedef {object} HSVObject - An object representing a color in HSV format.\n     * @property {number} h - hue, in the range [0-359).\n     * @property {number} s - saturation, in the range [0,1].\n     * @property {number} v - value, in the range [0,1].\n     */\n\n    /** @type {RGBObject} */\n    static get RGB_BLACK () {\n        return {r: 0, g: 0, b: 0};\n    }\n\n    /** @type {RGBObject} */\n    static get RGB_WHITE () {\n        return {r: 255, g: 255, b: 255};\n    }\n\n    /**\n     * Convert a Scratch decimal color to a hex string, #RRGGBB.\n     * @param {number} decimal RGB color as a decimal.\n     * @return {string} RGB color as #RRGGBB hex string.\n     */\n    static decimalToHex (decimal) {\n        if (decimal < 0) {\n            decimal += 0xFFFFFF + 1;\n        }\n        let hex = Number(decimal).toString(16);\n        hex = `#${'000000'.substr(0, 6 - hex.length)}${hex}`;\n        return hex;\n    }\n\n    /**\n     * Convert a Scratch decimal color to an RGB color object.\n     * @param {number} decimal RGB color as decimal.\n     * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     */\n    static decimalToRgb (decimal) {\n        const a = (decimal >> 24) & 0xFF;\n        const r = (decimal >> 16) & 0xFF;\n        const g = (decimal >> 8) & 0xFF;\n        const b = decimal & 0xFF;\n        return {r: r, g: g, b: b, a: a > 0 ? a : 255};\n    }\n\n    /**\n     * Convert a hex color (e.g., F00, #03F, #0033FF) to an RGB color object.\n     * CC-BY-SA Tim Down:\n     * https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb\n     * @param {!string} hex Hex representation of the color.\n     * @return {RGBObject} null on failure, or rgb: {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     */\n    static hexToRgb (hex) {\n        const shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n        hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);\n        const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n        return result ? {\n            r: parseInt(result[1], 16),\n            g: parseInt(result[2], 16),\n            b: parseInt(result[3], 16)\n        } : null;\n    }\n\n    /**\n     * Convert an RGB color object to a hex color.\n     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     * @return {!string} Hex representation of the color.\n     */\n    static rgbToHex (rgb) {\n        return Color.decimalToHex(Color.rgbToDecimal(rgb));\n    }\n\n    /**\n     * Convert an RGB color object to a Scratch decimal color.\n     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     * @return {!number} Number representing the color.\n     */\n    static rgbToDecimal (rgb) {\n        return (rgb.r << 16) + (rgb.g << 8) + rgb.b;\n    }\n\n    /**\n    * Convert a hex color (e.g., F00, #03F, #0033FF) to a decimal color number.\n    * @param {!string} hex Hex representation of the color.\n    * @return {!number} Number representing the color.\n    */\n    static hexToDecimal (hex) {\n        return Color.rgbToDecimal(Color.hexToRgb(hex));\n    }\n\n    /**\n     * Convert an HSV color to RGB format.\n     * @param {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}\n     * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     */\n    static hsvToRgb (hsv) {\n        let h = hsv.h % 360;\n        if (h < 0) h += 360;\n        const s = Math.max(0, Math.min(hsv.s, 1));\n        const v = Math.max(0, Math.min(hsv.v, 1));\n\n        const i = Math.floor(h / 60);\n        const f = (h / 60) - i;\n        const p = v * (1 - s);\n        const q = v * (1 - (s * f));\n        const t = v * (1 - (s * (1 - f)));\n\n        let r;\n        let g;\n        let b;\n\n        switch (i) {\n        default:\n        case 0:\n            r = v;\n            g = t;\n            b = p;\n            break;\n        case 1:\n            r = q;\n            g = v;\n            b = p;\n            break;\n        case 2:\n            r = p;\n            g = v;\n            b = t;\n            break;\n        case 3:\n            r = p;\n            g = q;\n            b = v;\n            break;\n        case 4:\n            r = t;\n            g = p;\n            b = v;\n            break;\n        case 5:\n            r = v;\n            g = p;\n            b = q;\n            break;\n        }\n\n        return {\n            r: Math.floor(r * 255),\n            g: Math.floor(g * 255),\n            b: Math.floor(b * 255)\n        };\n    }\n\n    /**\n     * Convert an RGB color to HSV format.\n     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     * @return {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}\n     */\n    static rgbToHsv (rgb) {\n        const r = rgb.r / 255;\n        const g = rgb.g / 255;\n        const b = rgb.b / 255;\n        const x = Math.min(Math.min(r, g), b);\n        const v = Math.max(Math.max(r, g), b);\n\n        // For grays, hue will be arbitrarily reported as zero. Otherwise, calculate\n        let h = 0;\n        let s = 0;\n        if (x !== v) {\n            const f = (r === x) ? g - b : ((g === x) ? b - r : r - g);\n            const i = (r === x) ? 3 : ((g === x) ? 5 : 1);\n            h = ((i - (f / (v - x))) * 60) % 360;\n            s = (v - x) / v;\n        }\n\n        return {h: h, s: s, v: v};\n    }\n\n    /**\n     * Linear interpolation between rgb0 and rgb1.\n     * @param {RGBObject} rgb0 - the color corresponding to fraction1 <= 0.\n     * @param {RGBObject} rgb1 - the color corresponding to fraction1 >= 1.\n     * @param {number} fraction1 - the interpolation parameter. If this is 0.5, for example, mix the two colors equally.\n     * @return {RGBObject} the interpolated color.\n     */\n    static mixRgb (rgb0, rgb1, fraction1) {\n        if (fraction1 <= 0) return rgb0;\n        if (fraction1 >= 1) return rgb1;\n        const fraction0 = 1 - fraction1;\n        return {\n            r: (fraction0 * rgb0.r) + (fraction1 * rgb1.r),\n            g: (fraction0 * rgb0.g) + (fraction1 * rgb1.g),\n            b: (fraction0 * rgb0.b) + (fraction1 * rgb1.b)\n        };\n    }\n}\n\nmodule.exports = Color;\n","const Color = require('../util/color');\n\n/**\n * @fileoverview\n * Utilities for casting and comparing Scratch data-types.\n * Scratch behaves slightly differently from JavaScript in many respects,\n * and these differences should be encapsulated below.\n * For example, in Scratch, add(1, join(\"hello\", world\")) -> 1.\n * This is because \"hello world\" is cast to 0.\n * In JavaScript, 1 + Number(\"hello\" + \"world\") would give you NaN.\n * Use when coercing a value before computation.\n */\n\nclass Cast {\n    /**\n     * Scratch cast to number.\n     * Treats NaN as 0.\n     * In Scratch 2.0, this is captured by `interp.numArg.`\n     * @param {*} value Value to cast to number.\n     * @return {number} The Scratch-casted number value.\n     */\n    static toNumber (value) {\n        // If value is already a number we don't need to coerce it with\n        // Number().\n        if (typeof value === 'number') {\n            // Scratch treats NaN as 0, when needed as a number.\n            // E.g., 0 + NaN -> 0.\n            if (Number.isNaN(value)) {\n                return 0;\n            }\n            return value;\n        }\n        const n = Number(value);\n        if (Number.isNaN(n)) {\n            // Scratch treats NaN as 0, when needed as a number.\n            // E.g., 0 + NaN -> 0.\n            return 0;\n        }\n        return n;\n    }\n\n    /**\n     * Scratch cast to boolean.\n     * In Scratch 2.0, this is captured by `interp.boolArg.`\n     * Treats some string values differently from JavaScript.\n     * @param {*} value Value to cast to boolean.\n     * @return {boolean} The Scratch-casted boolean value.\n     */\n    static toBoolean (value) {\n        // Already a boolean?\n        if (typeof value === 'boolean') {\n            return value;\n        }\n        if (typeof value === 'string') {\n            // These specific strings are treated as false in Scratch.\n            if ((value === '') ||\n                (value === '0') ||\n                (value.toLowerCase() === 'false')) {\n                return false;\n            }\n            // All other strings treated as true.\n            return true;\n        }\n        // Coerce other values and numbers.\n        return Boolean(value);\n    }\n\n    /**\n     * Scratch cast to string.\n     * @param {*} value Value to cast to string.\n     * @return {string} The Scratch-casted string value.\n     */\n    static toString (value) {\n        return String(value);\n    }\n\n    /**\n     * Cast any Scratch argument to an RGB color array to be used for the renderer.\n     * @param {*} value Value to convert to RGB color array.\n     * @return {Array.<number>} [r,g,b], values between 0-255.\n     */\n    static toRgbColorList (value) {\n        const color = Cast.toRgbColorObject(value);\n        return [color.r, color.g, color.b];\n    }\n\n    /**\n     * Cast any Scratch argument to an RGB color object to be used for the renderer.\n     * @param {*} value Value to convert to RGB color object.\n     * @return {import(\"../typescript-support/types\").RGBObject} [r,g,b], values between 0-255.\n     */\n    static toRgbColorObject (value) {\n        let color;\n        if (typeof value === 'string' && value.substring(0, 1) === '#') {\n            color = Color.hexToRgb(value);\n            // If the color wasn't *actually* a hex color, cast to black\n            if (!color) color = {r: 0, g: 0, b: 0, a: 255};\n        } else {\n            color = Color.decimalToRgb(Cast.toNumber(value));\n        }\n        return color;\n    }\n\n    /**\n     * Determine if a Scratch argument is a white space string (or null / empty).\n     * @param {*} val value to check.\n     * @return {boolean} True if the argument is all white spaces or null / empty.\n     */\n    static isWhiteSpace (val) {\n        return val === null || (typeof val === 'string' && val.trim().length === 0);\n    }\n\n    /**\n     * Compare two values, using Scratch cast, case-insensitive string compare, etc.\n     * In Scratch 2.0, this is captured by `interp.compare.`\n     * @param {*} v1 First value to compare.\n     * @param {*} v2 Second value to compare.\n     * @returns {number} Negative number if v1 < v2; 0 if equal; positive otherwise.\n     */\n    static compare (v1, v2) {\n        let n1 = Number(v1);\n        let n2 = Number(v2);\n        if (n1 === 0 && Cast.isWhiteSpace(v1)) {\n            n1 = NaN;\n        } else if (n2 === 0 && Cast.isWhiteSpace(v2)) {\n            n2 = NaN;\n        }\n        if (isNaN(n1) || isNaN(n2)) {\n            // At least one argument can't be converted to a number.\n            // Scratch compares strings as case insensitive.\n            const s1 = String(v1).toLowerCase();\n            const s2 = String(v2).toLowerCase();\n            if (s1 < s2) {\n                return -1;\n            } else if (s1 > s2) {\n                return 1;\n            }\n            return 0;\n        }\n        // Handle the special case of Infinity\n        if (\n            (n1 === Infinity && n2 === Infinity) ||\n            (n1 === -Infinity && n2 === -Infinity)\n        ) {\n            return 0;\n        }\n        // Compare as numbers.\n        return n1 - n2;\n    }\n\n    /**\n     * Determine if a Scratch argument number represents a round integer.\n     * @param {*} val Value to check.\n     * @return {boolean} True if number looks like an integer.\n     */\n    static isInt (val) {\n        // Values that are already numbers.\n        if (typeof val === 'number') {\n            if (isNaN(val)) { // NaN is considered an integer.\n                return true;\n            }\n            // True if it's \"round\" (e.g., 2.0 and 2).\n            return val === parseInt(val, 10);\n        } else if (typeof val === 'boolean') {\n            // `True` and `false` always represent integer after Scratch cast.\n            return true;\n        } else if (typeof val === 'string') {\n            // If it contains a decimal point, don't consider it an int.\n            return val.indexOf('.') < 0;\n        }\n        return false;\n    }\n\n    static get LIST_INVALID () {\n        return 'INVALID';\n    }\n\n    static get LIST_ALL () {\n        return 'ALL';\n    }\n\n    /**\n     * Compute a 1-based index into a list, based on a Scratch argument.\n     * Two special cases may be returned:\n     * LIST_ALL: if the block is referring to all of the items in the list.\n     * LIST_INVALID: if the index was invalid in any way.\n     * @param {*} index Scratch arg, including 1-based numbers or special cases.\n     * @param {number} length Length of the list.\n     * @param {boolean} acceptAll Whether it should accept \"all\" or not.\n     * @return {(number|string)} 1-based index for list, LIST_ALL, or LIST_INVALID.\n     */\n    static toListIndex (index, length, acceptAll) {\n        if (typeof index !== 'number') {\n            if (index === 'all') {\n                return acceptAll ? Cast.LIST_ALL : Cast.LIST_INVALID;\n            }\n            if (index === 'last') {\n                if (length > 0) {\n                    return length;\n                }\n                return Cast.LIST_INVALID;\n            } else if (index === 'random' || index === 'any') {\n                if (length > 0) {\n                    return 1 + Math.floor(Math.random() * length);\n                }\n                return Cast.LIST_INVALID;\n            }\n        }\n        index = Math.floor(Cast.toNumber(index));\n        if (index < 1 || index > length) {\n            return Cast.LIST_INVALID;\n        }\n        return index;\n    }\n}\n\nmodule.exports = Cast;\n","export const openUIEvent = \"OPEN_UI_FROM_EXTENSION\";\nexport const registerButtonCallbackEvent = \"REGISTER_BUTTON_CALLBACK_FROM_EXTENSION\";\nexport const FrameworkID = \"ExtensionFramework\";\n\nexport const customArgumentFlag = \"internal_IsCustomArgument\";\nexport const customArgumentCheck = \"isCustomArgumentHack\";\nexport const dropdownStateFlag = \"dropdownState\";\nexport const dropdownEntryFlag = \"dropdownEntry\";\nexport const initDropdownState = \"init\";\nexport const openDropdownState = \"open\";\nexport const closeDropdownState = \"close\"; ","import Runtime from \"$scratch-vm/engine/runtime\";\nimport { Extension as BaseExtension } from \"./Extension\";\nimport { openUIEvent, registerButtonCallbackEvent } from \"./globals\";\n\nexport type ReactivityDependency = any | any[];\n\nexport const activeClass = true;\n\nexport const px = (numberOf: number) => `${numberOf}px`;\n\ntype UniqueKeys<Extension> = Exclude<keyof Extension, keyof BaseExtension<any, any>>;\ntype Methods<Extension> = { [K in UniqueKeys<Extension>]-?: Extension[K] extends (...args: any) => any ? K : never };\ntype Properties<Extension> = { [K in UniqueKeys<Extension>]-?: Extension[K] extends (...args: any) => any ? never : K };\ntype MethodParams<Extension> = { [Key in UniqueKeys<Extension>]: Extension[Key] extends (...args: any) => any ? Parameters<Extension[Key]> : never };\ntype MethodReturns<Extension> = { [Key in UniqueKeys<Extension>]: Extension[Key] extends (...args: any) => any ? ReturnType<Extension[Key]> : never };\n\nexport type ReactiveInvoke<Extension> = <T extends keyof Methods<Extension>>(funcName: Methods<Extension>[T] extends never ? never : T, ...args: MethodParams<Extension>[T]) => MethodReturns<Extension>[T];\nexport type ReactiveSet<Extension> = <T extends keyof Properties<Extension>>(propertyName: Properties<Extension>[T] extends never ? never : T, value: Extension[T]) => void;\n\nexport type ReactiveMethods<Extension> = {\n  invoke: ReactiveInvoke<Extension>;\n  set: ReactiveSet<Extension>;\n}\n\nexport const reactiveInvoke = <Extension, T extends keyof Methods<Extension>>(extensionAssignment: Extension, funcName: T, args: MethodParams<Extension>[T]): MethodReturns<Extension>[T] => {\n  return (extensionAssignment[funcName] as Function)(...args as []);\n}\n\nexport const reactiveSet = <Extension, T extends keyof Properties<Extension>>(extensionAssignment: Extension, propertyName: T, value: Extension[T]): void => {\n  extensionAssignment[propertyName] = value;\n}\n\nexport const openUI = (runtime: Runtime, details: { id: string, name: string, component: string, label?: string }) => runtime.emit(openUIEvent, details);\n\nexport const registerButtonCallback = (runtime: Runtime, buttonID: string, callback: (...args: any[]) => void) => {\n  runtime.emit(registerButtonCallbackEvent, buttonID);\n  runtime.on(buttonID, callback);\n}\n\nconst enum Color {\n  ui = \"ui\",\n  text = \"text\",\n  motion = \"motion\",\n  red = \"red\",\n  sound = \"sound\",\n  control = \"control\",\n  data = \"data\",\n  pen = \"pen\",\n  error = \"error\",\n  extensions = \"extensions\",\n  drop = \"drop\"\n}\n\n/**\n * Makes it easier to reference the css color variables defined in prg-extension-boilerplate/packages/scratch-gui/src/components/programmatic-modal/programmatic-modal.jsx\n */\nclass CssVar {\n  root: Color;\n\n  constructor(root: Color) { this.root = root }\n\n  get(...parts: string[]) { return `var(--${this.root}-${parts.join(\"-\")})` }\n  primary(...parts: string[]) { return this.get(\"primary\", ...parts) }\n  secondary(...parts: string[]) { return this.get(\"secondary\", ...parts) }\n  tertiary(...parts: string[]) { return this.get(\"tertiary\", ...parts) }\n  transparent(...parts: string[]) { return this.get(\"transparent\", ...parts) }\n  light(...parts: string[]) { return this.get(\"light\", ...parts) }\n}\n\nconst ui = new CssVar(Color.ui);\nconst text = new CssVar(Color.text);\nconst motion = new CssVar(Color.motion);\nconst red = new CssVar(Color.red);\nconst sound = new CssVar(Color.sound);\nconst control = new CssVar(Color.control);\nconst data = new CssVar(Color.data);\nconst pen = new CssVar(Color.pen);\nconst error = new CssVar(Color.error);\nconst extensions = new CssVar(Color.extensions);\nconst drop = new CssVar(Color.extensions);\n\n/**\n * Color variable references corresponding to the css variables defined in prg-extension-boilerplate/packages/scratch-gui/src/components/programmatic-modal/programmatic-modal.jsx\n */\nexport const color = {\n  \"ui\": {\n    primary: ui.primary(),\n    secondary: ui.secondary(),\n    tertiary: ui.tertiary(),\n    modalOverlay: ui.get(\"modal\", \"overlay\"),\n    white: ui.get(\"white\"),\n    whiteDim: ui.get(\"white\", \"dim\"),\n    whiteTransparent: ui.get(\"white\", \"transparent\"),\n    transparent: ui.transparent(),\n    blackTransparent: ui.get(\"black\", \"transparent\"),\n  },\n  \"text\": {\n    primary: text.primary(),\n    primaryTransparent: text.transparent(),\n  },\n  \"motion\": {\n    primary: motion.primary(),\n    tertiary: motion.tertiary(),\n    transparent: motion.get(\"transparent\"),\n    lightTansparent: motion.light(\"transparent\"),\n  },\n  \"red\": {\n    primary: red.primary(),\n    tertiary: red.tertiary(),\n  },\n  \"sound\": {\n    primary: sound.primary(),\n    tertiary: sound.tertiary(),\n  },\n  \"control\": {\n    primary: control.primary(),\n  },\n  \"data\": {\n    primary: data.primary(),\n  },\n  \"pen\": {\n    primary: pen.primary(),\n    transparent: pen.transparent(),\n  },\n  \"error\": {\n    primary: error.primary(),\n    light: error.light(),\n    transparent: error.transparent(),\n  },\n  \"extensions\": {\n    primary: extensions.primary(),\n    tertiary: extensions.tertiary(),\n    light: extensions.light(),\n    transparent: extensions.transparent(),\n  },\n  \"drop\": {\n    highlight: drop.get(\"highlight\")\n  }\n}","import { MenuItem } from \"./types\"\n\ntype FetchParams = {\n  request: Parameters<typeof fetch>[0],\n  options: Parameters<typeof fetch>[1]\n}\n\nexport const getValueFromMenuItem = <T>(item: MenuItem<T>) => typeof item === \"object\" ? (item as { value: T }).value : item;\n\nexport const getTextFromMenuItem = <T>(item: MenuItem<T>) => typeof item === \"object\" ? (item as { text: string }).text : item;\n\nexport async function fetchWithTimeout(\n  resource: FetchParams[\"request\"],\n  options: FetchParams[\"options\"] & { timeout: number }\n) {\n  const { timeout } = options;\n\n  const controller = new AbortController();\n  const id = setTimeout(() => controller.abort(), timeout);\n\n  const response = await fetch(resource, {\n    ...options,\n    signal: controller.signal\n  });\n\n  clearTimeout(id);\n\n  return response;\n}\n\nexport async function untilObject<T>(getter: () => T, delay: number = 100): Promise<T> {\n  let timeout: NodeJS.Timeout;\n  let value: T = getter();\n  while (!value) {\n    await new Promise(resolve => {\n      clearTimeout(timeout);\n      timeout = setTimeout(resolve, delay);\n    });\n    value = getter();\n  }\n  clearTimeout(timeout);\n  return value;\n}\n\nexport async function untilCondition(condition: () => boolean, delay: number = 100): Promise<void> {\n  let timeout: NodeJS.Timeout;\n  while (!condition()) {\n    await new Promise(resolve => {\n      clearTimeout(timeout);\n      timeout = setTimeout(resolve, delay);\n    });\n  }\n  clearTimeout(timeout);\n};\n\nexport async function untilReady<T extends { ready: boolean }>(obj: T, delay: number = 100): Promise<void> {\n  let timeout: NodeJS.Timeout;\n  while (!obj.ready) {\n    await new Promise(resolve => {\n      clearTimeout(timeout);\n      timeout = setTimeout(resolve, delay);\n    });\n  }\n  clearTimeout(timeout);\n};\n\nexport const isString = (query: any) => typeof query === 'string' || query instanceof String;\n\nexport const isFunction = (query: any) =>\n  Object.prototype.toString.call(query) === \"[object Function]\"\n  || \"function\" === typeof query\n  || query instanceof Function;\n\nexport const isPrimitive = (query: any) => query !== Object(query);\n\nexport const splitOnCapitals = (query: string) => query.split(/(?=[A-Z])/);\n\n/**\n * A type safe utility function for copy values from one object to another\n * @param param0 object containing the target to copy values to and the source of the values to copy\n */\nexport const copyTo = <TTarget extends object, TSource extends { [k in keyof TTarget]?: TTarget[k] }>({ target, source }: { target: TTarget, source: TSource }) => {\n  for (const key in source) {\n    if (!(key in target)) continue;\n    // @ts-ignore -- the types of the function should ensure this is valud TS\n    target[key] = source[key]\n  }\n}\n\nexport const identity = (x: any) => x;\n\nexport const loadExternalScript = (url: string, onLoad: () => void, onError?: () => void) => {\n  const script = document.createElement('script');\n\n  script.onload = onLoad;\n\n  script.onerror = onError ?? (() => {\n    throw new Error(`Error loading endpoint: ${url}`)\n  });\n\n  script.src = url;\n  script.async = true;\n\n  document.body.appendChild(script);\n}\n\n/**\n * \n * @param url \n * @returns \n */\nexport const untilExternalScriptLoaded = async (url: string): Promise<void> => {\n  const scriptLoaded = new Promise((resolve, reject) => {\n    const script = document.createElement('script');\n    script.onload = resolve;\n    script.onerror = reject;\n    script.async = true;\n    script.src = url;\n    document.body.appendChild(script);\n  });\n  await scriptLoaded;\n  return;\n}\n\n/**\n * \n * @param url \n * @param globalVariableName \n * @returns \n */\nexport const untilExternalGlobalVariableLoaded = async <T>(url: string, globalVariableName: string): Promise<T> => {\n  if (window[globalVariableName]) return window[globalVariableName];\n  await untilExternalScriptLoaded(url);\n  return window[globalVariableName];\n}","import { Extension } from \"$common/Extension\";\nimport { untilObject } from \"$common/utils\";\nimport { ArgumentEntry, ArgumentEntrySetter } from \"./CustomArgumentManager\";\n\n/** Constructed based on Svelte documentation: https://svelte.dev/docs#run-time-client-side-component-api-creating-a-component */\ntype CreateComponentOptions = {\n  target: Element | HTMLElement;\n  anchor?: Element | HTMLElement;\n  props: {};\n}\n\nexport type CustomArgumentUIConstructor = (options: CreateComponentOptions) => void;\n\nexport const renderToDropdown = async <T>(\n  compononentConstructor: CustomArgumentUIConstructor,\n  props: {\n    extension: Extension<any, any>,\n    setter: ArgumentEntrySetter<T>,\n    current: ArgumentEntry<T>\n  }\n) => {\n  const dropdownContainerClass = \"blocklyDropDownContent\";\n  const elements = document.getElementsByClassName(dropdownContainerClass);\n  if (elements.length !== 1) return console.error(`Uh oh! Expected 1 element with class '${dropdownContainerClass}', but found ${elements.length}`);\n  const [target] = elements;\n  const anchor = await untilObject(() => target.children[0]);\n  const component = new compononentConstructor({ target, anchor, props });\n  centerDropdownButton(anchor);\n}\n\nconst centerDropdownButton = (container: Element) => {\n  type ClassAndStyleModification = [string, (syle: CSSStyleDeclaration) => void];\n\n  const findElementAndModifyStyle = ([className, styleMod]: ClassAndStyleModification) => {\n    const elements = container.getElementsByClassName(className);\n    console.assert(elements.length === 1, `Incorrect number of elements found with class: ${className}`);\n    styleMod((elements[0] as HTMLElement).style);\n  };\n\n  const elements = [\n    [\n      \"goog-menuitem goog-option\",\n      (style) => {\n        style.margin = \"auto\";\n        style.paddingLeft = style.paddingRight = \"0px\";\n      }\n    ],\n    [\n      \"goog-menuitem-content\",\n      (style) => style.textAlign = \"center\"\n    ]\n  ] satisfies ClassAndStyleModification[];\n\n  elements.forEach(findElementAndModifyStyle);\n}","import Runtime from \"$root/packages/scratch-vm/src/engine/runtime\";\nimport { Extension } from \"../Extension\";\nimport { closeDropdownState, customArgumentFlag, dropdownEntryFlag, dropdownStateFlag, initDropdownState, openDropdownState } from \"../globals\";\nimport { ArgumentEntry } from \"./CustomArgumentManager\";\nimport { CustomArgumentUIConstructor, renderToDropdown } from \"./dropdownOverride\";\n\ntype ComponentGetter = (id: string, componentName: string) => CustomArgumentUIConstructor;\n\nconst callingContext = {\n  DrowpdownOpen: openDropdownState,\n  DropdownClose: closeDropdownState,\n  Init: initDropdownState,\n} as const;\n\n/**\n * Checks if the value returned by a dyanmic menu indicates that it should be treated as a 'custom argument'\n * @param arr \n * @returns \n */\nexport const isCustomArgumentHack = (arr: Array<string | { text: string }>) => {\n  if (arr.length !== 1) return false;\n  const item = arr[0];\n  if (typeof item !== \"object\") return false;\n  const { text } = item;\n  return text === customArgumentFlag;\n}\n\n/**\n * \n * @param this The 'this' calling context of this function is assumed to be an Extension\n * @param runtime \n * @param entry \n * @param getComponent \n * @returns \n */\nexport function processCustomArgumentHack<T extends Extension<any, any>>(\n  this: T,\n  runtime: Runtime,\n  [{ value }]: Array<{ value: string }>,\n  getComponent: ComponentGetter\n): (readonly [string, string])[] {\n  const { id: extensionID, customArgumentManager: argumentManager } = this;\n  const { component, id: initialID } = JSON.parse(value) as { component: string, id: string };\n  const context = runtime[dropdownStateFlag];\n\n  switch (context) {\n    case callingContext.Init:\n      return argumentManager.getCurrentEntries();\n    case callingContext.DropdownClose: {\n      const result = argumentManager.tryResolve();\n      return result ? [[result.entry.text, result.id]] : argumentManager.getCurrentEntries();\n    }\n    case callingContext.DrowpdownOpen: {\n      const currentEntry = runtime[dropdownEntryFlag] as ArgumentEntry<any>;\n      const prevID = currentEntry?.value ?? initialID;\n      const current = argumentManager.getEntry(prevID);\n      const [id, setEntry] = argumentManager.request();\n      renderToDropdown(getComponent(extensionID, component), { setter: setEntry, current, extension: this });\n      return [[\"Apply\", id]];\n    }\n  }\n\n  throw new Error(\"Error during processing -- Context:\" + callingContext);\n}","export type ArgumentEntry<T> = { text: string, value: T };\nexport type ArgumentEntrySetter<T> = (entry: ArgumentEntry<T>) => void;\n\nexport default class CustomArgumentManager {\n  map: Map<string, ArgumentEntry<any>> = new Map();\n  pending: { id: string, entry: ArgumentEntry<any> } = null;\n\n  clearPending() { this.pending = null }\n  setPending(update: typeof this.pending) { this.pending = update }\n\n  add<T>(entry: ArgumentEntry<T>): string {\n    const id = CustomArgumentManager.GetIdentifier();\n    this.map.set(id, entry);\n    this.clearPending();\n    return id;\n  }\n\n  insert<T>(id: string, entry: ArgumentEntry<T>): string {\n    this.map.set(id, entry);\n    this.clearPending();\n    return id;\n  }\n\n  request<T>(): [string, ArgumentEntrySetter<T>] {\n    this.clearPending();\n    const id = CustomArgumentManager.GetIdentifier();\n    return [id, (entry) => this.setPending({ id, entry })];\n  }\n\n  tryResolve() {\n    if (!this.pending) return;\n    const { pending: { entry, id } } = this;\n    this.map.set(id, entry);\n    this.clearPending();\n    return { entry, id };\n  }\n\n  getCurrentEntries() {\n    return Array.from(this.map.entries())\n      .filter(([_, entry]) => entry !== null)\n      .map(([id, { text }]) => [text, id] as const);\n  }\n\n  getEntry(id: string) { return this.map.get(id) }\n\n  static SaveKey = \"internal_customArgumentsSaveData\" as const;\n\n  requiresSave() { this.map.size > 0 }\n\n  saveTo(obj: object) {\n    const entries = Array.from(this.map.entries())\n      .filter(([_, entry]) => entry !== null)\n      .map(([id, entry]) => ({ id, entry }));\n    if (entries.length === 0) return;\n    obj[CustomArgumentManager.SaveKey] = entries;\n  }\n\n  loadFrom(obj: Record<typeof CustomArgumentManager[\"SaveKey\"], { id: string, entry: ArgumentEntry<any> }[]>) {\n    obj[CustomArgumentManager.SaveKey]?.forEach(({ id, entry }) => {\n      this.map.set(id, entry);\n    });\n  }\n\n  /**\n   * @todo Implement this if it becomes necessary (i.e the every growing size of this.map becomes an issue)\n   */\n  private purgeStaleIDs() {\n    // Somehow, tap into blockly to loop through all current blocks & their field dropdowns.\n    // Collect all field dropdowns values. \n    // Then, loop over entries in this.map -- if the values don't appear in the collected in-use values, drop those items.\n    // NOTE: The blocks in the 'pallette' do not show up in a target's \"blocks\" object, which makes this tricky.\n  }\n\n  static IsIdentifier = (query: string) => query.startsWith(CustomArgumentManager.IdentifierPrefix);\n  private static GetIdentifier = () => CustomArgumentManager.IdentifierPrefix + new Date().getTime().toString();\n  private static IdentifierPrefix = \"__customArg__\";\n}","import { ArgumentType, BlockType, Language } from './enums';\nimport type { ExtensionMenuDisplayDetails, ExtensionBlocks, Block, ExtensionArgumentMetadata, ExtensionMetadata, ExtensionBlockMetadata, ExtensionMenuMetadata, Argument, MenuItem, RGBObject, BlockDefinitions, VerboseArgument, Environment, Menu, DynamicMenu, MenuThatAcceptsReporters, DynamicMenuThatAcceptsReporters, TypeByArgumentType, AllText, Translations, BlockOperation, ValueOf, BaseExtension, ExtensionMenuItems } from './types';\nimport Cast from '$scratch-vm/util/cast';\n//import * as formatMessage from 'format-message';\nimport Runtime from \"$scratch-vm/engine/runtime\";\nimport { openUI, registerButtonCallback } from './ui';\nimport { identity, isFunction, isPrimitive, isString } from './utils';\nimport { isCustomArgumentHack, processCustomArgumentHack } from './customArguments';\nimport { customArgumentCheck, customArgumentFlag } from './globals';\nimport CustomArgumentManager, { ArgumentEntry } from './customArguments/CustomArgumentManager';\nimport { SaveDataHandler } from './SavaDataHandler';\n\nexport type CodeGenArgs = {\n  name: never,\n  id: never,\n  blockIconURI: never,\n}\n\nexport type PopulateCodeGenArgs = { [k in keyof CodeGenArgs]: CodeGenArgs[k] extends never ? string : never };\n\n/**\n * @summary Base class for all extensions implemented via the Typescript Extension Framework.\n * @example \n * class MyExtension extends Extension<\n *  { // Display details\n *    name: \"My Extension\",\n *    description: \"This is my extension\",\n *    iconURL: \"example.png\",\n *    insetIconURL: \"example.svg\"\n *  },\n *  { // Blocks\n *    myBlock: (someArg: number) => void;\n *  }\n * > {\n *  init(env: Environment): { ... };\n *  defineBlocks(): MyExtension[\"BlockDefinitions\"] { return ... }\n * }\n * @description Extension developers will create Typescript classes that `extend` (or 'inherit', or 'implement') this `Extension` class.\n * \n * In order to `extend` this class, you must first specify 2 generic type arguments, which effectively describe what kind of Extension you're implementing.\n * \n * More specifically, the 2 generic type arguments describe how this extension is presented to the user (by specifyng the details displayed in the Extensions Menu),\n * and what this Extension actually does (by specifying the blocks it will define).\n * \n * By declaring that we're extending an `Extension` with our specific generic type arguments,\n * Typescript holds us accountable to implement exactly what we said we would (all in order to make a working extension).\n *  \n * This includes:\n * * Defining an `init` method, which is used INSTEAD of a constructor\n * * Defining a `defineBlocks` method that does just that: defines this extension's blocks \n * @template MenuDetails How the extension should display in the extensions menu \n * @template Blocks What kind of blocks this extension implements\n * @link https://www.typescriptlang.org/docs/handbook/2/generics.html Learn more about generics! \n */\nexport abstract class Extension\n  <\n    MenuDetails extends ExtensionMenuDisplayDetails,\n    Blocks extends ExtensionBlocks\n  > {\n  runtime: Runtime;\n\n  /**\n   * Optional field that can be defined if you need to save custom data for an extension \n   * (like some extension specific variable, or an API endpoint).\n   * @example\n   * class Example extends Extension<..., ...> {\n   *    someValue = 5;\n   *    ...\n   *    saveDataHandler = new SaveDataHandler({\n   *      Extension: Example,\n   *      // NOTE: The type info for 'instance' could be left off in the line below\n   *      onSave: (instance: Example) => ({ valueToSave: instance.someValue }),\n   *      onLoad: (instance, data) => instance.someValue = data.valueToSave\n   *    })\n   * }\n   * @see Extension.MakeSaveDataHandler\n   */\n  protected saveDataHandler: SaveDataHandler<typeof this, any> = undefined;\n\n  readonly BlockFunctions: Blocks;\n  readonly BlockDefinitions: BlockDefinitions<typeof this>;\n  readonly Translations: Translations<typeof this>;\n\n  private readonly internal_blocks: ExtensionBlockMetadata[] = [];\n  private readonly internal_menus: (ExtensionMenuItems & { name: string })[] = [];\n\n  private keyByLegacyName: Record<keyof Blocks, string> = undefined;\n\n  private argumentManager: CustomArgumentManager = null;\n\n  public get customArgumentManager(): CustomArgumentManager {\n    return this.argumentManager\n  }\n\n  /**\n   * WARNING! If you change this key, it will affect already saved projects.\n   * Do not rename this without first developing a mechanism for searching for previously used keys.\n   */\n  private static SaveDataKey = \"customSaveDataPerExtension\" as const;\n\n  /**\n   * Save function called 'internally' by the VM when serializing a project.\n   * @param toSave \n   * @param extensionIDs \n   * @returns \n   */\n  private save(toSave: { [Extension.SaveDataKey]: Record<string, any> }, extensionIDs: Set<string>) {\n    const { saveDataHandler, id, argumentManager } = this;\n    const saveData = saveDataHandler?.hooks.onSave(this) ?? {};\n    argumentManager?.saveTo(saveData);\n    if (Object.keys(saveData).length === 0) return;\n    const container = toSave[Extension.SaveDataKey];\n    container ? (container[id] = saveData) : (toSave[Extension.SaveDataKey] = { [id]: saveData });\n    extensionIDs.add(id);\n  }\n\n  /**\n   * Load function called 'internally' by the VM when loading a project.\n   * Will be invoked on an extension immediately after it is constructed.\n   * @param saved \n   * @returns \n   */\n  private load(saved: { [Extension.SaveDataKey]: Record<string, any> }) {\n    if (!saved) return;\n    const { saveDataHandler, id } = this;\n    const saveData = Extension.SaveDataKey in saved ? saved[Extension.SaveDataKey][id] : null;\n    if (!saveData) return;\n    saveDataHandler?.hooks.onLoad(this, saveData);\n    (this.argumentManager ??= new CustomArgumentManager()).loadFrom(saveData);\n  }\n\n\n  openUI(component: string, label?: string) {\n    const { id, name, runtime } = this;\n    openUI(runtime, { id, name, component: component.replace(\".svelte\", \"\"), label });\n  }\n\n  constructor(runtime: never, codeGenArgs?: CodeGenArgs) {\n    const { name, id, blockIconURI } = codeGenArgs ?? this[Extension.InternalCodeGenArgsGetterKey]() as CodeGenArgs;\n    this.name = name;\n    this.id = id;\n    this.blockIconURI = blockIconURI;\n    this.runtime = runtime;\n    Extension.ExtensionsByID.set(id, this);\n  }\n\n  private internal_init() {\n    this.init({ runtime: this.runtime, videoFeed: this.runtime.ioDevices?.video });\n    const definitions = this.defineBlocks();\n    const menus: Menu<any>[] = [];\n    const menuNames: string[] = [];\n    for (const key in definitions) {\n      const block = isFunction(definitions[key]) ? (definitions[key] as Function)(this) : definitions[key];\n      const info = this.convertToInfo(key, block, menus, menuNames);\n      this.internal_blocks.push(info);\n    }\n\n    const reporterItemsKey: keyof MenuThatAcceptsReporters<any> = \"items\";\n    const reporterItemsGetterKey: keyof DynamicMenuThatAcceptsReporters<any> = \"getItems\";\n    for (const [index, menu] of menus.entries()) {\n      let acceptReporters = false;\n      const name = menuNames[index];\n\n      if (Array.isArray(menu)) {\n        const items: any[] | MenuItem<any>[] = menu;\n        this.addStaticMenu(items, acceptReporters, name);\n        continue;\n      }\n\n      if (isFunction(menu)) {\n        const getItems = menu as DynamicMenu<any>;\n        this.addDynamicMenu(getItems, acceptReporters, name);\n        continue;\n      }\n\n      acceptReporters = true;\n\n      if (reporterItemsKey in menu) {\n        const nonDynamic = menu as MenuThatAcceptsReporters<any>;\n        this.addStaticMenu(nonDynamic.items, acceptReporters, name);\n        continue;\n      }\n\n      if (reporterItemsGetterKey in menu) {\n        const dynamicMenu = menu as DynamicMenuThatAcceptsReporters<any>;\n        this.addDynamicMenu(dynamicMenu.getItems, acceptReporters, name);\n        continue;\n      }\n    }\n  }\n\n  /**\n   * The ID of this extension.\n   * NOTE: The `never` type is used to prevent users from defining their own extension ID (which will be filled in through code generation).\n   */\n  readonly id: string & never;\n\n  /**\n   * The name of this extension.\n   * NOTE: The `never` type is used to prevent users from re-defining an extension Name (which is already defined through ExtensionMenuDisplayDetails)\n   */\n  readonly name: string & never;\n\n  /**\n   * NOTE: The `never` type is used to prevent users from re-defining the blockIconURI (the insetIconURI from ExtensionMenuDisplayDetails will be encoded and used)\n   */\n  private readonly blockIconURI: never;\n\n  /**\n   * @summary This member function (or 'method') will be called when a user adds your extension via the Extensions Menu (i.e. when your extension is instantiated)\n   * @example\n   * // Initialize class field(s)\n   * private count: number;\n   * \n   * init() {\n   *  count = 0;\n   * }\n   * @example \n   * // Interact with environment's runtime \n   * init(env: Environment) {\n   *  env.runtime.emit(RuntimeEvent.ProjectStart);\n   * }\n   * @example \n   * // Nothing to initialize\n   * init() {}\n   * @description This function is intended to behave exactly like a constructor, used to initialize the state of your extension.\n   * \n   * The reason we use this function INSTEAD of a constructor is so that the base Extension class can manage the construction of this class.\n   * @param {Environment} env An object that allows your Extension to interact with the Scratch Environment. Currently is a little bare, but will be expanded soon.\n   * Can be ommitted if not needed.\n   * \n   * For Scratch developers: The `runtime` property on env is the same as the runtime passed to non-Typescript-Framework Extension constructors\n   */\n  abstract init(env: Environment): void;\n\n  /**\n   * @summary Extension member method that returns an object defining all blocks that belong to the extension.\n   * @description Every block your extension implements (defined by the second generic argument of the Extension class), will have an entry in the object return by this function.\n   * Each entry will either be an object or a function that returns an object that provides the:\n   * - type: the type of block\n   * - text: what is displayed on the block\n   * - arg or args: the arguments the block accepts\n   * - operation: the function that is called when the blocked is executed\n   * @example\n   * // Returning an object with two block definition function for 'someBlock'\n   * defineBlocks(): ExampleExtension[\"BlockDefinitions\"] {\n   *  return {\n   *    // Using object syntax\n   *    someBlock: {\n   *      type: BlockType.Reporter,\n   *      arg: ArgumentType.String,\n   *      text: (argument) => `Some text about ${argument}`,\n   *      operation: (argument) => {\n   *        // do something\n   *      }\n   *    },\n   *    // Using arrow function syntax\n   *    someBlock: (self: MyExtension) => ({\n   *      type: BlockType.Reporter,\n   *      arg: ArgumentType.String,\n   *      text: (argument) => `Some text about ${argument}`,\n   *      operation: (argument) => {\n   *        // do something\n   *      }\n   *    }),\n   *    // Using method function syntax\n   *    someOtherBlock(self: MyExtension) {\n   *      const type = BlockType.Reporter;\n   *      const arg = ArgumentType.String;\n   *      return {\n   *        arg, type,\n   *        text: (argument) => `Some text about ${argument}`,\n   *        operation: (argument) => {\n   *          // do something\n   *        }\n   *      }\n   *    }\n   *  }\n   * }\n   * @see BlockDefinitions\n   * @returns {BlockDefinitions<Blocks>} An object defining 'block definition' objects / functions for each block associated with this Extension.\n   */\n  abstract defineBlocks(): BlockDefinitions<Extension<MenuDetails, Blocks>>;\n\n  /**\n   * @summary Define the translations for this extension.\n   * \n   * @description Ignore this for now (but don't delete it)! \n   * \n   * Translations are still a work in progress, but will be supported.\n   */\n  defineTranslations?(): Translations<Extension<MenuDetails, Blocks>>;\n\n  private getInfo(): ExtensionMetadata {\n    const { id, internal_blocks: blocks, internal_menus: menus, name, blockIconURI } = this;\n    const info = { id, blocks, name, blockIconURI };\n    if (menus) info['menus'] = Object.values(this.internal_menus).reduce((obj, { name, ...value }) => {\n      obj[name] = value;\n      return obj;\n    }, {});\n\n    return info;\n  }\n\n  private addStaticMenu(items: MenuItem<any>[], acceptReporters: boolean, name: string) {\n    this.internal_menus.push({\n      name,\n      acceptReporters,\n      items: items.map(item => item /**TODO figure out how to format */).map(Extension.ConvertMenuItemsToString)\n    });\n  }\n\n  private addDynamicMenu(getItems: DynamicMenu<any>, acceptReporters: boolean, name: string) {\n    // this key might need to be adapted for legacy extensions\n    const key = `internal_dynamic_${this.internal_menus.length}`;\n    this[key] = () => {\n      const items = getItems();\n      return items.map(item => item).map(Extension.ConvertMenuItemsToString);\n    };\n    this.internal_menus.push({ acceptReporters, items: key, name });\n  }\n\n  private convertToInfo(key: keyof Blocks & string, block: Block<this, BlockOperation>, menusToAdd: MenuItem<any>[], menuNames: string[]): ExtensionBlockMetadata {\n    const { type, text, operation } = block;\n    const args: Argument<any>[] = block.arg ? [block.arg] : block.args;\n\n    const legacyInfo = Extension.ExtractLegacyInformation(block);\n    const isLegacy = legacyInfo !== undefined;\n\n    if (isLegacy) this.keyByLegacyName\n      ? this.keyByLegacyName[key] = legacyInfo.name\n      : this.keyByLegacyName = { [key]: legacyInfo.name } as Record<keyof Blocks, string>;\n\n    const { displayText, orderedNames } = Extension.ConvertToDisplayText(this, key, text, args, isLegacy);\n    const { argumentsInfo, handlers } = Extension.ConvertToArgumentInfo(this, key, args, menusToAdd, menuNames) ?? { argumentsInfo: undefined, handlers: undefined };\n\n    const opcode = isLegacy ? legacyInfo.name : Extension.GetInternalKey(key);\n    const bound = operation.bind(this);\n\n    const { id } = this;\n\n    const isButton = type === BlockType.Button;\n    const buttonID = isButton ? Extension.GetButtonID(id, opcode) : undefined;\n\n    isButton\n      ? registerButtonCallback(this.runtime, buttonID, bound)\n      : this.registerOpcode(opcode, bound, args, handlers, orderedNames, isLegacy);\n\n    return {\n      opcode,\n      text: displayText,\n      blockType: type,\n      arguments: argumentsInfo,\n      func: buttonID,\n    }\n  }\n\n  private [customArgumentCheck] = isCustomArgumentHack.bind(this) as typeof isCustomArgumentHack;\n  private processCustomArgumentHack = processCustomArgumentHack.bind(this) as typeof processCustomArgumentHack<Extension<MenuDetails, Blocks>>;\n\n  private format(text: string, identifier: string, description: string): string {\n    return text;\n    /** \n    return formatMessage({\n      id: `extension.${this.id}.${identifier}`,\n      default: text,\n      description: `${description} (of '${this.name}' extension)`,\n    });\n    */\n  }\n\n  private registerOpcode(opcode: string, bound: Function, args: Argument<any>[], handlers: Function[], orderedNames: string[], isLegacy: boolean,) {\n    const { customArgumentManager } = this;\n    this[opcode] = (argsFromScratch, blockUtility) => {\n      const { mutation } = argsFromScratch; // if we need it...\n\n      const uncasted = isLegacy\n        ? orderedNames.map(name => argsFromScratch[name])\n        // NOTE: Assumption is that args order will be correct since their keys are parsable as ints (i.e. '0', '1', ...)\n        : Object.values(argsFromScratch).slice(0, -1);\n\n      const casted = uncasted.map((param: any, index) => {\n        const type = Extension.GetArgumentType(args[index]);\n        const handler = handlers[index] ?? identity;\n\n        return type !== ArgumentType.Custom\n          ? Extension.CastToType(type, handler(param))\n          : !(isString(param) && CustomArgumentManager.IsIdentifier(param))\n            ? handler(param)\n            : handler(customArgumentManager.getEntry(param).value)\n      });\n\n      return bound(...casted, blockUtility); // can add more util params as necessary\n    }\n  }\n\n  /*\n    addTranslations(map: Record<Language, string>) {\n      const translations = this.getTranslations();\n      if (!translations) return;\n  \n      for (const key in map) {\n        if (!(key in translations)) continue;\n  \n        const forLocale = translations[key as Language];\n        if (!forLocale) continue;\n  \n        for (const translationID in forLocale) {\n          map[translationID] = forLocale[translationID];\n        }\n      }\n    }\n  */\n\n  static GetExtensionByID = <T extends Extension<any, any>>(id: string): T => {\n    if (Extension.ExtensionsByID.has(id)) return Extension.ExtensionsByID.get(id) as T;\n    console.error(`Could not find extension with id '${id}'`);\n    return undefined;\n  }\n\n  static TryCastToArgumentType = <T extends ValueOf<typeof ArgumentType>>(\n    argumentType: T,\n    value: any,\n    onFailure: (value: any) => TypeByArgumentType<T>\n  ): TypeByArgumentType<T> => {\n    try {\n      const casted = Extension.CastToType(argumentType, value);\n      return casted as TypeByArgumentType<T>;\n    }\n    catch {\n      return onFailure(value);\n    }\n  }\n\n  protected makeCustomArgument = <T>({ component, initial, acceptReportersHandler: handler }: { component: string, initial: ArgumentEntry<T>, acceptReportersHandler?: (x: any) => ArgumentEntry<T> }): Argument<T> => {\n    this.argumentManager ??= new CustomArgumentManager();\n    const id = this.argumentManager.add(initial);\n    const getItems = () => [{ text: customArgumentFlag, value: JSON.stringify({ component, id }) }];\n    return {\n      type: ArgumentType.Custom,\n      defaultValue: id,\n      options: handler === undefined ? getItems : { acceptsReports: true, getItems, handler },\n    } as Argument<T>\n  }\n\n  static GetKeyFromOpcode = (opcode: string) => opcode.replace(Extension.GetInternalKey(\"\"), \"\");\n\n  private static ConvertToDisplayText<T extends BaseExtension>(ext: T, key: string, text: string | ((...args: any[]) => string), args: Argument<any>[], isLegacy: boolean) {\n    const orderedNames = isLegacy ? [] : undefined;\n\n    type TextFunc = (...params: any[]) => string;\n    const resolvedText: string = isFunction(text)\n      ? (text as TextFunc)(...args.map((arg, index) => {\n        const name = isLegacy ? Extension.ExtractLegacyInformation(arg).name : index;\n        if (isLegacy) orderedNames.push(name);\n        return `[${name}]`\n      }))\n      : text as string;\n\n    // Once translations supported, replace with 'format'\n    return { displayText: ext.format(resolvedText, key, `Block text for '${key}'`), orderedNames };\n  }\n\n  private static ConvertToArgumentInfo<T extends BaseExtension>(ext: T, key: string, args: Argument<any>[], menusToAdd: MenuItem<any>[], menuNames: string[]) {\n    if (!args) return undefined;\n\n    type Handler = MenuThatAcceptsReporters<any>['handler'];\n    const handlerKey: keyof MenuThatAcceptsReporters<any> = 'handler';\n    const handlers = args ? new Array<Handler>(args.length).fill(undefined) : undefined;\n\n    type Entry = ExtensionArgumentMetadata & { name: string };\n\n    const argumentsInfo = args\n      .map((element, index) => {\n        const entry = {} as Entry;\n        entry.type = Extension.GetArgumentType(element);\n        entry.name = Extension.ExtractLegacyInformation(element)?.name ?? `${index}`;\n\n        if (isPrimitive(element)) return entry;\n\n        const { defaultValue, options } = element as VerboseArgument<any>;\n\n        if (defaultValue !== undefined)\n          entry.defaultValue = isString(entry)\n            ? ext.format(defaultValue, Extension.GetArgTranslationID(key, index), `Default value for arg ${index + 1} of ${key} block`)\n            : defaultValue;\n\n        if (!options) return entry;\n\n        const alreadyAddedIndex = menusToAdd.indexOf(options);\n        const alreadyAdded = alreadyAddedIndex >= 0;\n        const menuIndex = alreadyAdded ? alreadyAddedIndex : menusToAdd.push(options) - 1;\n        const name = Extension.ExtractLegacyInformation(options)?.name ?? `${menuIndex}`;\n\n        if (!alreadyAdded) menuNames.push(name);\n\n        entry.menu = name;\n\n        if (handlerKey in options) {\n          const { handler } = options as MenuThatAcceptsReporters<any> | DynamicMenuThatAcceptsReporters<any>;\n          handlers[index] = handler;\n        }\n\n        return entry;\n      })\n      .reduce((accumulation, { name, ...value }) => {\n        accumulation[name] = value;\n        return accumulation;\n      }, {});\n\n    return { argumentsInfo, handlers };\n  }\n\n  private static GetArgTranslationID = (blockname: string, index: number) => {\n    return `${blockname}-arg${index}-default`;\n  }\n\n  private static GetInternalKey = (key: string) => `internal_${key}`;\n  private static GetButtonID = (id: string, opcode: string) => `${id}_${opcode}`;\n\n  private static GetArgumentType = <T>(arg: Argument<T>): ValueOf<typeof ArgumentType> =>\n    isPrimitive(arg) ? arg as ValueOf<typeof ArgumentType> : (arg as VerboseArgument<T>).type;\n\n  private static ToFlag = (value: string): boolean => parseInt(value) === 1;\n\n  private static ToMatrix = (matrixString: string): boolean[][] => {\n    if (matrixString.length !== 25) return new Array(5).fill(new Array(5).fill(false));\n\n    const entries = matrixString.split('');\n    const matrix = entries.map(Extension.ToFlag).reduce((matrix, flag, index) => {\n      const row = Math.floor(index / 5);\n      const column = index % 5;\n      (column === 0) ? matrix[row] = [flag] : matrix[row].push(flag);\n      return matrix;\n    }, new Array<boolean[]>(5));\n\n    return matrix;\n  }\n\n  private static CastToType = (argumentType: ValueOf<typeof ArgumentType>, value: any) => {\n    switch (argumentType) {\n      case ArgumentType.String:\n        return `${value}`;\n      case ArgumentType.Number:\n        return parseFloat(value);\n      case ArgumentType.Boolean:\n        return JSON.parse(value);\n      case ArgumentType.Note:\n        return parseInt(value);\n      case ArgumentType.Angle:\n        return parseInt(value);\n      case ArgumentType.Matrix:\n        return Extension.ToMatrix(value);\n      case ArgumentType.Color:\n        return Cast.toRgbColorObject(value) as RGBObject;\n      default:\n        throw new Error(`Method not implemented for value of ${value} and type ${argumentType}`);\n    }\n  }\n\n  private static ConvertMenuItemsToString = (item: any | MenuItem<any>) =>\n    isPrimitive(item) ? `${item}` : { ...item, value: `${item.value}` };\n\n  private static ExtensionsByID = new Map<string, Extension<any, any>>();\n\n  static InternalCodeGenArgsGetterKey = \"internal_getCodeGenArgs\";\n\n  static TestGetInfo = <T extends Extension<any, any>>(ext: T, ...params: Parameters<Extension<any, any>[\"getInfo\"]>) => ext.getInfo(...params);\n  static TestGetBlocks = <T extends Extension<any, any>>(ext: T, ...params: Parameters<Extension<any, any>[\"getInfo\"]>) => ext.getInfo(...params).blocks as ExtensionBlockMetadata[];\n  static TestInit = <T extends Extension<any, any>>(ext: T, ...params: Parameters<Extension<any, any>[\"internal_init\"]>) => ext.internal_init(...params);\n\n  static ExtractLegacyInformation = (item) => !isPrimitive(item) && \"name\" in item ? ({ name: item[\"name\"] as string | undefined }) : undefined;\n\n  static GetLegacyName = <Blocks extends ExtensionBlocks, T extends Extension<any, Blocks>>(ext: T, key: keyof Blocks) => ext.keyByLegacyName?.[key];\n};\n","import type Runtime from '$scratch-vm/engine/runtime';\nimport BlockUtility from '$scratch-vm/engine/block-utility';\nimport { ArgumentType, BlockType, Branch, Language } from './enums';\nimport type { Extension } from './Extension';\n\nexport type InternalButtonKey = \"__button__\";\nexport type ButtonBlock = () => InternalButtonKey;\n\nexport type BaseExtension = Extension<ExtensionMenuDisplayDetails, ExtensionBlocks>;\n\n/**\n * @summary An object passed to extensions on initialization. \n * @description The Environment object should contain anything necessary for an extension to interact with the Scratch/Blockly environment\n * (and can therefore grow and evolve overtime).\n * \n * A good rule of thumb is: If you have to access a nested object on the Runtime more than once, consider adding it to the 'Environment'\n */\nexport type Environment = {\n  /**\n   * The scratch runtime \n   */\n  runtime: Runtime,\n  /**\n   * An example of a convenient property to have on the Environment.\n   * Prior to the Extension Framework, video (and other io) was available via the runtime and thus required overly intimate knowledge of that class. \n   * NOTE: This will have type-safety soon, but currently has none.\n   * @todo #161 \n   */\n  videoFeed: undefined | any\n}\n\n/**\n * Helpful way to specify you want a reference to Extension class itself (not an instance of it) \n */\nexport interface ExtensionConstructor<T extends BaseExtension> {\n  new(...args: ConstructorParameters<typeof Extension>): T;\n}\n\nexport type BlockOperation = (...args: any) => any;\n\nexport type ParameterOf<\n  TExtension extends Extension<any, any>,\n  TBlockKey extends keyof TExtension[\"BlockFunctions\"],\n  TIndex extends number,\n> = Parameters<TExtension[\"BlockFunctions\"][TBlockKey]>[TIndex];\n\nexport type MenuItem<T> = T | {\n  value: T;\n  text: string;\n};\n\nexport type DynamicMenu<T> = () => MenuItem<T>[];\n\nexport type DynamicMenuThatAcceptsReporters<T> = {\n  /**\n   * A function that dynamically retrieves the options for this argument \n   * whenever the associated block is interacted with.\n   */\n  getItems: DynamicMenu<T>,\n  /**\n   * Indicates that this argument is allowed to accept a reporter block for input. \n   */\n  acceptsReporters: true,\n  /**\n   * A function responsible for taking in arbitrary input \n   * and converting it to a form that it will not break your block when passed to it as an argument.\n   * \n   * This function is required because this argument acceptsReporters (i.e.` acceptReporters = true`) and therefore it might receive a value it is not prepared to handle. \n   */\n  handler: (reported: any) => T;\n};\n\nexport type MenuThatAcceptsReporters<T> = {\n  items: MenuItem<T>[],\n  /**\n   * Indicates that this argument is allowed to accept a reporter block for input. \n   */\n  acceptsReporters: true,\n  /**\n   * A function responsible for taking in arbitrary input \n   * and converting it to a form that it will not break your block when passed to it as an argument.\n   * \n   * This function is required because this argument acceptsReporters (i.e. `acceptReporters = true`) and therefore the argument might take on a value your block is not prepared to handle. \n   */\n  handler: (reported: any) => T;\n};\n\nexport type Menu<T> = MenuItem<T>[] | MenuThatAcceptsReporters<T> | DynamicMenu<T> | DynamicMenuThatAcceptsReporters<T>;\n\nexport type VerboseArgument<T> = {\n  type: ScratchArgument<T>;\n  defaultValue?: T | undefined;\n  options?: Menu<T>;\n};\n\nexport type Argument<T> = VerboseArgument<T> | ScratchArgument<T>;\n\nexport type RGBObject = { r: number, g: number, b: number };\nexport type Matrix = boolean[][];\n\nexport type TypeByArgumentType<T extends ValueOf<typeof ArgumentType>> =\n  T extends typeof ArgumentType.Number | typeof ArgumentType.Angle | typeof ArgumentType.Note ? number\n  : T extends typeof ArgumentType.Boolean ? boolean\n  : T extends typeof ArgumentType.String ? string\n  : T extends typeof ArgumentType.Color ? RGBObject\n  : T extends typeof ArgumentType.Matrix ? boolean[][]\n  : T extends typeof ArgumentType.Image ? string // TODO\n  : T extends typeof ArgumentType.Custom ? any\n  : never;\n\nexport type ScratchArgument<T> =\n  T extends RGBObject ? typeof ArgumentType.Color :\n  T extends boolean[][] ? typeof ArgumentType.Matrix :\n  T extends number ? (typeof ArgumentType.Number | typeof ArgumentType.Angle | typeof ArgumentType.Note | typeof ArgumentType.Custom) :\n  T extends string ? (typeof ArgumentType.String | typeof ArgumentType.Custom) :\n  T extends boolean ? (typeof ArgumentType.Boolean | typeof ArgumentType.Custom) :\n  (typeof ArgumentType.Custom);\n\n// Used to be <T extends [...any[]]> ... not sure if it needs to be?\ntype ToArguments<T extends any[]> =\n  T extends [infer Head, ...infer Tail]\n  ? [Argument<Head>, ...ToArguments<Tail>]\n  : [];\n\ntype ParamsAndUtility<T extends BlockOperation> = [...params: Parameters<T>, util: BlockUtility];\n\nexport type NonEmptyArray<T> = [T, ...T[]];\n\nconst enum ArgField {\n  Arg = 'arg',\n  Args = 'args'\n}\n\nexport type Block<TExt extends BaseExtension, TOp extends BlockOperation> = {\n  /**\n   * @type {BlockType}\n   * @example type: BlockType.Command\n   * @example type: BlockType.Reporter\n   * @description\n   * The kind of block we're defining, from a predefined list \n   * (shown below, roughly in order from most-to-least common).\n   * * `BlockType.Command` - A block that accepts 0 or more arguments and likely does something to the sprite / environment (but does not return a value). \n   *    * A function that represents a BlockType.Command block might look like:\n   *      * `example_command: (text: string, value: number) => void`\n   *      * Note the `void` return type\n   *    * For reference, below are built-in blocks that are 'commands'\n   *      * move ___ steps\n   *      * say ____\n   *      * next backdrop\n   * * `BlockType.Reporter` - Accepts 0 or more arguments and returns a value. E.g.\n   *    * A function that represents a BlockType.Command block might look like:\n   *      * `example_reporter: (value: number) => number`\n   *      * Note the non-`void` return type\n   *    * For reference, below are built-in blocks that are 'reporters'\n   *      * x position\n   *      * direction\n   *      * costume [name or number]\n   * * `BlockType.Boolean` - same as 'Reporter' but specifically returns a Boolean value\n   * * `BlockType.Hat` - Starts a stack if its value changes from falsy to truthy\n   * \n   * NOTE: Scratch warns us that the below blocks are still 'in development' and therefore might not work (or at least not work as expected).\n   * * `BlockType.Conditional` - control flow, like \"if {}\" or \"if {} else {}\"\n   *     * A 'Conditional' block may return the one-based index of a branch to\n   *     run, or it may return zero/falsy to run no branch.\n   * * `BlockType.Loop` - control flow, like \"repeat {} {}\" or \"forever {}\"\n   *     * A LOOP block is like a CONDITIONAL block with two differences:\n   *        * the block is assumed to have exactly one child branch, and\n   *        * each time a child branch finishes, the loop block is called again.\n   * * `BlockType.Event` - Starts a stack in response to an event (full spec TBD)\n   */\n  type: ReturnType<TOp> extends ReturnType<ButtonBlock>\n  ? typeof BlockType.Button\n  : ReturnType<TOp> extends void\n  ? typeof BlockType.Command | typeof BlockType.Button | typeof BlockType.Loop\n  : ReturnType<TOp> extends boolean\n  ? (typeof BlockType.Reporter | typeof BlockType.Boolean | typeof BlockType.Hat)\n  : ReturnType<TOp> extends number\n  ? (typeof BlockType.Reporter | typeof BlockType.Conditional)\n  : ReturnType<TOp> extends Promise<any>\n  ? never\n  : typeof BlockType.Reporter;\n\n  /**\n   * @summary A function that encapsulates the code that runs when a block is executed\n   * @description This is where you implement what your block actually does.\n   * \n   * It can/should act on the arguments you specified for this block.\n   * \n   * @example\n   * // An operation that could satisfy a one-liner reporter boock\n   * // (specified with arrow syntax)\n   * operation: (text: string, index: number) => text[index];\n   * \n   * @example\n   * // An operation that could satisfy a  reporter boock\n   * // (specified with arrow syntax)\n   * operation: (dividend: number, divisor: number) => {\n   *  return dividend / divisor;\n   * }\n   * \n   * @example\n   * // An operation that could satisfy a command block\n   * // (specified with method syntax, and leveraging optional final BlockUtility parameter)\n   * operation: function(msg: string, util: BlockUtility) {\n   *  alert(`${msg} ${util.stackFrame.isLoop}`);\n   * }\n   * \n   * @param {BlockUtility} util Unless this block is a `Button`, the final argument passed to this function will always be a BlockUtility object, \n   * which can help you accomplish more advanced block behavior. If you don't need to use it, feel free to omit it.\n   * @see {BlockUtility} type for more information on the final argument passed to this function.\n   */\n  operation: (this: TExt, ...params: TOp extends ButtonBlock ? Parameters<TOp> : ParamsAndUtility<TOp>) => TOp extends ButtonBlock ? void : ReturnType<TOp>;\n  /**\n   * @summary The display text of your block.\n   * @description This is where you describe what your block should say. \n   * \n   * The value that this field takes on depends on if your block takes any arguments or not.\n   * - If your block takes NO arguments, then this field should be a simple string. \n   * - If your block takes one or more arguments, then this field should be a function that takes the same arguments as your block, \n   * and returns a templated string (see below examples for more details). \n   * @example\n   * // Text for a block that takes NO arguments\n   * text: \"Click me! I'm a button!\"\n   * @example\n   * // Text for a block that takes 2 arguments \n   * text: (name: string, age: number) => `My name is ${name} and I'm ${age} years old`\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals for more info on Template Strings (aka Template Literals)\n   */\n  text: Parameters<TOp> extends NonEmptyArray<any> ? (...params: Parameters<TOp>) => string : string;\n} & (Parameters<TOp> extends NonEmptyArray<any>\n  ? Parameters<TOp> extends [any]\n  // NOTE: The above check shouldn't be necessary, and instead a mapped type should be used, but JS Doc comments currently don't work with mapped types:\n  // For example: [K in Parameters<T> extends [any] ? \"arg\" : \"args\"]: Parameters<T> extends [any] ? ToArguments<Parameters<T>>[0] : ToArguments<Parameters<T>>\n  ? {\n    /**\n    * @description The args field should not be defined for blocks that take only one argument\n    */\n    args?: never\n    /**\n     * @summary The Argument your block takes.\n     * \n     * Because there's a couple different pieces to a Scratch Argument \n     * (including it's acceptable values, its UI representation, if it uses a menu, if it can take reporters, etc.),\n     * this field can be more involved than just simply defining the plain argument type for a function, say. \n     * @example \n     * // Only (implicitly) specifying type\n     * arg: ArgumentType.Angle\n     * @example\n     * // Only (explicitly) specifying type\n     * arg: { type: ArgumentType. Angle }\n     * @example \n     * // More verbose specification, with type and default value\n     * arg: { type: ArgumentType.String, defaultValue: 'hello world'}\n     * @example\n     * // More verbose specification with type and options (values only)\n     * arg: { type: ArgumentType.Number, options: [1, 2, 3, 5, 7, 11, 13]}\n     * // Note: we could've also included a defaultValue\n     * @example\n     * // Specifying options more verbosely with text and value\n     * arg: { \n     *  type: ArgumentType.Angle, \n     *  options: [{ text: 'right', value: 90 }, { text: 'left', value: -90 }]\n     * }\n     * \n     * // Advanced examples available below description (including dynamic options aka menus, accepting reporters...)\n     * @description This is where you define the arguments that your block should take. \n     * \n     * Because this field can take on a few different values depending on how you want your block arguments to behave, \n     * it is like best to learn from the examples above (and below).\n     * @example \n     * // ADVANCED\n     * // With options that accepts reporters\n     * arg: { \n     *  type: ArgumentType.Number, \n     *  options: {\n     *    acceptsReporter: true,\n     *    items: [1, 2, 3],\n     *    handler: (x: any) => {\n     *       const parsed = parseInt(x);\n     *       return isNan(parsed) ? 1 : Math.min(Math.max(parsed, 1), 3)\n     *  }\n     * }\n     * @example \n     * // ADVANCED\n     * // Dynamic options\n     * args: {\n     *  type: ArgumentType.Number,\n     *  options: () => [Math.random(), Math.random()]\n     * }\n     * @example \n     * // ADVANCED\n     * // With dynamic options that accepts reporters\n     * args: {\n     *  type: ArgumentType.Number,\n     *  options: {\n     *    acceptsReporter: true,\n     *    getItems: () => [Math.random(), Math.random()],\n     *    handler: (x: any) => {\n     *       const parsed = parseInt(x);\n     *       return isNan(parsed) ? -1 : parsed;\n     *    }\n     *  }\n     * }\n     */\n    arg: ToArguments<Parameters<TOp>>[0]\n  }\n  : {\n    /**\n    * @description The arg field should not be defined for blocks that take more than one argument\n    */\n    arg?: never\n    /**\n     * @summary The Arguments that your block takes.\n     * \n     * Because there's a couple different pieces to a Scratch Argument \n     * (including it's acceptable values, its UI representation, if it uses a menu, if it can take reporters, etc.),\n     * this field can be more involved than just simply defining the plain argument types for a function, say. \n     * @example \n     * // Below is an args array that shows the different ways to specify arguments.\n     * args: [\n     *  ArgumentType.String, // Only (implicitly) specifying type\n     *  { // Only (explicitly) specifying type\n     *    type: ArgumentType.Angle \n     *  },  \n     *  { // Specifying type and default value\n     *    type: ArgumentType.String, \n     *    defaultValue: 'hello world'\n     *  }, \n     *  { // Specifying type and options (with values only)\n     *    type: ArgumentType.Number, \n     *    options: [1, 2, 3, 5, 7, 11, 13]\n     *  }, \n     *  { // Specifying type, default value, and options (with values and text)\n     *    type: ArgumentType.Angle, \n     *    defaultValue: -90, \n     *    options: [{ text: 'right', value: 90 }, { text: 'two', value: -90 }]\n     *  } \n     * ]\n     * \n     * // Advanced examples are available below description (include dynamic options aka menus, accepting reporters...)\n     * \n     * @description This is where you define the arguments that your block should take. \n     * \n     * Because this field can take on a few different values depending on how you want your block arguments to behave, \n     * it is likely best to learn from the examples above (and below).\n     * @example \n     * // ADVANCED\n     * args: [\n     *  { // Dynamic options\n     *    type: ArgumentType.Number,\n     *    options: () => [Math.random(), Math.random()]\n     *  }, \n     *  { // With options that accepts reporters\n     *    type: ArgumentType.Number, \n     *    options: {\n     *      acceptsReporter: true,\n     *      items: [1, 2, 3],\n     *      handler: (x: any) => {\n     *        const parsed = parseInt(x);\n     *        return isNan(parsed) ? 1 : Math.min(Math.max(parsed, 1), 3)\n     *      } \n     *    }\n     *  }, \n     *  { // With dynamic options that accepts reporters\n     *    type: ArgumentType.Number,\n     *    options: {\n     *      acceptsReporter: true,\n     *      getItems: () => [Math.random(), Math.random()],\n     *      handler: (x: any) => {\n     *        const parsed = parseInt(x);\n     *        return isNan(parsed) ? -1 : parsed;\n     *      }\n     *    }\n     *  } \n     * ]\n     */\n    args: ToArguments<Parameters<TOp>>\n  }\n  : {\n    /**\n     * @description The args field should not be defined for blocks that take no arguments\n     */\n    args?: never\n    arg?: never\n  });\n\n/**\n * How an extension should display in the extensions menu.\n * \n * IMPORTANT! You can NOT use template literal types. \n * @link https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html (Not allowed!)\n */\nexport type ExtensionMenuDisplayDetails = {\n  name: string;\n  description: string;\n  iconURL: string;\n  insetIconURL: string;\n  internetConnectionRequired?: boolean;\n  collaborator?: string;\n  bluetoothRequired?: boolean;\n  launchPeripheralConnectionFlow?: boolean;\n  useAutoScan?: boolean;\n  connectionIconURL?: string;\n  connectionSmallIconURL?: string;\n  connectionTipIconURL?: string;\n  connectingMessage?: string;\n  helpLink?: string;\n  featured?: boolean;\n  hidden?: boolean;\n  disabled?: boolean;\n  implementationLanguage?: ValueOf<typeof Language>;\n} & Partial<Record<ValueOf<typeof Language>, { name: string, description: string }>>\n\nexport type DefineBlock<TExt extends BaseExtension, TOp extends BlockOperation> = ((extension: TExt) => Block<TExt, TOp>) | Block<TExt, TOp>;\n\nexport type ExtensionBlocks = Record<string, BlockOperation>;\n\nexport type BlockDefinitions<T extends BaseExtension> =\n  {\n    [k in keyof T[\"BlockFunctions\"]]: T[\"BlockFunctions\"][k] extends\n    (...args: infer A) => infer R\n    ? DefineBlock<T, (...args: A) => R>\n    : never\n  };\n\nexport type BlocksInfo<T extends BaseExtension> = {\n  [k in keyof T[\"BlockFunctions\"]]: T[\"BlockFunctions\"][k] extends\n  (...args: infer A) => infer R\n  ? Block<T, (...args: A) => R>\n  : never\n};\n\nexport type BlockInfo<TExtension extends BaseExtension, TKey extends keyof BlocksInfo<TExtension>> = BlocksInfo<TExtension>[TKey];\n\ntype ArgsTextCommon = {\n  options?: (string)[]\n}\n\ntype ArgsText<T> = T extends ScratchArgument<string> | VerboseArgument<string>\n  ? ({\n    defaultValue?: string,\n  } & ArgsTextCommon)\n  : ArgsTextCommon;\n\ntype ToArgumentsText<T extends any[]> =\n  T extends [infer Head, ...infer Tail]\n  ? [ArgsText<Head>, ...ToArgumentsText<Tail>]\n  : [];\n\n\ntype ExtractTextFromBlock<TOp extends BlockOperation, TBlock extends Block<BaseExtension, TOp>> =\n  TBlock[\"args\"] extends never\n  ? TBlock[\"arg\"] extends never\n  ? string | { blockText: TBlock[\"text\"] }\n  : {\n    blockText: TBlock[\"text\"],\n    argsText?: ArgsText<TBlock[\"arg\"]>,\n  }\n  : TBlock[\"text\"] extends (...args: [any]) => any\n  ? {\n    blockText: TBlock[\"text\"],\n    argsText?: ToArgumentsText<TBlock[\"args\"]>,\n  }\n  : never // shouldn't happen\n\nexport type AllText<T extends Extension<any, any>> = {\n  [k in keyof T[\"BlockFunctions\"]]: ExtractTextFromBlock<T[\"BlockFunctions\"][k], Block<BaseExtension, T[\"BlockFunctions\"][k]>>\n};\n\nexport type Translations<T extends Extension<any, any>> = Partial<{ [k in ValueOf<typeof Language>]: AllText<T> | undefined }>;\n\ntype UnionToIntersection<U> = (\n  U extends never ? never : (arg: U) => never\n) extends (arg: infer I) => void\n  ? I\n  : never;\n\nexport type UnionToTuple<T> = UnionToIntersection<\n  T extends never ? never : (t: T) => T\n> extends (_: never) => infer W\n  ? readonly [...UnionToTuple<Exclude<T, W>>, W]\n  : readonly [];\n\nexport type KeysWithValuesOfType<T, V> = keyof { [P in keyof T as T[P] extends V ? P : never]: P };\n\nexport type RequiredKeys<T> = { [K in keyof T]-?: {} extends Pick<T, K> ? never : K }[keyof T];\nexport type OptionalKeys<T> = { [K in keyof T]-?: {} extends Pick<T, K> ? K : never }[keyof T];\n\n// Type definitions for scratch-vm (extension environment) 3.0\n// Project: https://github.com/LLK/scratch-vm#readme\n// Definitions by: Richie Bendall <https://github.com/Richienb>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.9\n\nexport type ValueOf<ObjectType> = ObjectType[keyof ObjectType];\n\n/**\n * Raw extension block data paired with processed data ready for scratch-blocks\n */\nexport type ConvertedBlockInfo = {\n  /**\n   * the raw block info\n   */\n  info: ExtensionBlockMetadata;\n  /**\n   * the scratch-blocks JSON definition for this block\n   */\n  json: Object;\n  /**\n   * the scratch-blocks XML definition for this block\n   */\n  xml: string;\n}\n\n/**\n * Information about a block category\n */\nexport type CategoryInfo = {\n  /**\n   * the unique ID of this category\n   */\n  id: string;\n  /**\n   * the human-readable name of this category\n   */\n  name: string;\n  /**\n   * optional URI for the block icon image\n   */\n  blockIconURI?: string;\n  /**\n   * the primary color for this category, in '#rrggbb' format\n   */\n  color1: string;\n  /**\n   * the secondary color for this category, in '#rrggbb' format\n   */\n  color2: string;\n  /**\n   * the tertiary color for this category, in '#rrggbb' format\n   */\n  color3: string;\n  /**\n   * the blocks, separators, etc. in this category\n   */\n  blocks: ConvertedBlockInfo[];\n  /**\n   * the menus provided by this category\n   */\n  menus: Object[];\n  customFieldTypes?: any;\n  showStatusButton?: boolean;\n  menuIconURI?: string;\n}\n\n/** All the metadata needed to register an extension. */\nexport interface ExtensionMetadata {\n  /** A unique alphanumeric identifier for this extension. No special characters allowed. */\n  id: string;\n\n  /** The human-readable name of this extension. */\n  name?: string | undefined;\n\n  /** URI for an image to be placed on each block in this extension. Data URI ok. */\n  blockIconURI?: string | undefined;\n\n  /** URI for an image to be placed on this extension's category menu item. Data URI ok. */\n  menuIconURI?: string | undefined;\n\n  /** Link to documentation content for this extension. */\n  docsURI?: string | undefined;\n\n  /** The blocks provided by this extension and the separators. */\n  blocks: readonly ExtensionBlockMetadata[] | readonly string[];\n\n  /** Map of menu name to metadata for each of this extension's menus. */\n  menus?: Record<string, ExtensionMenuMetadata> | undefined;\n}\n\n/** All the metadata needed to register an extension block. */\nexport interface ExtensionBlockMetadata {\n  /** A unique alphanumeric identifier for this block. No special characters allowed. */\n  opcode: string;\n\n  /** The name of the function implementing this block. Can be shared by other blocks/opcodes. */\n  func?: string | undefined;\n\n  /** The type of block (command, reporter, etc.) being described. */\n  blockType: ValueOf<typeof BlockType>;\n\n  /** The text on the block, with [PLACEHOLDERS] for arguments. */\n  text: string;\n\n  /** Whether this block should not appear in the block palette. */\n  hideFromPalette?: boolean | undefined;\n\n  /** Whether the block ends a stack - no blocks can be connected after it. */\n  isTerminal?: boolean | undefined;\n\n  /** Whether this block is a reporter but should not allow a monitor. */\n  disableMonitor?: boolean | undefined;\n\n  /** If this block is a reporter, this is the scope/context for its value. */\n  reporterScope?: ReporterScope | undefined;\n\n  /** Whether a hat block is edge-activated. */\n  isEdgeActivated?: boolean | undefined;\n\n  /** Whether a hat/event block should restart existing threads. */\n  shouldRestartExistingThreads?: boolean | undefined;\n\n  /** For flow control blocks, the number of branches/substacks for this block. */\n  branchCount?: number | undefined;\n\n  /** Map of argument placeholder to metadata about each arg. */\n  arguments?: Record<string, ExtensionArgumentMetadata> | undefined;\n}\n\n/** All the metadata needed to register an argument for an extension block. */\nexport interface ExtensionArgumentMetadata {\n  /** The type of the argument (number, string, etc.) */\n  type: ValueOf<typeof ArgumentType>;\n\n  /** The default value of this argument. */\n  defaultValue?: any;\n\n  /** The name of the menu to use for this argument, if any. */\n  menu?: string | undefined;\n}\n\n/** All the metadata needed to register an extension drop-down menu. */\nexport type ExtensionMenuMetadata = ExtensionDynamicMenu | ExtensionMenuItems;\n\n/** The string name of a function which returns menu items. */\nexport type ExtensionDynamicMenu = string;\n\n/** Items in an extension menu. */\nexport type ExtensionMenuItems = {\n  items: readonly ExtensionMenuItemSimple[] | readonly ExtensionMenuItemComplex[] | ExtensionDynamicMenu,\n  acceptReporters: boolean\n};\n\n/** A menu item for which the label and value are identical strings. */\nexport type ExtensionMenuItemSimple = string;\n\n/** A menu item for which the label and value can differ. */\nexport interface ExtensionMenuItemComplex {\n  /** The value of the block argument when this menu item is selected. */\n  value: any;\n\n  /** The human-readable label of this menu item in the menu. */\n  text: string;\n}\n\nexport type ScratchExtension = {\n  /** Returns data about the extension. */\n  getInfo(): ExtensionMetadata;\n}\n\n/** Indicate the scope for a reporter's value. */\ndeclare enum ReporterScope {\n  /** This reporter's value is global and does not depend on context. */\n  GLOBAL = \"global\",\n\n  /**\n   * This reporter's value is specific to a particular target/sprite.\n   * Another target may have a different value or may not even have a value.\n   */\n  TARGET = \"target\"\n}\n\n","const validRegEx = new RegExp('^[a-z0-9]+$', 'i');\nconst invalidRegEx = new RegExp('[^a-z0-9]+', 'gi');\n\nexport const isValidID = (id) => validRegEx.test(id);\n\nconst guard = 'prg';\nconst guards = [guard, guard.split(\"\").reverse().join(\"\")];\n\nconst guardsRegEx = new RegExp(`${guards[0]}([0-9]+)${guards[1]}`, 'g');\n\nconst wrap = (str) => `${guards[0]}${str}${guards[1]}`;\n\nconst replaceAll = (query, current, desired) => query.replaceAll(current, desired);\n\nexport const encode = (query: string): string => {\n  const matches = [...query.matchAll(invalidRegEx)];\n  const invalidCharacters = matches.reduce((set, current) => {\n    current[0].split(\"\").forEach(char => set.add(char));\n    return set;\n  }, new Set<string>());\n  const replacements = [...invalidCharacters].map(char => ({ char, code: char.charCodeAt(0) }));\n  return replacements.reduce((modified, { char, code }) => replaceAll(modified, char, wrap(code)), `${query}`);\n}\n\nexport const decode = (query: string): string => {\n  const matches = [...query.matchAll(guardsRegEx)];\n  const replacements = matches.reduce((replacements, match) => {\n    const [key, code] = match;\n    return replacements.set(key, String.fromCharCode(code as any as number));\n  }, new Map());\n  return [...replacements].reduce((modified, [current, desired]) => replaceAll(modified, current, desired), `${query}`);\n}","import { BaseExtension, Block, ExtensionBlockMetadata, ExtensionMetadata, ExtensionMenuItems, DynamicMenu, DynamicMenuThatAcceptsReporters, MenuItem, MenuThatAcceptsReporters, TypeByArgumentType, ValueOf, VerboseArgument, Argument } from \"./types\";\nimport { ArgumentType } from \"./enums\";\nimport { isFunction, isPrimitive, isString } from \"./utils\";\n\nexport type SerializedBlockData = Pick<ExtensionMetadata, \"blocks\" | \"menus\">;\n\nexport const mockFormatMessage = (args: { id: string, default: string, description: string }): string => \"\";\n\ntype Opcodes<T extends SerializedBlockData> = { [k in keyof T[\"blocks\"]]: T[\"blocks\"][k] extends ExtensionBlockMetadata ? T[\"blocks\"][k][\"opcode\"] : never }[number];\n\ntype Arguments<A extends ExtensionMetadata[\"blocks\"], Opcode extends string> = {\n  [E in keyof A as A[E] extends { opcode: infer K extends Opcode } ? K : never]: A[E] extends ExtensionBlockMetadata ? A[E]['arguments'] : never;\n};\n\ntype Type<A extends ExtensionMetadata[\"blocks\"], Opcode extends string> = {\n  [E in keyof A as A[E] extends { opcode: infer K extends Opcode } ? K : never]: A[E] extends ExtensionBlockMetadata ? A[E]['blockType'] : never;\n}\n\ntype MappedToBlockDefinition<T extends SerializedBlockData> = { [k in Opcodes<T>]:\n  {\n    type: Type<T[\"blocks\"], k>[keyof Type<T[\"blocks\"], k>],\n  } & (TsMagic.ObjValueTuple<Arguments<T[\"blocks\"], k>[keyof Arguments<T[\"blocks\"], k>]> extends { length: 0 }\n    ? {}\n    : TsMagic.ObjValueTuple<Arguments<T[\"blocks\"], k>[keyof Arguments<T[\"blocks\"], k>]> extends { length: 1 }\n    ? { arg: MapToArgument<TsMagic.ObjValueTuple<Arguments<T[\"blocks\"], k>[keyof Arguments<T[\"blocks\"], k>]>>[0], }\n    : { args: MapToArgument<TsMagic.ObjValueTuple<Arguments<T[\"blocks\"], k>[keyof Arguments<T[\"blocks\"], k>]>>, })\n};\n\ntype WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] }\n\ntype MapToArgument<T extends unknown[]> = T extends [] ? [] :\n  T extends [infer H, ...infer R] ?\n  H extends { type: infer X extends ValueOf<typeof ArgumentType> }\n  ? H extends { menu: string }\n  ? [WithRequired<VerboseArgument<TypeByArgumentType<X>>, \"options\">, ...MapToArgument<R>]\n  : [VerboseArgument<TypeByArgumentType<X>>, ...MapToArgument<R>]\n  : MapToArgument<R> : T\n\ntype WithName = { name: string };\n\nconst processArg = (arg: VerboseArgument<any> & WithName, argName: string, menuName: string, menus: ExtensionMetadata[\"menus\"], blockName: string) => {\n  arg.name = argName;\n  if (!menuName) return;\n\n  (arg.options as WithName).name = menuName;\n  const menuEntry = menus[menuName];\n  if (!menuEntry) return;\n\n  const legacyAcceptReporters = (menuEntry as ExtensionMenuItems).acceptReporters;\n  const updatedAcceptReporters = (arg.options as MenuThatAcceptsReporters<any>).acceptsReporters ?? false;\n  if (legacyAcceptReporters !== updatedAcceptReporters) {\n    throw new Error(`The new options provided for the legacy block '${blockName}' for legacy argument '${argName}' ${legacyAcceptReporters ? \"should\" : \"should NOT\"} accept reporters`);\n  }\n\n  const oldItems = (menuEntry as ExtensionMenuItems).items as MenuItem<any>[];\n  if (!oldItems || oldItems.length === 0) return;\n\n  const newItems: MenuItem<any>[] = Array.isArray(arg.options)\n    ? (arg.options as MenuItem<any>[])\n    : isFunction(arg.options)\n      ? (arg.options as DynamicMenu<any>)()\n      : (arg.options as MenuThatAcceptsReporters<any>).items\n        ? (arg.options as MenuThatAcceptsReporters<any>).items\n        : (arg.options as DynamicMenuThatAcceptsReporters<any>).getItems();\n\n  const expand = (item: MenuItem<any>) => isPrimitive(item) ? ({ text: `${item}`, value: item }) : item as { value: any; text: string; };\n  const serialize = (item: any) => JSON.stringify(item);\n\n  const oldItemsExpanded = oldItems.map(expand).map(serialize);\n  const newItemsExpand = newItems.map(expand).map(serialize);\n\n  for (const oldItem of oldItemsExpanded) {\n    if (!newItemsExpand.includes(oldItem)) {\n      throw new Error(`Mismatch in old and new menus for block ${blockName}: arg ${argName}. Old entry: ${oldItem}, new entries: [${newItemsExpand.join(\", \")}]`)\n    }\n  }\n}\n\nconst attachNames = <T extends SerializedBlockData, TKey extends Opcodes<T>, TBlock>(\n  name: TKey,\n  block: TBlock & MappedToBlockDefinition<T>[TKey],\n  legacyBlock: ExtensionBlockMetadata,\n  menus: ExtensionMetadata[\"menus\"]\n): TBlock => {\n  type AnyBlock = Block<BaseExtension, ((...args: any[]) => any) | ((arg: any) => any) | (() => any)>;\n  const asBlock = block as any as AnyBlock;\n  (block as any as WithName).name = name;\n\n  if (\"arg\" in asBlock) {\n    const [key, { menu }] = Object.entries(legacyBlock.arguments)[0];\n    processArg(asBlock.arg, key, menu, menus, name);\n  }\n  else if (\"args\" in asBlock) {\n    const entries = Object.entries(legacyBlock.arguments);\n    for (let index = 0; index < entries.length; index++) {\n      const [key, { menu }] = entries[index];\n      processArg(asBlock.args[index], key, menu, menus, name);\n    }\n  }\n\n  return block;\n}\n\ntype LegacySupport<T extends SerializedBlockData> =\n  { [k in Opcodes<T>]: <TBlock extends MappedToBlockDefinition<T>[k]>(block: TBlock) => TBlock }\n  & { tsIgnore: { [k in Opcodes<T>]: <TBlock>(block: TBlock) => TBlock } }\n  & { legacyBlocksForTests: { [k in Opcodes<T>]: ExtensionBlockMetadata } }\n\n/**\n * \n * @param data The object returned by a vanilla-javascript extension's `getInfo` method\n * @returns An object where the keys are the 'opcodes' of the blocks provided as an argument this function. \n * The value for each key is a function that, when applied to a block definition, \n * adds the necessary legacy support so old projects will load correctly. \n */\nexport const extractLegacySupportFromOldGetInfo = <T extends SerializedBlockData>(data: T): LegacySupport<T> => {\n  const { blocks, menus } = data;\n\n  const mapper: LegacySupport<T> = ((blocks as ExtensionBlockMetadata[]).filter(block => !isString(block)) as ExtensionBlockMetadata[])\n    .map(block => {\n      const opcode = block.opcode as Opcodes<T>;\n      return [opcode, (b) => attachNames<T, typeof opcode, typeof b>(block.opcode as Opcodes<T>, b, block, menus)];\n    })\n    .reduce((acc, [key, func]) => {\n      acc[key] = func;\n      return acc;\n    }, {} as any);\n\n  mapper[\"tsIgnore\"] = mapper as any as LegacySupport<T>[\"tsIgnore\"];\n\n  mapper.legacyBlocksForTests = (blocks as ExtensionBlockMetadata[]).reduce((acc, block) => {\n    acc[block.opcode] = block;\n    return acc;\n  }, {} as LegacySupport<T>[\"legacyBlocksForTests\"]);\n\n  return mapper;\n};\n\n/**\n * As is made very clear in the stack overflow from which this code is taken, \n * THIS IS AN ABUSE OF TYPESCRIPT:\n * https://stackoverflow.com/questions/55127004/how-to-transform-union-type-to-tuple-type/55128956#55128956\n * https://stackoverflow.com/questions/52855145/typescript-object-type-to-array-type-tuple\n */\nnamespace TsMagic {\n  export type UnionToIntersection<U> =\n    (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never\n  type LastOf<T> =\n    UnionToIntersection<T extends any ? () => T : never> extends () => (infer R) ? R : never\n\n  export type Push<T extends any[], V> = [...T, V];\n\n  export type TuplifyUnion<T, L = LastOf<T>, N = [T] extends [never] ? true : false> =\n    true extends N ? [] : Push<TuplifyUnion<Exclude<T, L>>, L>\n\n  export type ObjValueTuple<T, KS extends any[] = TuplifyUnion<keyof T>, R extends any[] = []> =\n    KS extends [infer K, ...infer KT]\n    ? ObjValueTuple<T, KT, [...R, T[K & keyof T]]>\n    : R\n}\n\n","import { BaseExtension, ExtensionConstructor } from \"./types\";\nimport { ExtensionBase } from \"./ExtensionV2\";\nimport { ExtensionConstructor as ExtensionConstructorV2 } from \"./ExtensionMixins\";\n\n\n/**\n * @summary Utility class to assist in creating a (typesafe) object that, for a given Extension type, handles both:\n * - writing out data on save\n * - doing something with save data on load\n * \n * @description This class's constructor takes an object with both an `onSave` and an `onLoad` method\n * (and the `onSave`'s return type must match `onLoad`'s argument type)\n * @example\n * new SaveDataHandler({\n *    Extension: MyExtension,\n *    onSave: () => ({x: 0, y: 3}),\n *    onLoad: (data) => {\n *       const sum = data.x + data.y; // do something with saved data\n *    }\n * })\n */\nexport class SaveDataHandler<T extends BaseExtension | ExtensionBase, TData> {\n  constructor(public hooks: {\n    // @ts-ignore\n    Extension: ExtensionConstructor<T> | ExtensionConstructorV2,\n    onSave: (self: T) => TData,\n    onLoad: (self: T, data: TData) => void,\n  }) { }\n}"],"names":["ExtensionFramework","exports","BlockType","Boolean","Button","Command","Conditional","Event","Hat","Loop","Reporter","ArgumentType","Angle","Color","Number","String","Matrix","Note","Image","Custom","StageLayering","BackgroundLayer","VideoLayer","PenLayer","SpriteLayer","LayerGroups","Language","Azeri","Bahasa_Indonesia","Cymraeg","Dansk","Deutsch","Eesti","English","Euskara","Gaeilge","Galego","Hrvatski","isiZulu","Italiano","Kiswahili","Magyar","Nederlands","Norsk_Nynorsk","Polski","Rapa_Nui","Suomi","Svenska","LanguageKeys","Object","keys","RGB_BLACK","r","g","b","RGB_WHITE","static","decimal","hex","toString","substr","length","a","replace","m","result","exec","parseInt","rgb","decimalToHex","rgbToDecimal","hexToRgb","hsv","h","s","Math","max","min","v","i","floor","f","p","q","t","x","rgb0","rgb1","fraction1","fraction0","Cast","value","isNaN","n","toLowerCase","color","toRgbColorObject","substring","decimalToRgb","toNumber","val","trim","v1","v2","n1","n2","isWhiteSpace","NaN","s1","s2","Infinity","indexOf","LIST_INVALID","LIST_ALL","index","acceptAll","random","cast","openUIEvent","registerButtonCallbackEvent","customArgumentFlag","customArgumentCheck","dropdownStateFlag","dropdownEntryFlag","initDropdownState","openDropdownState","closeDropdownState","openUI","runtime","details","emit","registerButtonCallback","buttonID","callback","on","CssVar","constructor","root","this","get","parts","join","primary","secondary","tertiary","transparent","light","ui","text","motion","red","sound","control","data","pen","error","extensions","drop","modalOverlay","white","whiteDim","whiteTransparent","blackTransparent","primaryTransparent","lightTansparent","highlight","async","untilObject","getter","delay","timeout","Promise","resolve","clearTimeout","setTimeout","isString","query","isFunction","prototype","call","Function","isPrimitive","identity","untilExternalScriptLoaded","url","scriptLoaded","reject","script","document","createElement","onload","onerror","src","body","appendChild","centerDropdownButton","container","style","margin","paddingLeft","paddingRight","textAlign","forEach","className","styleMod","elements","getElementsByClassName","console","assert","callingContext","DrowpdownOpen","DropdownClose","Init","isCustomArgumentHack","arr","item","processCustomArgumentHack","getComponent","id","extensionID","customArgumentManager","argumentManager","component","initialID","JSON","parse","getCurrentEntries","tryResolve","entry","currentEntry","prevID","lhs","ops","lastAccessLHS","op","fn","args","undefined","_optionalChain","_","rhsFn","current","getEntry","setEntry","request","compononentConstructor","props","dropdownContainerClass","target","anchor","children","renderToDropdown","setter","extension","Error","CustomArgumentManager","__init","__init2","map","Map","pending","clearPending","setPending","update","add","GetIdentifier","set","insert","Array","from","entries","filter","SaveKey","requiresSave","size","saveTo","obj","loadFrom","_2","_3","_4","purgeStaleIDs","IsIdentifier","startsWith","IdentifierPrefix","Date","getTime","_nullishCoalesce","__initStatic","__initStatic2","__initStatic3","__initStatic4","Extension","saveDataHandler","internal_blocks","__init3","internal_menus","__init4","keyByLegacyName","__init5","SaveDataKey","save","toSave","extensionIDs","saveData","hooks","onSave","_5","_6","_7","load","saved","_8","_9","onLoad","_10","label","name","codeGenArgs","__init6","__init7","__init8","blockIconURI","InternalCodeGenArgsGetterKey","ExtensionsByID","internal_init","init","videoFeed","_11","_12","ioDevices","_13","video","definitions","defineBlocks","menus","menuNames","key","block","info","convertToInfo","push","menu","acceptReporters","isArray","items","addStaticMenu","getItems","addDynamicMenu","nonDynamic","dynamicMenu","getInfo","blocks","values","reduce","ConvertMenuItemsToString","menusToAdd","type","operation","arg","legacyInfo","ExtractLegacyInformation","isLegacy","displayText","orderedNames","ConvertToDisplayText","argumentsInfo","handlers","ConvertToArgumentInfo","opcode","GetInternalKey","bound","bind","isButton","GetButtonID","registerOpcode","blockType","arguments","func","format","identifier","description","argsFromScratch","blockUtility","casted","slice","param","GetArgumentType","handler","CastToType","GetExtensionByID","has","TryCastToArgumentType","argumentType","onFailure","e2","makeCustomArgument","initial","acceptReportersHandler","stringify","defaultValue","options","acceptsReports","GetKeyFromOpcode","ext","resolvedText","fill","element","_14","_15","_16","GetArgTranslationID","alreadyAddedIndex","alreadyAdded","menuIndex","_17","_18","_19","accumulation","blockname","ToFlag","ToMatrix","matrixString","split","matrix","flag","row","parseFloat","TestGetInfo","params","TestGetBlocks","TestInit","GetLegacyName","_20","_21","ArgField","__initStatic5","__initStatic6","__initStatic7","__initStatic8","__initStatic9","__initStatic10","__initStatic11","__initStatic12","__initStatic13","__initStatic14","__initStatic15","__initStatic16","__initStatic17","__initStatic18","__initStatic19","validRegEx","RegExp","invalidRegEx","guards","reverse","guardsRegEx","replaceAll","desired","processArg","argName","menuName","blockName","menuEntry","legacyAcceptReporters","acceptsReporters","oldItems","newItems","expand","serialize","oldItemsExpanded","newItemsExpand","oldItem","includes","Branch","Exit","Enter","First","Second","Third","Fourth","Fifth","Sixth","Seventh","FrameworkID","RuntimeEvent","ScriptGlowOn","ScriptGlowOff","BlockGlowOn","BlockGlowOff","HasCloudDataUpdate","TurboModeOn","TurboModeOff","RecordingOn","RecordingOff","ProjectStart","ProjectRunStart","ProjectRunStop","ProjectStopAll","StopForTarget","VisualReport","ProjectLoaded","ProjectChanged","ToolboxExtensionsNeedUpdate","TargetsUpdate","MonitorsUpdate","BlockDragUpdate","BlockDragEnd","ExtensionAdded","ExtensionFieldAdded","PeripheralListUpdate","PeripheralConnected","PeripheralDisconnected","PeripheralRequestError","PeripheralConnectionLostError","PeripheralScanTimeout","MicListening","BlocksInfoUpdate","RuntimeStarted","RuntimeDisposed","BlocksNeedUpdate","SaveDataHandler","ScratchBlocksConstants","OutputShapeHexagonal","OutputShapeRound","OutputShapeSquare","TargetType","Sprite","Stage","VariableType","Scalar","List","BrooadcastMessage","activeClass","copyTo","source","decode","matchAll","replacements","match","code","fromCharCode","modified","encode","char","Set","charCodeAt","extractLegacySupportFromOldGetInfo","mapper","legacyBlock","asBlock","attachNames","acc","legacyBlocksForTests","fetchWithTimeout","resource","controller","AbortController","abort","response","fetch","signal","getTextFromMenuItem","getValueFromMenuItem","isValidID","test","loadExternalScript","onError","mockFormatMessage","px","numberOf","reactiveInvoke","extensionAssignment","funcName","reactiveSet","propertyName","splitOnCapitals","untilCondition","condition","untilExternalGlobalVariableLoaded","globalVariableName","window","untilReady","ready","defineProperty"],"mappings":"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"}