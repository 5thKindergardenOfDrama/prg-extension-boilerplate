{"version":3,"file":"onnxTest.js","sources":["../../../../extensions/src/common/utils.ts","../../../../extensions/src/common/onnx/index.ts","../../../../extensions/src/onnxTest/index.ts"],"sourcesContent":["import { MenuItem, Primitive } from \"./types\"\n\ntype FetchParams = {\n  request: Parameters<typeof fetch>[0],\n  options: Parameters<typeof fetch>[1]\n}\n\nexport const getValueFromMenuItem = <T>(item: MenuItem<T>) => typeof item === \"object\" ? (item as { value: T }).value : item;\n\nexport const getTextFromMenuItem = <T>(item: MenuItem<T>) => typeof item === \"object\" ? (item as { text: string }).text : item;\n\nexport async function fetchWithTimeout(\n  resource: FetchParams[\"request\"],\n  options: FetchParams[\"options\"] & { timeout: number }\n) {\n  const { timeout } = options;\n\n  const controller = new AbortController();\n  const id = setTimeout(() => controller.abort(), timeout);\n\n  const response = await fetch(resource, {\n    ...options,\n    signal: controller.signal\n  });\n\n  clearTimeout(id);\n\n  return response;\n}\n\nexport async function untilObject<T>(getter: () => T, delay: number = 100): Promise<T> {\n  let timeout: NodeJS.Timeout;\n  let value: T = getter();\n  while (!value) {\n    await new Promise(resolve => {\n      clearTimeout(timeout);\n      timeout = setTimeout(resolve, delay);\n    });\n    value = getter();\n  }\n  clearTimeout(timeout);\n  return value;\n}\n\nexport async function untilCondition(condition: () => boolean, delay: number = 100): Promise<void> {\n  let timeout: NodeJS.Timeout;\n  while (!condition()) {\n    await new Promise(resolve => {\n      clearTimeout(timeout);\n      timeout = setTimeout(resolve, delay);\n    });\n  }\n  clearTimeout(timeout);\n};\n\nexport async function untilReady<T extends { ready: boolean }>(obj: T, delay: number = 100): Promise<void> {\n  let timeout: NodeJS.Timeout;\n  while (!obj.ready) {\n    await new Promise(resolve => {\n      clearTimeout(timeout);\n      timeout = setTimeout(resolve, delay);\n    });\n  }\n  clearTimeout(timeout);\n};\n\nexport const isString = (query: any): query is string => typeof query === 'string' || query instanceof String;\n\nexport const isFunction = (query: any): query is (...args: any[]) => any =>\n  Object.prototype.toString.call(query) === \"[object Function]\"\n  || \"function\" === typeof query\n  || query instanceof Function;\n\nexport const isPrimitive = (query: any): query is Primitive => query !== Object(query);\n\nexport const splitOnCapitals = (query: string) => query.split(/(?=[A-Z])/);\n\n/**\n * A type safe utility function for copy values from one object to another\n * @param param0 object containing the target to copy values to and the source of the values to copy\n */\nexport const copyTo = <TTarget extends object, TSource extends { [k in keyof TTarget]?: TTarget[k] }>({ target, source }: { target: TTarget, source: TSource }) => {\n  for (const key in source) {\n    if (!(key in target)) continue;\n    // @ts-ignore -- the types of the function should ensure this is valid TS\n    target[key] = source[key]\n  }\n}\n\nexport const identity = (x: any) => x;\n\nexport const loadExternalScript = (url: string, onLoad: () => void, onError?: () => void) => {\n  const script = document.createElement('script');\n\n  script.onload = onLoad;\n\n  script.onerror = onError ?? (() => {\n    throw new Error(`Error loading endpoint: ${url}`)\n  });\n\n  script.src = url;\n  script.async = true;\n\n  document.body.appendChild(script);\n}\n\n/**\n * \n * @param url \n * @returns \n */\nexport const untilExternalScriptLoaded = async (url: string): Promise<void> => {\n  const scriptLoaded = new Promise((resolve, reject) => {\n    const script = document.createElement('script');\n    script.onload = resolve;\n    script.onerror = reject;\n    script.async = true;\n    script.src = url;\n    document.body.appendChild(script);\n  });\n  await scriptLoaded;\n  return;\n}\n\n/**\n * \n * @param url \n * @param globalVariableName \n * @returns \n */\nexport const untilExternalGlobalVariableLoaded = async <T>(url: string, globalVariableName: string): Promise<T> => {\n  if (window[globalVariableName]) return window[globalVariableName];\n  await untilExternalScriptLoaded(url);\n  return window[globalVariableName];\n}\n\n/**\n * Utilize javascript's \"call\" method (on Function.prototype) in a typesafe manner\n * @param fn \n * @param _this \n * @param args \n * @returns \n */\nexport const typesafeCall = <Args extends any[], Return, This, Fn extends (this: This, ...args: Args) => Return>(fn: Fn, _this: This, ...args: Args) => fn.call(_this, ...args) as Return;\n\nexport const set = <T extends object, K extends keyof T>(container: T, key: K, value: T[K]) => {\n  container[key] = value;\n  return container;\n}","import { loadExternalScript, untilReady } from \"$common/utils\";\nimport * as ort from \"onnxruntime-web\";\n\ntype OnWindow = { ort: typeof ort };\n\nexport class OnnxRuntime {\n  static FromCDN = \"https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js\";\n\n  ready = false;\n  private onnx: typeof ort;\n\n  get runtime(): Promise<typeof ort> { return untilReady(this).then(() => this.onnx); }\n\n  private get globalOnnx() { return (window as any as OnWindow).ort }\n\n  constructor() {\n    const onnx = this.globalOnnx;\n    onnx ? this.resolve() : loadExternalScript(OnnxRuntime.FromCDN, this.resolve.bind(this));\n  }\n\n  private resolve() {\n    this.ready = true;\n    this.onnx = this.globalOnnx;\n  }\n}","import { BlockType, Extension, Environment, } from \"$common\";\nimport { OnnxRuntime } from \"$common/onnx\";\n\ntype Details = {\n  name: \"Onnx Example\",\n  description: \"A demonstration that an onnx model can be used (not exciting, nor educationally valuable)\",\n  iconURL: \"\",\n  insetIconURL: \"\"\n};\n\n\ntype Blocks = {\n  test: () => void\n}\n\nexport default class ExtensionNameGoesHere extends Extension<Details, Blocks> {\n  onnx = new OnnxRuntime();\n\n  init(env: Environment) { }\n\n  defineBlocks(): ExtensionNameGoesHere[\"BlockDefinitions\"] {\n\n    return {\n      test: {\n        type: BlockType.Command,\n        text: \"eee\",\n        operation: async () => {\n          try {\n            const { InferenceSession, Tensor } = await this.onnx.runtime;\n\n            // create a new session and load the specific model.\n            //\n            // the model in this example contains a single MatMul node\n            // it has 2 inputs: 'a'(float32, 3x4) and 'b'(float32, 4x3)\n            // it has 1 output: 'c'(float32, 3x3)\n            const session = await InferenceSession.create(`${location.href}/static/model.onnx`);\n\n            // prepare inputs. a tensor need its corresponding TypedArray as data\n            const dataA = Float32Array.from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);\n            const dataB = Float32Array.from([10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]);\n            const tensorA = new Tensor('float32', dataA, [3, 4]);\n            const tensorB = new Tensor('float32', dataB, [4, 3]);\n\n            // prepare feeds. use model input names as keys.\n            const feeds = { a: tensorA, b: tensorB };\n\n            // feed inputs and run\n            const results = await session.run(feeds);\n\n            // read from results\n            const dataC = results.c.data;\n            console.log(dataC);\n          } catch (e) {\n            console.error(`failed to inference ONNX model: ${e}.`);\n          }\n        }\n      }\n    }\n  }\n}"],"names":["onnxTest","exports","$common","OnnxRuntime","runtime","async","obj","delay","timeout","ready","Promise","resolve","clearTimeout","setTimeout","untilReady","this","then","onnx","globalOnnx","window","ort","constructor","url","onLoad","onError","script","document","createElement","onload","onerror","Error","src","body","appendChild","loadExternalScript","FromCDN","bind","ExtensionNameGoesHere","Extension","init","env","defineBlocks","test","type","BlockType","Command","text","operation","InferenceSession","Tensor","session","create","location","href","dataA","Float32Array","from","dataB","tensorA","feeds","a","b","dataC","run","c","data","console","log","e","error","Object","defineProperty","value","ExtensionFramework"],"mappings":"AAuDO,IAAAA,SAAA,SAAAC,EAAAC,GAAA,aClDP,MAAaC,EAMPC,cAAiC,OD4ChCC,eAAwDC,EAAQC,EAAgB,KACrF,IAAIC,EACJ,MAAQF,EAAIG,aACJ,IAAIC,SAAQC,IAChBC,aAAaJ,GACbA,EAAUK,WAAWF,EAASJ,EAAM,IAGxCK,aAAaJ,EACf,CCrD8CM,CAAWC,MAAMC,MAAK,IAAMD,KAAKE,MAAQ,CAEzEC,iBAAe,OAAQC,OAA2BC,GAAK,CAEnEC,cAPAN,KAAKN,OAAG,EAQOM,KAAKG,WACXH,KAAKJ,UD0EkB,EAACW,EAAaC,EAAoBC,KAClE,MAAMC,EAASC,SAASC,cAAc,UAEtCF,EAAOG,OAASL,EAEhBE,EAAOI,QAAUL,SACf,MAAM,IAAIM,MAAM,2BAA2BR,IAC5C,GAEDG,EAAOM,IAAMT,EACbG,EAAOpB,OAAQ,EAEfqB,SAASM,KAAKC,YAAYR,EAAO,ECtFPS,CAAmB/B,EAAYgC,QAASpB,KAAKJ,QAAQyB,KAAKrB,MACnF,CAEOJ,UACNI,KAAKN,OAAQ,EACbM,KAAKE,KAAOF,KAAKG,UAClB,EAjBMf,EAAOgC,QAAG,+DCSE,MAAAE,UAA8BC,EAAAA,UAAnDjB,qxCACEN,KAAAE,KAAO,IAAId,CA2CZ,CAzCCoC,KAAKC,GAAqB,CAE1BC,eAEE,MAAO,CACLC,KAAM,CACJC,KAAMC,EAASA,UAACC,QAChBC,KAAM,MACNC,UAAW1C,UACT,IACE,MAAM2C,iBAAEA,EAAgBC,OAAEA,SAAiBlC,KAAKE,KAAKb,QAO/C8C,QAAgBF,EAAiBG,OAAO,GAAGC,SAASC,0BAGpDC,EAAQC,aAAaC,KAAK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,KAC9DC,EAAQF,aAAaC,KAAK,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,IAAK,MACzEE,EAAU,IAAIT,EAAO,UAAWK,EAAO,CAAC,EAAG,IAI3CK,EAAQ,CAAEC,EAAGF,EAASG,EAHZ,IAAIZ,EAAO,UAAWQ,EAAO,CAAC,EAAG,KAS3CK,SAHgBZ,EAAQa,IAAIJ,IAGZK,EAAEC,KACxBC,QAAQC,IAAIL,EACb,CAAC,MAAOM,GACPF,QAAQG,MAAM,mCAAmCD,KAClD,IAIR,EACF,OAAAnE,EAAAqC,UAAAD,EAAAiC,OAAAC,eAAAtE,EAAA,aAAA,CAAAuE,OAAA,IAAAvE,CAAA,CFJM,CEIN,CAAA,EAAAwE"}