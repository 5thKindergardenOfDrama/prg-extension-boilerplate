{"version":3,"file":"poseFace.js","sources":["../../../../extensions/src/poseFace/legacy.ts","../../../../extensions/src/poseFace/index.ts"],"sourcesContent":["import { ArgumentType, BlockType, extractLegacySupportFromOldGetInfo } from \"$common\";\nimport { mockFormatMessage as formatMessage } from \"$common\";\n\n\n/**\n * Copy and paste over the of the object returned by the old extension's 'getInfo' method \n * (making the necessary changes outlined below, and note that only the 'blocks' and 'menus' fields are required)\n * and pass it as an argument to the 'extractLegacySupportFromOldGetInfo' function.\n * If you're doing this in a seperate file from your Extension, make sure to export the return value.\n * NOTE: The object makes use of the 'as const' assertion applied to the argument object \n * (see below, at the end of the function call).\n * @see https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions\n */\nexport default extractLegacySupportFromOldGetInfo({\n  blocks: [\n    {\n      opcode: 'affdexGoToPart',\n      text: 'go to [AFFDEX_POINT]',\n      blockType: BlockType.Command,\n      isTerminal: false,\n      arguments: {\n        AFFDEX_POINT: {\n          type: ArgumentType.Number,\n          defaultValue: 0,\n          menu: 'AFFDEX_POINT'\n        },\n      },\n    },\n    //'---',\n    {\n      opcode: 'affdexWhenExpression',\n      text: 'when [EXPRESSION] detected',\n      blockType: BlockType.Hat,\n      isTerminal: true,\n      arguments: {\n        EXPRESSION: {\n          type: ArgumentType.String,\n          defaultValue: 'smile',\n          menu: 'EXPRESSION'\n        },\n      }\n    },\n    {\n      opcode: 'affdexExpressionAmount',\n      text: 'amount of [EXPRESSION]',\n      blockType: BlockType.Reporter,\n      isTerminal: true,\n      arguments: {\n        EXPRESSION: {\n          type: ArgumentType.String,\n          defaultValue: 'smile',\n          menu: 'EXPRESSION'\n        },\n      }\n    },\n    {\n      opcode: 'affdexIsExpression',\n      text: 'expressing [EXPRESSION]',\n      blockType: BlockType.Boolean,\n      isTerminal: true,\n      arguments: {\n        EXPRESSION: {\n          type: ArgumentType.String,\n          defaultValue: 'smile',\n          menu: 'EXPRESSION'\n        },\n      }\n    },\n    //'---',\n    {\n      opcode: 'affdexWhenEmotion',\n      text: 'when [EMOTION] feeling detected',\n      blockType: BlockType.Hat,\n      isTerminal: true,\n      arguments: {\n        EMOTION: {\n          type: ArgumentType.String,\n          defaultValue: 'joy',\n          menu: 'EMOTION'\n        },\n      }\n    },\n    {\n      opcode: 'affdexEmotionAmount',\n      text: 'level of [EMOTION_ALL]',\n      blockType: BlockType.Reporter,\n      isTerminal: true,\n      arguments: {\n        EMOTION_ALL: {\n          type: ArgumentType.String,\n          defaultValue: 'joy',\n          menu: 'EMOTION_ALL'\n        },\n      },\n    },\n    {\n      opcode: 'affdexIsTopEmotion',\n      text: 'feeling [EMOTION]',\n      blockType: BlockType.Boolean,\n      isTerminal: true,\n      arguments: {\n        EMOTION: {\n          type: ArgumentType.String,\n          defaultValue: 'joy',\n          menu: 'EMOTION'\n        },\n      },\n    },\n    //'---',\n    {\n      opcode: 'videoToggle',\n      blockType: BlockType.Command,\n      text: formatMessage({\n        id: 'videoSensing.videoToggle',\n        default: 'turn video [VIDEO_STATE]',\n        description: 'Controls display of the video preview layer'\n      }),\n      arguments: {\n        VIDEO_STATE: {\n          type: ArgumentType.Number,\n          menu: 'VIDEO_STATE',\n          defaultValue: 0\n        }\n      }\n    },\n    {\n      opcode: 'setVideoTransparency',\n      blockType: BlockType.Command,\n      text: formatMessage({\n        id: 'videoSensing.setVideoTransparency',\n        default: 'set video transparency to [TRANSPARENCY]',\n        description: 'Controls transparency of the video preview layer'\n      }),\n      arguments: {\n        TRANSPARENCY: {\n          type: ArgumentType.Number,\n          defaultValue: 50\n        }\n      }\n    },\n  ],\n  menus: {\n    AFFDEX_POINT: {\n      acceptReporters: false,\n      items: [\n        { text: 'left ear', value: 0 },\n        { text: 'left chin', value: 1 },\n        { text: 'chin', value: 2 },\n        { text: 'right chin', value: 3 },\n        { text: 'right ear', value: 4 },\n        { text: 'left outer eyebrow', value: 5 },\n        { text: 'left eyebrow', value: 6 },\n        { text: 'left inner eyebrow', value: 7 },\n        { text: 'right inner eyebrow', value: 8 },\n        { text: 'right eyebrow', value: 9 },\n        { text: 'right outer eyebrow', value: 10 },\n        { text: 'nose bridge', value: 11 },\n        { text: 'nose tip', value: 12 },\n        { text: 'left nostril', value: 13 },\n        { text: 'nose tip', value: 14 },\n        { text: 'right nostril', value: 15 },\n        { text: 'left outer eye crease', value: 16 },\n        { text: 'left inner eye crease', value: 17 },\n        { text: 'right inner eye crease', value: 18 },\n        { text: 'right outer eye crease', value: 19 },\n        { text: 'left mouth crease', value: 20 },\n        { text: 'left upper lip point', value: 21 },\n        { text: 'upper lip', value: 22 },\n        { text: 'right upper lip point', value: 23 },\n        { text: 'right mouth crease', value: 24 },\n        { text: 'right lower lip point', value: 25 },\n        { text: 'lower lip', value: 26 },\n        { text: 'left lower lip point', value: 27 },\n        { text: 'upper lip bottom', value: 28 },\n        { text: 'lower lip top', value: 29 },\n        { text: 'left upper eyelid', value: 30 },\n        { text: 'left lower eyelid', value: 31 },\n        { text: 'right upper eyelid', value: 32 },\n        { text: 'right lower eyelid', value: 33 }\n      ]\n    },\n    EMOTION: {\n      acceptReporters: true,\n      items: [\n        { text: 'joyful', value: 'joy' },\n        { text: 'sad', value: 'sadness' },\n        { text: 'disgusted', value: 'disgust' },\n        // {text: 'contempt', value: 'contempt'},\n        { text: 'angry', value: 'anger' },\n        { text: 'fearful', value: 'fear' },\n        // {text: 'surprise', value: 'surprise'},\n        // {text: 'valence', value: 'valence'},\n        // {text: 'engagement', value: 'engagement'},\n      ]\n    },\n    EXPRESSION: {\n      acceptReporters: true,\n      items: [\n        { text: 'smile', value: 'smile' },\n        { text: 'mouth open', value: 'mouthOpen' },\n        { text: 'eye closure', value: 'eyeClosure' },\n        { text: 'eyebrow raise', value: 'browRaise' },\n        { text: 'whistling', value: 'lipPucker' },\n        { text: 'eye widening', value: 'eyeWiden' },\n        // {text:'innerBrowRaise', value: 'innerBrowRaise'},\n        { text: 'eyebrow furrow', value: 'browFurrow' },\n        { text: 'nose wrinkle', value: 'noseWrinkle' },\n        { text: 'upper lip raise', value: 'upperLipRaise' },\n        { text: 'lip corner pull', value: 'lipCornerDepressor' },\n        { text: 'chin raise', value: 'chinRaise' },\n        // {text:'lip press', value:  'lipPress'},\n        // {text:'lip suck', value:  'lipSuck'},\n        { text: 'smirk', value: 'smirk' },\n        { text: 'attention', value: 'attention' },\n        { text: 'eyelid tighten', value: 'lidTighten' },\n        { text: 'jaw drop', value: 'jawDrop' },\n        { text: 'cheek dimple', value: 'dimpler' },\n        { text: 'cheek raise', value: 'cheekRaise' },\n        { text: 'lip stretch', value: 'lipStretch' },\n      ]\n    },\n    EMOTION_ALL: {\n      acceptReporters: true,\n      items: [\n        { text: 'joy', value: 'joy' },\n        { text: 'sadness', value: 'sadness' },\n        { text: 'disgust', value: 'disgust' },\n        { text: 'contempt', value: 'contempt' },\n        { text: 'anger', value: 'anger' },\n        { text: 'fear', value: 'fear' },\n        { text: 'surprise', value: 'surprise' },\n        { text: 'valence', value: 'valence' },\n        { text: 'engagement', value: 'engagement' },\n      ]\n    },\n    ATTRIBUTE: {\n      acceptReporters: true,\n      items: [\n        {\n          text: formatMessage({\n            id: 'videoSensing.motion',\n            default: 'motion',\n            description: 'Attribute for the \"video [ATTRIBUTE] on [SUBJECT]\" block'\n          }),\n          value: 'motion'\n        },\n        {\n          text: formatMessage({\n            id: 'videoSensing.direction',\n            default: 'direction',\n            description: 'Attribute for the \"video [ATTRIBUTE] on [SUBJECT]\" block'\n          }),\n          value: 'direction'\n        }\n      ]\n    },\n    SUBJECT: {\n      acceptReporters: true,\n      items: [\n        {\n          text: formatMessage({\n            id: 'videoSensing.sprite',\n            default: 'sprite',\n            description: 'Subject for the \"video [ATTRIBUTE] on [SUBJECT]\" block'\n          }),\n          value: 'this sprite'\n        },\n        {\n          text: formatMessage({\n            id: 'videoSensing.stage',\n            default: 'stage',\n            description: 'Subject for the \"video [ATTRIBUTE] on [SUBJECT]\" block'\n          }),\n          value: 'Stage'\n        }\n      ]\n    },\n    VIDEO_STATE: {\n      acceptReporters: true,\n      items: [\n        {\n          text: formatMessage({\n            id: 'videoSensing.off',\n            default: 'off',\n            description: 'Option for the \"turn video [STATE]\" block'\n          }),\n          value: 0\n        },\n        {\n          text: formatMessage({\n            id: 'videoSensing.on',\n            default: 'on',\n            description: 'Option for the \"turn video [STATE]\" block'\n          }),\n          value: 1\n        },\n        {\n          text: formatMessage({\n            id: 'videoSensing.onFlipped',\n            default: 'on and flipped',\n            description: 'Option for the \"turn video [STATE]\" block that causes the video to be flipped' +\n              ' horizontally (reversed as in a mirror)'\n          }),\n          value: 2\n        }\n      ]\n    }\n  },\n} as const); // VERY IMPORTANT! Note the use of 'as const' on the object passed to the function\n\n/**\n * By using 'as const', \n * we ensure typescript is able to extract as much information from the old getInfo object as possible\n */\n\n\n","import { ArgumentType, BlockType, Extension, Block, DefineBlock, Environment, ExtensionMenuDisplayDetails, untilExternalGlobalVariableLoaded, extractLegacySupportFromOldGetInfo } from \"$common\";\nimport legacy from \"./legacy\";\n\n// import * as window from 'affdex.js';\n\n/**\n * States what the video sensing activity can be set to.\n */\nconst VideoState = {\n  /** Video turned off. */\n  OFF: 0,\n\n  /** Video turned on with default y axis mirroring. */\n  ON: 1,\n\n  /** Video turned on without default y axis mirroring. */\n  ON_FLIPPED: 2\n} as const;\n\n/**\n * Used for rounding\n * @param amount \n * @returns {double} a double\n */\nfunction friendlyRound(amount) {\n  return parseFloat(Number(amount).toFixed(2));\n}\n\n/**\n * Contains details about the Face Sensing extension\n */\ntype Details = {\n  name: \"Face Sensing\",\n  description: \"Sense face movement with the camera.\",\n  iconURL: \"pose-face.png\",\n  insetIconURL: \"pose-face-small.svg\"\n};\n\n/**\n * Contains descriptions of the blocks of the Block Sensing extension\n */\ntype Blocks = {\n  goToFacePartCommand(facePart: number): void;\n  whenExpressionDetectedHat(expression: string): boolean;\n  amountOfExpressionDetectedReport(expression: string): number;\n  isExpressionReport(expression: string): boolean;\n  whenFeelingDetectedHat(feeling: string): boolean;\n  levelOfFeelingReport(feeling: string): number;\n  isFeelingReport(feeling: string): boolean;\n  // these video blocks are present in a few different extensions, perhaps making a file just for these?\n  videoToggleBlock(state: number): void;\n  setVideoTransparencyBlock(transparency: number): void;\n}\n\ntype Affdex = {\n  PhotoDetector: new (imageElement, width: number, height: number, mode) => Detector,\n\n  FaceDetectorMode: {\n    LARGE_FACES: 0,\n    SMALL_FACES: 1\n  };\n};\n\ntype Detector = {\n  process: (imageElement: any, index: number) => void;\n  addEventListener: (eventName: string, data: any) => void;\n  detectAllEmotions();\n  detectAllExpressions();\n  start();\n  removeEventListener: (eventName: string, toRemove: Function) => void;\n}\n\n\nexport default class PoseFace extends Extension<Details, Blocks> {\n\n\n  /**\n   * The state of where the hand and its parts are estimated to be\n   */\n  affdexState;\n\n  hasResult: boolean;\n\n  private affdexDetector: Detector;\n\n  /**\n   * The current video state\n   * @type {number}\n   */\n  globalVideoState: number;\n\n  /**\n   * The current transparency of the video\n   * @type {number}\n   */\n  globalVideoTransparency: number;\n\n  /**\n   * Acts like class PoseHand's constructor (instead of a child class constructor)\n   * @param env \n   */\n  init(env: Environment) {\n    this.runtime = env.runtime;\n    const EXTENSION_ID = 'PoseHand';\n\n    /* Unused but possibly needed in the future\n    this.runtime.registerPeripheralExtension(EXTENSION_ID, this);\n    this.runtime.connectPeripheral(EXTENSION_ID, 0);\n    this.runtime.emit(this.runtime.constructor.PERIPHERAL_CONNECTED);\n    */\n\n    if (this.runtime.ioDevices) {\n      /* Possibly unnecessary, keep commented just in case\n      this.runtime.on(RuntimeEvent.ProjectLoaded, this.projectStarted.bind(this));\n      this.runtime.on(RuntimeEvent.ProjectRunStart, this.reset.bind(this)); \n      */\n      this._loop();\n    }\n  }\n\n  /**\n   * Dimensions the video stream is analyzed at after its rendered to the\n   * sample canvas.\n   * @type {Array.<number>}\n   */\n  static get DIMENSIONS() {\n    return [480, 360];\n  }\n\n  projectStarted() {\n    this.setTransparency(this.globalVideoTransparency);\n    this.toggleVideo(this.globalVideoState);\n  }\n\n  /**\n   * Converts the coordinates from the hand pose estimate to Scratch coordinates\n   * @param x \n   * @param y\n   * @returns enum\n   */\n  convertCoordsToScratch({ x, y }) {\n    return { x: x - (PoseFace.DIMENSIONS[0] / 2), y: (PoseFace.DIMENSIONS[1] / 2) - y };\n  }\n\n  async _loop() {\n    while (true) {\n      const frame = this.runtime.ioDevices.video.getFrame({\n        format: 'image-data',\n        dimensions: PoseFace.DIMENSIONS\n      });\n\n      const time = +new Date();\n      if (frame) {\n        this.affdexState = await this.estimateAffdexOnImage(frame);\n        /*\n        if (this.affdexState) {\n          this.hasResult = true;\n          this.runtime.emit(this.runtime.constructor.PERIPHERAL_CONNECTED);\n        } else {\n          this.hasResult = false;\n          this.runtime.emit(this.runtime.constructor.PERIPHERAL_DISCONNECTED);\n        }\n        */\n      }\n      const estimateThrottleTimeout = (+new Date() - time) / 4;\n      await new Promise(r => setTimeout(r, estimateThrottleTimeout));\n    }\n  }\n\n  isConnected() {\n    return this.hasResult;\n  }\n\n  async estimateAffdexOnImage(imageElement) {\n    const affdexDetector = await this.ensureAffdexLoaded(imageElement);\n\n    affdexDetector.process(imageElement, 0);\n    return new Promise((resolve, reject) => {\n      const resultListener = function (faces, image, timestamp) {\n        affdexDetector.removeEventListener(\"onImageResultsSuccess\", resultListener);\n        if (faces.length < 1) {\n          resolve(null);\n          return;\n        }\n        resolve(faces[0]);\n      };\n      affdexDetector.addEventListener(\"onImageResultsSuccess\", resultListener);\n    });\n  }\n\n  async ensureAffdexLoaded(imageElement) {\n    if (this.affdexDetector) return this.affdexDetector\n\n    const affdex: Affdex = await untilExternalGlobalVariableLoaded('https://download.affectiva.com/js/3.2.1/affdex.js', 'affdex');\n\n    const affdexStarter = new Promise((resolve, reject) => {\n      const width = PoseFace.DIMENSIONS[0];\n      const height = PoseFace.DIMENSIONS[1];\n      const faceMode = affdex.FaceDetectorMode.LARGE_FACES;\n      const detector = new affdex.PhotoDetector(imageElement, width, height, faceMode);\n      detector.detectAllEmotions();\n      detector.detectAllExpressions();\n      detector.start();\n      this.affdexDetector = detector;\n      detector.addEventListener(\"onInitializeSuccess\", resolve);\n    });\n    await affdexStarter;\n\n    return this.affdexDetector;\n  }\n\n  /**\n   * \n   * @param part \n   * @param util \n   * @returns \n   */\n  goToPart(part, util) {\n    if (!this.affdexState || !this.affdexState.featurePoints) return;\n\n    const featurePoint = this.affdexState.featurePoints[part];\n    const { x, y } = this.convertCoordsToScratch(featurePoint);\n    (util.target as any).setXY(x, y, false);\n  }\n\n  /**\n   * \n   * @param expression \n   * @returns \n   */\n  isExpression(expression) {\n    if (!this.affdexState || !this.affdexState.expressions) {\n      return false;\n    }\n    return this.affdexState.expressions[expression] > .5;\n  }\n\n  /**\n   * \n   * @param expression \n   * @returns \n   */\n  expressionAmount(expression) {\n    if (!this.affdexState || !this.affdexState.expressions) {\n      return 0;\n    }\n    return friendlyRound(this.affdexState.expressions[expression]);\n  }\n\n  /**\n   * \n   * @param emotion \n   * @param emotions \n   * @returns \n   */\n  isTopEmotion(emotion, emotions) {\n    if (!this.affdexState || !this.affdexState.emotions) {\n      return false;\n    }\n    let maxEmotionValue = -Number.MAX_VALUE;\n    let maxEmotion = null;\n    emotions.forEach((emotion) => {\n      const emotionValue = this.affdexState.emotions[emotion];\n      if (emotionValue > maxEmotionValue) {\n        maxEmotionValue = emotionValue;\n        maxEmotion = emotion;\n      }\n    });\n    return emotion === maxEmotion;\n  }\n\n  /**\n   * \n   * @param emotion \n   * @returns \n   */\n  emotionAmount(emotion) {\n    if (!this.affdexState || !this.affdexState.emotions) {\n      return 0;\n    }\n    return friendlyRound(this.affdexState.emotions[emotion]);\n  }\n\n  /**\n   * Turns the video camera off/on/on and flipped. This is called in the operation of videoToggleBlock\n   * @param state \n   */\n  toggleVideo(state: number) {\n    if (state === VideoState.OFF) return this.runtime.ioDevices.video.disableVideo();\n\n    this.runtime.ioDevices.video.enableVideo();\n    // Mirror if state is ON. Do not mirror if state is ON_FLIPPED.\n    this.runtime.ioDevices.video.mirror = (state === VideoState.ON);\n  }\n\n  /**\n   * Sets the video's transparency. This is called in the operation of setVideoTransparencyBlock\n   * @param transparency \n   */\n  setTransparency(transparency: number) {\n    const trans = Math.max(Math.min(transparency, 100), 0);\n    this.runtime.ioDevices.video.setPreviewGhost(trans);\n  }\n\n  /**\n   * Sets up the default settings for the extension. Gives information related to each of the extension's blocks\n   * @returns The extension's blocks\n   */\n  defineBlocks(): PoseFace[\"BlockDefinitions\"] {\n\n    /**\n     * Sets up the extension's default video settings\n     */\n    this.globalVideoState = VideoState.ON;\n    this.globalVideoTransparency = 50;\n    this.projectStarted();\n\n\n    // FACE PART Block\n\n    const faceParts = [\n      { text: 'left ear', value: 0 },\n      { text: 'left chin', value: 1 },\n      { text: 'chin', value: 2 },\n      { text: 'right chin', value: 3 },\n      { text: 'right ear', value: 4 },\n      { text: 'left outer eyebrow', value: 5 },\n      { text: 'left eyebrow', value: 6 },\n      { text: 'left inner eyebrow', value: 7 },\n      { text: 'right inner eyebrow', value: 8 },\n      { text: 'right eyebrow', value: 9 },\n      { text: 'right outer eyebrow', value: 10 },\n      { text: 'nose bridge', value: 11 },\n      { text: 'nose tip', value: 12 },\n      { text: 'left nostril', value: 13 },\n      { text: 'nose tip', value: 14 },\n      { text: 'right nostril', value: 15 },\n      { text: 'left outer eye crease', value: 16 },\n      { text: 'left inner eye crease', value: 17 },\n      { text: 'right inner eye crease', value: 18 },\n      { text: 'right outer eye crease', value: 19 },\n      { text: 'left mouth crease', value: 20 },\n      { text: 'left upper lip point', value: 21 },\n      { text: 'upper lip', value: 22 },\n      { text: 'right upper lip point', value: 23 },\n      { text: 'right mouth crease', value: 24 },\n      { text: 'right lower lip point', value: 25 },\n      { text: 'lower lip', value: 26 },\n      { text: 'left lower lip point', value: 27 },\n      { text: 'upper lip bottom', value: 28 },\n      { text: 'lower lip top', value: 29 },\n      { text: 'left upper eyelid', value: 30 },\n      { text: 'left lower eyelid', value: 31 },\n      { text: 'right upper eyelid', value: 32 },\n      { text: 'right lower eyelid', value: 33 }\n    ];\n\n    //type DefineGoToFacePart = DefineBlock<PoseFace, Blocks[\"goToFacePartCommand\"]>;\n    const goToFacePartCommand = () => legacy.affdexGoToPart({\n      type: BlockType.Command,\n      arg: {\n        type: ArgumentType.Number,\n        options: faceParts\n      },\n      text: (part: number) => `go to ${part}`,\n      operation: (part: number, util) => {\n        this.goToPart(part, util)\n      }\n    });\n\n    // EXPRESSION BLOCKS\n\n    const expressions = [\n      { text: 'smile', value: 'smile' },\n      { text: 'mouth open', value: 'mouthOpen' },\n      { text: 'eye closure', value: 'eyeClosure' },\n      { text: 'eyebrow raise', value: 'browRaise' },\n      { text: 'whistling', value: 'lipPucker' },\n      { text: 'eye widening', value: 'eyeWiden' },\n      // {text:'innerBrowRaise', value: 'innerBrowRaise'},\n      { text: 'eyebrow furrow', value: 'browFurrow' },\n      { text: 'nose wrinkle', value: 'noseWrinkle' },\n      { text: 'upper lip raise', value: 'upperLipRaise' },\n      { text: 'lip corner pull', value: 'lipCornerDepressor' },\n      { text: 'chin raise', value: 'chinRaise' },\n      // {text:'lip press', value:  'lipPress'},\n      // {text:'lip suck', value:  'lipSuck'},\n      { text: 'smirk', value: 'smirk' },\n      { text: 'attention', value: 'attention' },\n      { text: 'eyelid tighten', value: 'lidTighten' },\n      { text: 'jaw drop', value: 'jawDrop' },\n      { text: 'cheek dimple', value: 'dimpler' },\n      { text: 'cheek raise', value: 'cheekRaise' },\n      { text: 'lip stretch', value: 'lipStretch' }\n    ];\n    const handlerExpressions = expressions.map(expression => expression.value);\n\n    // type DefineExpressDetect = DefineBlock<PoseFace, Blocks[\"whenExpressionDetectedHat\"]>;\n    const whenExpressionDetectedHat = () => legacy.affdexWhenExpression({\n      type: BlockType.Hat,\n      arg: {\n        type: ArgumentType.String,\n        options: {\n          acceptsReporters: true,\n          items: expressions,\n          handler: (expression: string) => {\n            return handlerExpressions.includes(expression) ? expression : 'smile';\n          }\n        }\n      },\n      text: (expression: string) => `when ${expression} detected`,\n      operation: (expression: string) => {\n        return this.isExpression(expression);\n      }\n    });\n\n    // type DefineAmountExpress = DefineBlock<PoseFace, Blocks[\"amountOfExpressionDetectedReport\"]>;\n    const amountOfExpressionDetectedReport = () => legacy.affdexExpressionAmount({\n      type: BlockType.Reporter,\n      arg: {\n        type: ArgumentType.String,\n        options: {\n          acceptsReporters: true,\n          items: expressions,\n          handler: (expression: string) => {\n            return handlerExpressions.includes(expression) ? expression : 'smile';\n          }\n        }\n      },\n      text: (expression: string) => `amount of ${expression}`,\n      operation: (expression: string) => {\n        return this.expressionAmount(expression);\n      }\n    });\n\n    // type DefineExpressReport = DefineBlock<PoseFace, Blocks[\"isExpressionReport\"]>;\n    const isExpressionReport = () => legacy.affdexIsExpression({\n      type: BlockType.Boolean,\n      arg: {\n        type: ArgumentType.String,\n        options: {\n          acceptsReporters: true,\n          items: expressions,\n          handler: (expression: string) => {\n            return handlerExpressions.includes(expression) ? expression : 'smile';\n          }\n        }\n      },\n      text: (expression: string) => `expressing ${expression}`,\n      operation: (expression: string) => {\n        return this.isExpression(expression);\n      }\n    });\n\n    // EMOTION BLOCKS\n\n    const emotions = [\n      { text: 'joyful', value: 'joy' },\n      { text: 'sad', value: 'sadness' },\n      { text: 'disgusted', value: 'disgust' },\n      { text: 'angry', value: 'anger' },\n      { text: 'fearful', value: 'fear' }\n    ];\n    const handlerEmotionsShort = emotions.map(emotion => emotion.value);\n\n    const emotions2 = [\n      { text: 'contempt', value: 'contempt' },\n      { text: 'surprise', value: 'surprise' },\n      { text: 'valence', value: 'valence' },\n      { text: 'engagement', value: 'engagement' }\n    ];\n    const allEmotionValues = emotions.concat(emotions2).map(emotion => emotion.value);\n\n    // type DefineFeelingDetect = DefineBlock<PoseFace, Blocks[\"whenFeelingDetectedHat\"]>;\n    const whenFeelingDetectedHat = () => legacy.affdexWhenEmotion({\n      type: BlockType.Hat,\n      arg: {\n        type: ArgumentType.String,\n        options: {\n          acceptsReporters: true,\n          items: emotions,\n          handler: (emotion: string) => {\n            return handlerEmotionsShort.includes(emotion) ? emotion : 'joy';\n          }\n        }\n      },\n      text: (emotion: string) => `when ${emotion} feeling detected`,\n      operation: (emotion: string) => {\n        return this.isTopEmotion(emotion, emotions);\n      }\n    });\n\n    // type DefineLevelFeeling = DefineBlock<PoseFace, Blocks[\"levelOfFeelingReport\"]>;\n    const levelOfFeelingReport = () => legacy.affdexEmotionAmount({\n      type: BlockType.Reporter,\n      arg: {\n        type: ArgumentType.String,\n        options: {\n          acceptsReporters: true,\n          items: allEmotionValues,\n          handler: (emotion: string) => {\n            return allEmotionValues.includes(emotion) ? emotion : 'joy';\n          }\n        }\n      },\n      text: (emotion: string) => `level of ${emotion}`,\n      operation: (emotion: string) => {\n        return this.emotionAmount(emotion)\n      }\n    });\n\n    // type DefineIsFeeling = DefineBlock<PoseFace, Blocks[\"isFeelingReport\"]>;\n    const isFeelingReport = () => legacy.affdexIsTopEmotion({\n      type: BlockType.Boolean,\n      arg: {\n        type: ArgumentType.String,\n        options: {\n          acceptsReporters: true,\n          items: emotions,\n          handler: (emotion: string) => {\n            return handlerEmotionsShort.includes(emotion) ? emotion : 'joy';\n          }\n        }\n      },\n      text: (emotion: string) => `feeling ${emotion}`,\n      operation: (emotion: string) => {\n        return this.isTopEmotion(emotion, emotions);\n      }\n    });\n\n    // VIDEO BLOCKS\n\n    // type DefineVideoToggle = DefineBlock<PoseFace, Blocks[\"videoToggleBlock\"]>;\n    const videoToggleBlock = () => legacy.videoToggle({\n      type: BlockType.Command,\n      arg: {\n        type: ArgumentType.Number,\n        options: {\n          acceptsReporters: true,\n          items: [{ text: 'off', value: VideoState.OFF }, { text: 'on', value: VideoState.ON }, { text: 'on and flipped', value: VideoState.ON_FLIPPED }],\n          handler: (video_state: number) => {\n            return Math.min(Math.max(video_state, VideoState.OFF), VideoState.ON_FLIPPED);\n          }\n        }\n      },\n      text: (video_state: number) => `turn video ${video_state}`,\n      operation: (video_state: number) => {\n        this.toggleVideo(video_state);\n      }\n    });\n\n    // type DefineSetVideoTransparency = DefineBlock<PoseFace, Blocks[\"setVideoTransparencyBlock\"]>;\n    const setVideoTransparencyBlock = () => legacy.setVideoTransparency({\n      type: BlockType.Command,\n      arg: { type: ArgumentType.Number, defaultValue: 50 },\n      text: (transparency: number) => `set video transparency to ${transparency}`,\n      operation: (transparency: number) => {\n        this.setTransparency(transparency);\n      }\n    });\n\n    return {\n      goToFacePartCommand,\n      whenExpressionDetectedHat,\n      amountOfExpressionDetectedReport,\n      isExpressionReport,\n      whenFeelingDetectedHat,\n      levelOfFeelingReport,\n      isFeelingReport,\n      videoToggleBlock,\n      setVideoTransparencyBlock\n    }\n  }\n}\n"],"names":["poseFace","exports","$common","legacy","extractLegacySupportFromOldGetInfo","blocks","opcode","text","blockType","BlockType","Command","isTerminal","arguments","AFFDEX_POINT","type","ArgumentType","Number","defaultValue","menu","Hat","EXPRESSION","String","Reporter","Boolean","EMOTION","EMOTION_ALL","formatMessage","id","default","description","VIDEO_STATE","TRANSPARENCY","menus","acceptReporters","items","value","ATTRIBUTE","SUBJECT","VideoState","friendlyRound","amount","parseFloat","toFixed","PoseFace","Extension","internal_getCodeGenArgs","name","blockIconURI","init","env","this","runtime","ioDevices","_loop","DIMENSIONS","projectStarted","setTransparency","globalVideoTransparency","toggleVideo","globalVideoState","convertCoordsToScratch","x","y","async","frame","video","getFrame","format","dimensions","time","Date","affdexState","estimateAffdexOnImage","estimateThrottleTimeout","Promise","r","setTimeout","isConnected","hasResult","imageElement","affdexDetector","ensureAffdexLoaded","process","resolve","reject","resultListener","faces","image","timestamp","removeEventListener","length","addEventListener","affdex","untilExternalGlobalVariableLoaded","affdexStarter","width","height","faceMode","FaceDetectorMode","LARGE_FACES","detector","PhotoDetector","detectAllEmotions","detectAllExpressions","start","goToPart","part","util","featurePoints","featurePoint","setXY","isExpression","expression","expressions","expressionAmount","isTopEmotion","emotion","emotions","maxEmotionValue","MAX_VALUE","maxEmotion","forEach","emotionValue","emotionAmount","state","disableVideo","enableVideo","mirror","transparency","trans","Math","max","min","setPreviewGhost","defineBlocks","faceParts","handlerExpressions","map","handlerEmotionsShort","allEmotionValues","concat","goToFacePartCommand","affdexGoToPart","arg","options","operation","whenExpressionDetectedHat","affdexWhenExpression","acceptsReporters","handler","includes","amountOfExpressionDetectedReport","affdexExpressionAmount","isExpressionReport","affdexIsExpression","whenFeelingDetectedHat","affdexWhenEmotion","levelOfFeelingReport","affdexEmotionAmount","isFeelingReport","affdexIsTopEmotion","videoToggleBlock","videoToggle","video_state","setVideoTransparencyBlock","setVideoTransparency"],"mappings":"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"}