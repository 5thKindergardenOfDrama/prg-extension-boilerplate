{"version":3,"file":"poseFace.js","sources":["../../../../extensions/src/poseFace/index.ts"],"sourcesContent":["import { ArgumentType, BlockType, Extension, Block, DefineBlock, Environment, ExtensionMenuDisplayDetails, untilExternalGlobalVariableLoaded } from \"$common\";\n\n// import * as window from 'affdex.js';\n\n/**\n * States what the video sensing activity can be set to.\n */\nconst VideoState = {\n  /** Video turned off. */\n  OFF: 0,\n\n  /** Video turned on with default y axis mirroring. */\n  ON: 1,\n\n  /** Video turned on without default y axis mirroring. */\n  ON_FLIPPED: 2\n} as const;\n\n/**\n * Used for rounding\n * @param amount \n * @returns {double} a double\n */\nfunction friendlyRound(amount) {\n  return parseFloat(Number(amount).toFixed(2));\n}\n\n/**\n * Contains details about the Face Sensing extension\n */\ntype Details = {\n  name: \"Face Sensing\",\n  description: \"Sense face movement with the camera.\",\n  iconURL: \"pose-face.png\",\n  insetIconURL: \"pose-face-small.svg\"\n};\n\n/**\n * Contains descriptions of the blocks of the Block Sensing extension\n */\ntype Blocks = {\n  goToFacePartCommand(facePart: number): void;\n  whenExpressionDetectedHat(expression: string): boolean;\n  amountOfExpressionDetectedReport(expression: string): number;\n  isExpressionReport(expression: string): boolean;\n  whenFeelingDetectedHat(feeling: string): boolean;\n  levelOfFeelingReport(feeling: string): number;\n  isFeelingReport(feeling: string): boolean;\n  // these video blocks are present in a few different extensions, perhaps making a file just for these?\n  videoToggleBlock(state: number): void;\n  setVideoTransparencyBlock(transparency: number): void;\n}\n\ntype Affdex = {\n  PhotoDetector: new (imageElement, width: number, height: number, mode) => Detector,\n\n  FaceDetectorMode: {\n    LARGE_FACES: 0,\n    SMALL_FACES: 1\n  };\n};\n\ntype Detector = {\n  process: (imageElement: any, index: number) => void;\n  addEventListener: (eventName: string, data: any) => void;\n  detectAllEmotions();\n  detectAllExpressions();\n  start();\n  removeEventListener: (eventName: string, toRemove: Function) => void;\n}\n\n\nexport default class PoseFace extends Extension<Details, Blocks> {\n\n\n  /**\n   * The state of where the hand and its parts are estimated to be\n   */\n  affdexState;\n\n  hasResult: boolean;\n\n  private affdexDetector: Detector;\n\n\n  /**\n   * The current video state\n   * @type {number}\n   */\n  globalVideoState: number;\n\n  /**\n   * The current transparency of the video\n   * @type {number}\n   */\n  globalVideoTransparency: number;\n\n  /**\n   * Acts like class PoseHand's constructor (instead of a child class constructor)\n   * @param env \n   */\n  init(env: Environment) {\n    this.runtime = env.runtime;\n    const EXTENSION_ID = 'PoseHand';\n\n    /* Unused but possibly needed in the future\n    this.runtime.registerPeripheralExtension(EXTENSION_ID, this);\n    this.runtime.connectPeripheral(EXTENSION_ID, 0);\n    this.runtime.emit(this.runtime.constructor.PERIPHERAL_CONNECTED);\n    */\n\n    if (this.runtime.ioDevices) {\n      /* Possibly unnecessary, keep commented just in case\n      this.runtime.on(RuntimeEvent.ProjectLoaded, this.projectStarted.bind(this));\n      this.runtime.on(RuntimeEvent.ProjectRunStart, this.reset.bind(this)); \n      */\n      this._loop();\n    }\n  }\n\n  /**\n   * Dimensions the video stream is analyzed at after its rendered to the\n   * sample canvas.\n   * @type {Array.<number>}\n   */\n  static get DIMENSIONS() {\n    return [480, 360];\n  }\n\n  projectStarted() {\n    this.setVideoTransparency(this.globalVideoTransparency);\n    this.videoToggle(this.globalVideoState);\n  }\n\n  /**\n   * Converts the coordinates from the hand pose estimate to Scratch coordinates\n   * @param x \n   * @param y\n   * @returns enum\n   */\n  affdexCoordsToScratch({ x, y }) {\n    console.log('coord to scratch');\n    return { x: x - (PoseFace.DIMENSIONS[0] / 2), y: (PoseFace.DIMENSIONS[1] / 2) - y };\n  }\n\n  async _loop() {\n    while (true) {\n      console.log('loop 1')\n      const frame = this.runtime.ioDevices.video.getFrame({\n        format: 'image-data',\n        dimensions: PoseFace.DIMENSIONS\n      });\n\n      const time = +new Date();\n      if (frame) {\n        this.affdexState = await this.estimateAffdexOnImage(frame);\n        console.log('loop 2');\n        /*\n        if (this.affdexState) {\n          this.hasResult = true;\n          this.runtime.emit(this.runtime.constructor.PERIPHERAL_CONNECTED);\n        } else {\n          this.hasResult = false;\n          this.runtime.emit(this.runtime.constructor.PERIPHERAL_DISCONNECTED);\n        }\n        */\n      }\n      const estimateThrottleTimeout = (+new Date() - time) / 4;\n      await new Promise(r => setTimeout(r, estimateThrottleTimeout));\n    }\n  }\n\n  isConnected() {\n    return this.hasResult;\n  }\n\n  async estimateAffdexOnImage(imageElement) {\n    const affdexDetector = await this.ensureAffdexLoaded(imageElement);\n\n    affdexDetector.process(imageElement, 0);\n    console.log('estimate affdex');\n    return new Promise((resolve, reject) => {\n      const resultListener = function (faces, image, timestamp) {\n        affdexDetector.removeEventListener(\"onImageResultsSuccess\", resultListener);\n        if (faces.length < 1) {\n          resolve(null);\n          return;\n        }\n        resolve(faces[0]);\n      };\n      affdexDetector.addEventListener(\"onImageResultsSuccess\", resultListener);\n    });\n  }\n\n  async ensureAffdexLoaded(imageElement) {\n    if (this.affdexDetector) return this.affdexDetector\n\n    const affdex: Affdex = await untilExternalGlobalVariableLoaded('https://download.affectiva.com/js/3.2.1/affdex.js', 'affdex');\n\n    const affdexStarter = new Promise((resolve, reject) => {\n      const width = PoseFace.DIMENSIONS[0];\n      const height = PoseFace.DIMENSIONS[1];\n      const faceMode = affdex.FaceDetectorMode.LARGE_FACES;\n      const detector = new affdex.PhotoDetector(imageElement, width, height, faceMode);\n      detector.detectAllEmotions();\n      detector.detectAllExpressions();\n      detector.start();\n      this.affdexDetector = detector;\n      detector.addEventListener(\"onInitializeSuccess\", resolve);\n    });\n    await affdexStarter;\n\n    return this.affdexDetector;\n  }\n\n  /**\n   * \n   * @param part \n   * @param util \n   * @returns \n   */\n  affdexGoToPart(part, util) {\n    if (!this.affdexState || !this.affdexState.featurePoints) {\n      return;\n    }\n    console.log('go to fxn');\n    const featurePoint = this.affdexState.featurePoints[part];\n    const { x, y } = this.affdexCoordsToScratch(featurePoint);\n    (util.target as any).setXY(x, y, false);\n  }\n\n  /**\n   * \n   * @param expression \n   * @returns \n   */\n  affdexIsExpression(expression) {\n    if (!this.affdexState || !this.affdexState.expressions) {\n      return false;\n    }\n    return this.affdexState.expressions[expression] > .5;\n  }\n\n  /**\n   * \n   * @param expression \n   * @returns \n   */\n  affdexExpressionAmount(expression) {\n    if (!this.affdexState || !this.affdexState.expressions) {\n      return 0;\n    }\n    return friendlyRound(this.affdexState.expressions[expression]);\n  }\n\n  /**\n   * \n   * @param emotion \n   * @param emotions \n   * @returns \n   */\n  affdexIsTopEmotion(emotion, emotions) {\n    if (!this.affdexState || !this.affdexState.emotions) {\n      return false;\n    }\n    let maxEmotionValue = -Number.MAX_VALUE;\n    let maxEmotion = null;\n    emotions.forEach((emotion) => {\n      const emotionValue = this.affdexState.emotions[emotion];\n      if (emotionValue > maxEmotionValue) {\n        maxEmotionValue = emotionValue;\n        maxEmotion = emotion;\n      }\n    });\n    return emotion === maxEmotion;\n  }\n\n  /**\n   * \n   * @param emotion \n   * @returns \n   */\n  affdexEmotionAmount(emotion) {\n    if (!this.affdexState || !this.affdexState.emotions) {\n      return 0;\n    }\n    return friendlyRound(this.affdexState.emotions[emotion]);\n  }\n\n  /**\n   * Turns the video camera off/on/on and flipped. This is called in the operation of videoToggleBlock\n   * @param state \n   */\n  videoToggle(state: number) {\n    if (state === VideoState.OFF) return this.runtime.ioDevices.video.disableVideo();\n\n    this.runtime.ioDevices.video.enableVideo();\n    // Mirror if state is ON. Do not mirror if state is ON_FLIPPED.\n    this.runtime.ioDevices.video.mirror = (state === VideoState.ON);\n  }\n\n  /**\n   * Sets the video's transparency. This is called in the operation of setVideoTransparencyBlock\n   * @param transparency \n   */\n  setVideoTransparency(transparency: number) {\n    const trans = Math.max(Math.min(transparency, 100), 0);\n    this.runtime.ioDevices.video.setPreviewGhost(trans);\n  }\n\n  /**\n   * Sets up the default settings for the extension. Gives information related to each of the extension's blocks\n   * @returns The extension's blocks\n   */\n  defineBlocks(): PoseFace[\"BlockDefinitions\"] {\n\n    /**\n     * Sets up the extension's default video settings\n     */\n    this.globalVideoState = VideoState.ON;\n    this.globalVideoTransparency = 50;\n    this.projectStarted();\n\n\n    // FACE PART Block\n\n    const faceParts = [\n      { text: 'left ear', value: 0 },\n      { text: 'left chin', value: 1 },\n      { text: 'chin', value: 2 },\n      { text: 'right chin', value: 3 },\n      { text: 'right ear', value: 4 },\n      { text: 'left outer eyebrow', value: 5 },\n      { text: 'left eyebrow', value: 6 },\n      { text: 'left inner eyebrow', value: 7 },\n      { text: 'right inner eyebrow', value: 8 },\n      { text: 'right eyebrow', value: 9 },\n      { text: 'right outer eyebrow', value: 10 },\n      { text: 'nose bridge', value: 11 },\n      { text: 'nose tip', value: 12 },\n      { text: 'left nostril', value: 13 },\n      { text: 'nose tip', value: 14 },\n      { text: 'right nostril', value: 15 },\n      { text: 'left outer eye crease', value: 16 },\n      { text: 'left inner eye crease', value: 17 },\n      { text: 'right inner eye crease', value: 18 },\n      { text: 'right outer eye crease', value: 19 },\n      { text: 'left mouth crease', value: 20 },\n      { text: 'left upper lip point', value: 21 },\n      { text: 'upper lip', value: 22 },\n      { text: 'right upper lip point', value: 23 },\n      { text: 'right mouth crease', value: 24 },\n      { text: 'right lower lip point', value: 25 },\n      { text: 'lower lip', value: 26 },\n      { text: 'left lower lip point', value: 27 },\n      { text: 'upper lip bottom', value: 28 },\n      { text: 'lower lip top', value: 29 },\n      { text: 'left upper eyelid', value: 30 },\n      { text: 'left lower eyelid', value: 31 },\n      { text: 'right upper eyelid', value: 32 },\n      { text: 'right lower eyelid', value: 33 }\n    ];\n\n    type DefineGoToFacePart = DefineBlock<PoseFace, Blocks[\"goToFacePartCommand\"]>;\n    const goToFacePartCommand: DefineGoToFacePart = () => ({\n      type: BlockType.Command,\n      arg: {\n        type: ArgumentType.Number,\n        options: {\n          acceptsReporters: true,\n          items: faceParts,\n          handler: (part: number) => {\n            return Math.min(Math.max(part, 0), 33);\n          }\n        }\n      },\n      text: (part: number) => `go to ${part}`,\n      operation: (part: number, util) => {\n        console.log('1')\n        this.affdexGoToPart(part, util)\n        console.log('2')\n      }\n    });\n\n    // EXPRESSION BLOCKS\n\n    const expressions = [\n      { text: 'smile', value: 'smile' },\n      { text: 'mouth open', value: 'mouthOpen' },\n      { text: 'eye closure', value: 'eyeClosure' },\n      { text: 'eyebrow raise', value: 'browRaise' },\n      { text: 'whistling', value: 'lipPucker' },\n      { text: 'eye widening', value: 'eyeWiden' },\n      // {text:'innerBrowRaise', value: 'innerBrowRaise'},\n      { text: 'eyebrow furrow', value: 'browFurrow' },\n      { text: 'nose wrinkle', value: 'noseWrinkle' },\n      { text: 'upper lip raise', value: 'upperLipRaise' },\n      { text: 'lip corner pull', value: 'lipCornerDepressor' },\n      { text: 'chin raise', value: 'chinRaise' },\n      // {text:'lip press', value:  'lipPress'},\n      // {text:'lip suck', value:  'lipSuck'},\n      { text: 'smirk', value: 'smirk' },\n      { text: 'attention', value: 'attention' },\n      { text: 'eyelid tighten', value: 'lidTighten' },\n      { text: 'jaw drop', value: 'jawDrop' },\n      { text: 'cheek dimple', value: 'dimpler' },\n      { text: 'cheek raise', value: 'cheekRaise' },\n      { text: 'lip stretch', value: 'lipStretch' }\n    ];\n    const handlerExpressions = expressions.map(expression => expression.value);\n\n    type DefineExpressDetect = DefineBlock<PoseFace, Blocks[\"whenExpressionDetectedHat\"]>;\n    const whenExpressionDetectedHat: DefineExpressDetect = () => ({\n      type: BlockType.Hat,\n      arg: {\n        type: ArgumentType.String,\n        options: {\n          acceptsReporters: true,\n          items: expressions,\n          handler: (expression: string) => {\n            return handlerExpressions.includes(expression) ? expression : 'smile';\n          }\n        }\n      },\n      text: (expression: string) => `when ${expression} detected`,\n      operation: (expression: string) => {\n        console.log('return')\n        return this.affdexIsExpression(expression);\n      }\n    });\n\n    type DefineAmountExpress = DefineBlock<PoseFace, Blocks[\"amountOfExpressionDetectedReport\"]>;\n    const amountOfExpressionDetectedReport: DefineAmountExpress = () => ({\n      type: BlockType.Reporter,\n      arg: {\n        type: ArgumentType.String,\n        options: {\n          acceptsReporters: true,\n          items: expressions,\n          handler: (expression: string) => {\n            return handlerExpressions.includes(expression) ? expression : 'smile';\n          }\n        }\n      },\n      text: (expression: string) => `amount of ${expression}`,\n      operation: (expression: string) => {\n        console.log('return')\n        return this.affdexExpressionAmount(expression);\n      }\n    });\n\n    type DefineExpressReport = DefineBlock<PoseFace, Blocks[\"isExpressionReport\"]>;\n    const isExpressionReport: DefineExpressReport = () => ({\n      type: BlockType.Boolean,\n      arg: {\n        type: ArgumentType.String,\n        options: {\n          acceptsReporters: true,\n          items: expressions,\n          handler: (expression: string) => {\n            return handlerExpressions.includes(expression) ? expression : 'smile';\n          }\n        }\n      },\n      text: (expression: string) => `expressing ${expression}`,\n      operation: (expression: string) => {\n        console.log('return')\n        return this.affdexIsExpression(expression);\n      }\n    });\n\n    // EMOTION BLOCKS\n\n    const emotions = [\n      { text: 'joyful', value: 'joy' },\n      { text: 'sad', value: 'sadness' },\n      { text: 'disgusted', value: 'disgust' },\n      { text: 'angry', value: 'anger' },\n      { text: 'fearful', value: 'fear' }\n    ];\n    const handlerEmotionsShort = emotions.map(emotion => emotion.value);\n\n    const emotions2 = [\n      { text: 'contempt', value: 'contempt' },\n      { text: 'surprise', value: 'surprise' },\n      { text: 'valence', value: 'valence' },\n      { text: 'engagement', value: 'engagement' }\n    ];\n    const allEmotionValues = emotions.concat(emotions2).map(emotion => emotion.value);\n\n    type DefineFeelingDetect = DefineBlock<PoseFace, Blocks[\"whenFeelingDetectedHat\"]>;\n    const whenFeelingDetectedHat: DefineFeelingDetect = () => ({\n      type: BlockType.Hat,\n      arg: {\n        type: ArgumentType.String,\n        options: {\n          acceptsReporters: true,\n          items: emotions,\n          handler: (emotion: string) => {\n            return handlerEmotionsShort.includes(emotion) ? emotion : 'joy';\n          }\n        }\n      },\n      text: (emotion: string) => `when ${emotion} feeling detected`,\n      operation: (emotion: string) => {\n        console.log('return')\n\n        return this.affdexIsTopEmotion(emotion, emotions);\n      }\n    });\n\n    type DefineLevelFeeling = DefineBlock<PoseFace, Blocks[\"levelOfFeelingReport\"]>;\n    const levelOfFeelingReport: DefineLevelFeeling = () => ({\n      type: BlockType.Reporter,\n      arg: {\n        type: ArgumentType.String,\n        options: {\n          acceptsReporters: true,\n          items: allEmotionValues,\n          handler: (emotion: string) => {\n            console.log('return')\n\n            return allEmotionValues.includes(emotion) ? emotion : 'joy';\n          }\n        }\n      },\n      text: (emotion: string) => `level of ${emotion}`,\n      operation: (emotion: string) => {\n        return this.affdexEmotionAmount(emotion)\n      }\n    });\n\n    type DefineIsFeeling = DefineBlock<PoseFace, Blocks[\"isFeelingReport\"]>;\n    const isFeelingReport: DefineIsFeeling = () => ({\n      type: BlockType.Boolean,\n      arg: {\n        type: ArgumentType.String,\n        options: {\n          acceptsReporters: true,\n          items: emotions,\n          handler: (emotion: string) => {\n            return handlerEmotionsShort.includes(emotion) ? emotion : 'joy';\n          }\n        }\n      },\n      text: (emotion: string) => `feeling ${emotion}`,\n      operation: (emotion: string) => {\n        console.log('return')\n\n        return this.affdexIsTopEmotion(emotion, emotions);\n      }\n    });\n\n    // VIDEO BLOCKS\n\n    type DefineVideoToggle = DefineBlock<PoseFace, Blocks[\"videoToggleBlock\"]>;\n    const videoToggleBlock: DefineVideoToggle = () => ({\n      type: BlockType.Command,\n      arg: {\n        type: ArgumentType.Number,\n        options: {\n          acceptsReporters: true,\n          items: [{ text: 'off', value: VideoState.OFF }, { text: 'on', value: VideoState.ON }, { text: 'on and flipped', value: VideoState.ON_FLIPPED }],\n          handler: (video_state: number) => {\n            return Math.min(Math.max(video_state, VideoState.OFF), VideoState.ON_FLIPPED);\n          }\n        }\n      },\n      text: (video_state: number) => `turn video ${video_state}`,\n      operation: (video_state: number) => {\n        this.videoToggle(video_state);\n      }\n    });\n\n    type DefineSetVideoTransparency = DefineBlock<PoseFace, Blocks[\"setVideoTransparencyBlock\"]>;\n    const setVideoTransparencyBlock: DefineSetVideoTransparency = () => ({\n      type: BlockType.Command,\n      arg: { type: ArgumentType.Number, defaultValue: 50 },\n      text: (transparency: number) => `set video transparency to ${transparency}`,\n      operation: (transparency: number) => {\n        this.setVideoTransparency(transparency);\n      }\n    });\n\n    return {\n      goToFacePartCommand,\n      whenExpressionDetectedHat,\n      amountOfExpressionDetectedReport,\n      isExpressionReport,\n      whenFeelingDetectedHat,\n      levelOfFeelingReport,\n      isFeelingReport,\n      videoToggleBlock,\n      setVideoTransparencyBlock\n    }\n  }\n}\n"],"names":["poseFace","exports","$common","VideoState","friendlyRound","amount","parseFloat","Number","toFixed","PoseFace","Extension","internal_getCodeGenArgs","id","name","blockIconURI","init","env","this","runtime","ioDevices","_loop","DIMENSIONS","projectStarted","setVideoTransparency","globalVideoTransparency","videoToggle","globalVideoState","affdexCoordsToScratch","x","y","console","log","async","frame","video","getFrame","format","dimensions","time","Date","affdexState","estimateAffdexOnImage","estimateThrottleTimeout","Promise","r","setTimeout","isConnected","hasResult","imageElement","affdexDetector","ensureAffdexLoaded","process","resolve","reject","resultListener","faces","image","timestamp","removeEventListener","length","addEventListener","affdex","untilExternalGlobalVariableLoaded","affdexStarter","width","height","faceMode","FaceDetectorMode","LARGE_FACES","detector","PhotoDetector","detectAllEmotions","detectAllExpressions","start","affdexGoToPart","part","util","featurePoints","featurePoint","setXY","affdexIsExpression","expression","expressions","affdexExpressionAmount","affdexIsTopEmotion","emotion","emotions","maxEmotionValue","MAX_VALUE","maxEmotion","forEach","emotionValue","affdexEmotionAmount","state","disableVideo","enableVideo","mirror","transparency","trans","Math","max","min","setPreviewGhost","defineBlocks","faceParts","text","value","handlerExpressions","map","handlerEmotionsShort","allEmotionValues","concat","goToFacePartCommand","type","BlockType","Command","arg","ArgumentType","options","acceptsReporters","items","handler","operation","whenExpressionDetectedHat","Hat","String","includes","amountOfExpressionDetectedReport","Reporter","isExpressionReport","Boolean","whenFeelingDetectedHat","levelOfFeelingReport","isFeelingReport","videoToggleBlock","video_state","setVideoTransparencyBlock","defaultValue"],"mappings":"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"}