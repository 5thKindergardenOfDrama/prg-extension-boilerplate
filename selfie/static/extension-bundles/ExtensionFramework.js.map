{"version":3,"file":"ExtensionFramework.js","sources":["../../../../extensions/src/common/types/enums.ts","../../../../extensions/src/common/utils.ts","../../../../extensions/src/common/globals.ts","../../../../extensions/src/common/ui.ts","../../../../extensions/src/common/IDs.ts","../../../../extensions/src/common/extension/mixins/optional/customSaveData.ts","../../../scratch-vm/src/util/color.js","../../../scratch-vm/src/util/cast.js","../../../../extensions/src/common/cast.ts","../../../../extensions/src/common/extension/mixins/optional/customArguments/CustomArgumentManager.ts","../../../../extensions/src/common/extension/mixins/optional/customArguments/dropdownOverride.ts","../../../../extensions/src/common/extension/mixins/optional/addCostumes/MockBitmapAdapter.ts","../../../../extensions/src/common/extension/mixins/optional/addCostumes/utils.ts","../../../../extensions/src/common/extension/mixins/optional/addCostumes/index.ts","../../../../extensions/src/common/extension/mixins/optional/customArguments/index.ts","../../../../extensions/src/common/extension/mixins/required/scratchInfo/menus.ts","../../../../extensions/src/common/extension/mixins/required/scratchInfo/util.ts","../../../../extensions/src/common/extension/mixins/required/scratchInfo/handlers.ts","../../../../extensions/src/common/extension/mixins/required/scratchInfo/args.ts","../../../../extensions/src/common/extension/mixins/required/scratchInfo/text.ts","../../../../extensions/src/common/extension/mixins/required/scratchInfo/index.ts","../../../../extensions/src/common/extension/decorators/blocks.ts","../../../../extensions/src/common/extension/decorators/legacySupport/index.ts","../../../../extensions/src/common/extension/mixins/optional/legacySupport.ts","../../../../extensions/src/common/extension/mixins/optional/video.ts","../../../../extensions/src/common/extension/mixins/index.ts","../../../../extensions/src/common/extension/mixins/optional/ui.ts","../../../../extensions/src/common/extension/mixins/optional/drawable.ts","../../../../extensions/src/common/extension/ExtensionBase.ts","../../../../extensions/src/common/extension/mixins/dependencies.ts","../../../../extensions/src/common/extension/index.ts","../../../../extensions/src/common/extension/mixins/required/supported.ts","../../../../extensions/src/common/extension/GenericExtension.ts","../../../../extensions/src/common/extension/decorators/validators.ts"],"sourcesContent":["import { ValueOf } from \"../types\";\n\n/**\n * The different kind of blocks that an extension can define\n */\nexport const BlockType = {\n  /**\n   * Boolean reporter with hexagonal shape\n   */\n  Boolean: 'Boolean',\n\n  /**\n   * A button (not an actual block) for some special action, like making a variable\n   */\n  Button: 'button',\n\n  /**\n   * Command block\n   */\n  Command: 'command',\n\n  /**\n   * Specialized command block which may or may not run a child branch\n   * The thread continues with the next block whether or not a child branch ran.\n   */\n  Conditional: 'conditional',\n\n  /**\n   * Specialized hat block with no implementation function\n   * This stack only runs if the corresponding event is emitted by other code.\n   */\n  Event: 'event',\n\n  /**\n   * Hat block which conditionally starts a block stack\n   */\n  Hat: 'hat',\n\n  /**\n   * Specialized command block which may or may not run a child branch\n   * If a child branch runs, the thread evaluates the loop block again.\n   */\n  Loop: 'loop',\n\n  /**\n   * General reporter with numeric or string value\n   */\n  Reporter: 'reporter'\n} as const;\n\nexport const ArgumentType = {\n  /** Numeric value with angle picker. */\n  Angle: \"angle\",\n\n  /** Boolean value with hexagonal placeholder. */\n  Boolean: \"Boolean\",\n\n  /** Numeric value with color picker. */\n  Color: \"color\",\n\n  /** Numeric value with text field. */\n  Number: \"number\",\n\n  /** String value with text field. */\n  String: \"string\",\n\n  /** String value with matrix field. */\n  Matrix: \"matrix\",\n\n  /** MIDI note number with note picker (piano) field. */\n  Note: \"note\",\n\n  /** Inline image on block (as part of the label). */\n  Image: \"image\",\n\n  /** Type added by PRG to support custom arguments */\n  Custom: \"custom\"\n} as const;\n\n/**\n * Default types of Target supported by the VM\n * @enum {string} as const;\n */\nexport const TargetType = {\n  /**\n   * Rendered target which can move, change costumes, etc.\n   */\n  Sprite: 'sprite',\n\n  /**\n   * Rendered target which cannot move but can change backdrops\n   */\n  Stage: 'stage'\n} as const;\n\n/**\n * These constants are copied from scratch-blocks/core/constants.js\n * @TODO find a way to require() these straight from scratch-blocks... maybe make a scratch-blocks/dist/constants.js?\n * @readonly\n * @enum {int} as const;\n */\nexport const ScratchBlocksConstants = {\n  /**\n   * ENUM for output shape: hexagonal (booleans/predicates).\n   * @const\n   */\n  OutputShapeHexagonal: 1,\n\n  /**\n   * ENUM for output shape: rounded (numbers).\n   * @const\n   */\n  OutputShapeRound: 2,\n\n  /**\n   * ENUM for output shape: squared (any/all values; strings).\n   * @const\n   */\n  OutputShapeSquare: 3\n} as const;\n\nexport const StageLayering = {\n  BackgroundLayer: 'background',\n  VideoLayer: 'video',\n  PenLayer: 'pen',\n  SpriteLayer: 'sprite',\n} as const;\n\nexport const LayerGroups: readonly ValueOf<typeof StageLayering>[] = [\n  StageLayering.VideoLayer,\n  StageLayering.SpriteLayer,\n  StageLayering.BackgroundLayer,\n  StageLayering.PenLayer,\n] as const;\n\nexport const VariableType = {\n  /**\n   * Type representation for scalar variables.\n   * This is currently represented as ''\n   * for compatibility with blockly.\n   */\n  Scalar: '',\n  /**\n   * Type representation for list variables.\n   */\n  List: 'list',\n\n  BrooadcastMessage: 'broadcast_msg'\n} as const;\n\nexport const Branch = {\n  Exit: 0,\n  Enter: 1,\n  First: 1,\n  Second: 2,\n  Third: 3,\n  Fourth: 4,\n  Fifth: 5,\n  Sixth: 6,\n  Seventh: 7\n} as const;\n\nexport const Language = {\n  Аҧсшәа: 'ab',\n  العربية: 'ar',\n  አማርኛ: 'am',\n  Azeri: 'az',\n  Bahasa_Indonesia: 'id',\n  Беларуская: 'be',\n  Български: 'bg',\n  Català: 'ca',\n  Česky: 'cs',\n  Cymraeg: 'cy',\n  Dansk: 'da',\n  Deutsch: 'de',\n  Eesti: 'et',\n  Ελληνικά: 'el',\n  English: 'en',\n  Español: 'es',\n  Español_Latinoamericano: 'es-419',\n  Euskara: 'eu',\n  فارسی: 'fa',\n  Français: 'fr',\n  Gaeilge: 'ga',\n  Gàidhlig: 'gd',\n  Galego: 'gl',\n  한국어: 'ko',\n  עִבְרִית: 'he',\n  Hrvatski: 'hr',\n  isiZulu: 'zu',\n  Íslenska: 'is',\n  Italiano: 'it',\n  ქართული_ენა: 'ka',\n  Kiswahili: 'sw',\n  Kreyòl_ayisyen: 'ht',\n  کوردیی_ناوەندی: 'ckb',\n  Latviešu: 'lv',\n  Lietuvių: 'lt',\n  Magyar: 'hu',\n  Māori: 'mi',\n  Nederlands: 'nl',\n  日本語: 'ja',\n  にほんご: 'ja-Hira',\n  Norsk_Bokmål: 'nb',\n  Norsk_Nynorsk: 'nn',\n  Oʻzbekcha: 'uz',\n  ไทย: 'th',\n  ភាសាខ្មែរ: 'km',\n  Polski: 'pl',\n  Português: 'pt',\n  Português_Brasileiro: 'pt-br',\n  Rapa_Nui: 'rap',\n  Română: 'ro',\n  Русский: 'ru',\n  Српски: 'sr',\n  Slovenčina: 'sk',\n  Slovenščina: 'sl',\n  Suomi: 'fi',\n  Svenska: 'sv',\n  Tiếng_Việt: 'vi',\n  Türkçe: 'tr',\n  Українська: 'uk',\n  简体中文: 'zh-cn',\n  繁體中文: 'zh-tw'\n} as const;\n\nexport const LanguageKeys = Object.keys(Language);\n\nexport const RuntimeEvent = {\n  /**\n   * Event name for glowing a script.\n   */\n  ScriptGlowOn: 'SCRIPT_GLOW_ON',\n  /**\n   * Event name for unglowing a script.\n   */\n  ScriptGlowOff: 'SCRIPT_GLOW_OFF',\n  /**\n   * Event name for glowing a block.\n   */\n  BlockGlowOn: 'BLOCK_GLOW_ON',\n  /**\n   * Event name for unglowing a block.\n   */\n  BlockGlowOff: 'BLOCK_GLOW_OFF',\n  /**\n   * Event name for a cloud data update to this project.\n   */\n  HasCloudDataUpdate: 'HAS_CLOUD_DATA_UPDATE',\n  /**\n   * Event name for turning on turbo mode.\n   */\n  TurboModeOn: 'TURBO_MODE_ON',\n  /**\n   * Event name for turning off turbo mode.\n   */\n  TurboModeOff: 'TURBO_MODE_OFF',\n  /**\n   * Event name for turning on turbo mode.\n   */\n  RecordingOn: 'RECORDING_ON',\n  /**\n   * Event name for turning off turbo mode.\n   */\n  RecordingOff: 'RECORDING_OFF',\n  /**\n   * Event name when the project is started (threads may not necessarily be running).\n   */\n  ProjectStart: 'PROJECT_START',\n  /**\n   * Event name when threads start running.\n   * Used by the UI to indicate running status.\n   */\n  ProjectRunStart: 'PROJECT_RUN_START',\n  /**\n   * Event name when threads stop running\n   * Used by the UI to indicate not-running status.\n   */\n  ProjectRunStop: 'PROJECT_RUN_STOP',\n  /**\n   * Event name for project being stopped or restarted by the user.\n   * Used by blocks that need to reset state.\n   */\n  ProjectStopAll: 'PROJECT_STOP_ALL',\n  /**\n   * Event name for target being stopped by a stop for target call.\n   * Used by blocks that need to stop individual targets.\n   */\n  StopForTarget: 'STOP_FOR_TARGET',\n  /**\n   * Event name for visual value report.\n   */\n  VisualReport: 'VISUAL_REPORT',\n  /**\n   * Event name for project loaded report.\n   */\n  ProjectLoaded: 'PROJECT_LOADED',\n  /**\n   * Event name for report that a change was made that can be saved\n   */\n  ProjectChanged: 'PROJECT_CHANGED',\n  /**\n   * Event name for report that a change was made to an extension in the toolbox.\n   */\n  ToolboxExtensionsNeedUpdate: 'TOOLBOX_EXTENSIONS_NEED_UPDATE',\n  /**\n   * Event name for targets update report.\n   */\n  TargetsUpdate: 'TARGETS_UPDATE',\n  /**\n   * Event name for monitors update.\n   */\n  MonitorsUpdate: 'MONITORS_UPDATE',\n  /**\n   * Event name for block drag update.\n   */\n  BlockDragUpdate: 'BLOCK_DRAG_UPDATE',\n  /**\n   * Event name for block drag end.\n   */\n  BlockDragEnd: 'BLOCK_DRAG_END',\n  /**\n   * Event name for reporting that an extension was added.\n   */\n  ExtensionAdded: 'EXTENSION_ADDED',\n  /**\n   * Event name for reporting that an extension as asked for a custom field to be added\n   */\n  ExtensionFieldAdded: 'EXTENSION_FIELD_ADDED',\n  /**\n   * Event name for updating the available set of peripheral devices.\n   * This causes the peripheral connection modal to update a list of available peripherals.\n   */\n  PeripheralListUpdate: 'PERIPHERAL_LIST_UPDATE',\n  /**\n   * Event name for reporting that a peripheral has connected.\n   * This causes the status button in the blocks menu to indicate 'connected'.\n   */\n  PeripheralConnected: 'PERIPHERAL_CONNECTED',\n  /**\n   * Event name for reporting that a peripheral has been intentionally disconnected.\n   * This causes the status button in the blocks menu to indicate 'disconnected'.\n   */\n  PeripheralDisconnected: 'PERIPHERAL_DISCONNECTED',\n  /**\n   * Event name for reporting that a peripheral has encountered a request error.\n   * This causes the peripheral connection modal to switch to an error state.\n   */\n  PeripheralRequestError: 'PERIPHERAL_REQUEST_ERROR',\n  /**\n   * Event name for reporting that a peripheral connection has been lost.\n   * This causes a 'peripheral connection lost' error alert to display.\n   */\n  PeripheralConnectionLostError: 'PERIPHERAL_CONNECTION_LOST_ERROR',\n  /**\n   * Event name for reporting that a peripheral has not been discovered.\n   * This causes the peripheral connection modal to show a timeout state.\n   */\n  PeripheralScanTimeout: 'PERIPHERAL_SCAN_TIMEOUT',\n  /**\n   * Event name to indicate that the microphone is being used to stream audio.\n   */\n  MicListening: 'MIC_LISTENING',\n  /**\n   * Event name for reporting that blocksInfo was updated.\n   */\n  BlocksInfoUpdate: 'BLOCKSINFO_UPDATE',\n  /**\n   * Event name when the runtime tick loop has been started.\n   */\n  RuntimeStarted: 'RUNTIME_STARTED',\n  /**\n   * Event name when the runtime dispose has been called.\n   */\n  RuntimeDisposed: 'RUNTIME_DISPOSED',\n  /**\n   * Event name for reporting that a block was updated and needs to be rerendered.\n   */\n  BlocksNeedUpdate: 'BLOCKS_NEED_UPDATE',\n} as const;\n","import { MenuItem, Primitive, RGBObject } from \"./types\"\n\ntype FetchParams = {\n  request: Parameters<typeof fetch>[0],\n  options: Parameters<typeof fetch>[1]\n}\n\nexport const getValueFromMenuItem = <T>(item: MenuItem<T>) => typeof item === \"object\" ? (item as { value: T }).value : item;\n\nexport const getTextFromMenuItem = <T>(item: MenuItem<T>) => typeof item === \"object\" ? (item as { text: string }).text : item;\n\nexport async function fetchWithTimeout(\n  resource: FetchParams[\"request\"],\n  options: FetchParams[\"options\"] & { timeout: number }\n) {\n  const { timeout } = options;\n\n  const controller = new AbortController();\n  const id = setTimeout(() => controller.abort(), timeout);\n\n  const response = await fetch(resource, {\n    ...options,\n    signal: controller.signal\n  });\n\n  clearTimeout(id);\n\n  return response;\n}\n\nexport async function untilTimePassed(timeMs: number) {\n  return await new Promise((resolve) => setTimeout(resolve, timeMs));\n}\n\nexport async function untilObject<T>(getter: () => T, delay: number = 100): Promise<T> {\n  let timeout: NodeJS.Timeout;\n  let value: T = getter();\n  while (!value) {\n    await new Promise(resolve => {\n      clearTimeout(timeout);\n      timeout = setTimeout(resolve, delay);\n    });\n    value = getter();\n  }\n  clearTimeout(timeout);\n  return value;\n}\n\nexport async function untilCondition(condition: () => boolean, delay: number = 100): Promise<void> {\n  let timeout: NodeJS.Timeout;\n  while (!condition()) {\n    await new Promise(resolve => {\n      clearTimeout(timeout);\n      timeout = setTimeout(resolve, delay);\n    });\n  }\n  clearTimeout(timeout);\n};\n\nexport async function untilReady<T extends { ready: boolean }>(obj: T, delay: number = 100): Promise<void> {\n  let timeout: NodeJS.Timeout;\n  while (!obj.ready) {\n    await new Promise(resolve => {\n      clearTimeout(timeout);\n      timeout = setTimeout(resolve, delay);\n    });\n  }\n  clearTimeout(timeout);\n};\n\nexport const isString = (query: any): query is string => typeof query === 'string' || query instanceof String;\n\nexport const isFunction = (query: any): query is (...args: any[]) => any =>\n  Object.prototype.toString.call(query) === \"[object Function]\"\n  || \"function\" === typeof query\n  || query instanceof Function;\n\nexport const isPrimitive = (query: any): query is Primitive => query !== Object(query);\n\nexport const splitOnCapitals = (query: string) => query.split(/(?=[A-Z])/);\n\n/**\n * A type safe utility function for copy values from one object to another\n * @param param0 object containing the target to copy values to and the source of the values to copy\n */\nexport const copyTo = <TTarget extends object, TSource extends { [k in keyof TTarget]?: TTarget[k] }>({ target, source }: { target: TTarget, source: TSource }) => {\n  for (const key in source) {\n    if (!(key in target)) continue;\n    // @ts-ignore -- the types of the function should ensure this is valid TS\n    target[key] = source[key]\n  }\n}\n\nexport const identity = (x: any) => x;\n\nexport const loadExternalScript = (url: string, onLoad: () => void, onError?: () => void) => {\n  const script = document.createElement('script');\n\n  script.onload = onLoad;\n\n  script.onerror = onError ?? (() => {\n    throw new Error(`Error loading endpoint: ${url}`)\n  });\n\n  script.src = url;\n  script.async = true;\n\n  document.body.appendChild(script);\n}\n\n/**\n * \n * @param url \n * @returns \n */\nexport const untilExternalScriptLoaded = async (url: string): Promise<void> => {\n  const scriptLoaded = new Promise((resolve, reject) => {\n    const script = document.createElement('script');\n    script.onload = resolve;\n    script.onerror = reject;\n    script.async = true;\n    script.src = url;\n    document.body.appendChild(script);\n  });\n  await scriptLoaded;\n  return;\n}\n\n/**\n * \n * @param url \n * @param globalVariableName \n * @returns \n */\nexport const untilExternalGlobalVariableLoaded = async <T>(url: string, globalVariableName: string): Promise<T> => {\n  if (window[globalVariableName]) return window[globalVariableName];\n  await untilExternalScriptLoaded(url);\n  return window[globalVariableName];\n}\n\n/**\n * Utilize javascript's \"call\" method (on Function.prototype) in a typesafe manner\n * @param fn \n * @param _this \n * @param args \n * @returns \n */\nexport const typesafeCall = <Args extends any[], Return, This, Fn extends (this: This, ...args: Args) => Return>(fn: Fn, _this: This, ...args: Args) => fn.call(_this, ...args) as Return;\n\nexport const set = <T extends object, K extends keyof T>(container: T, key: K, value: T[K]) => {\n  container[key] = value;\n  return container;\n}\n\nexport const assertSameLength = (...collections: any[][]) => {\n  const { size } = collections.reduce((set, { length }) => set.add(length), new Set<number>());\n  if (size !== 1) throw new Error(\"Zip failed because collections weren't equal length\");\n}\n\n/**\n * Convert a Scratch decimal color to a hex string, #RRGGBB.\n * @param {number} decimal RGB color as a decimal.\n * @return {string} RGB color as #RRGGBB hex string.\n */\nconst decimalToHex = (decimal: number) => {\n  if (decimal < 0) {\n    decimal += 0xFFFFFF + 1;\n  }\n  let hex = Number(decimal).toString(16);\n  hex = `#${'000000'.substr(0, 6 - hex.length)}${hex}`;\n  return hex;\n}\n\n/**\n * Convert an RGB color object to a Scratch decimal color.\n * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n * @return {!number} Number representing the color.\n */\nfunction rgbToDecimal(rgb: RGBObject) {\n  return (rgb.r << 16) + (rgb.g << 8) + rgb.b;\n}\n\n/**\n * Convert an RGB color object to a hex color.\n * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n * @return {!string} Hex representation of the color.\n */\nexport const rgbToHex = (rgb: RGBObject) => {\n  return decimalToHex(rgbToDecimal(rgb));\n}","export const openUIEvent = \"OPEN_UI_FROM_EXTENSION\";\nexport const registerButtonCallbackEvent = \"REGISTER_BUTTON_CALLBACK_FROM_EXTENSION\";\nexport const FrameworkID = \"ExtensionFramework\";\n\nexport const customArgumentFlag = \"internal_IsCustomArgument\";\nexport const customArgumentCheck = \"isCustomArgumentHack\";\nexport const dropdownStateFlag = \"dropdownState\";\nexport const dropdownEntryFlag = \"dropdownEntry\";\nexport const initDropdownState = \"init\";\nexport const openDropdownState = \"open\";\nexport const closeDropdownState = \"close\"; ","import Runtime from \"$scratch-vm/engine/runtime\";\nimport { Extension as BaseExtension } from \"./extension/GenericExtension\";\nimport { openUIEvent, registerButtonCallbackEvent } from \"./globals\";\n\nexport type ReactivityDependency = any | any[];\n\nexport const activeClass = true;\n\nexport const px = (numberOf: number) => `${numberOf}px`;\n\ntype UniqueKeys<Extension> = Exclude<keyof Extension, keyof BaseExtension<any, any>>;\ntype Methods<Extension> = { [K in UniqueKeys<Extension>]-?: Extension[K] extends (...args: any) => any ? K : never };\ntype Properties<Extension> = { [K in UniqueKeys<Extension>]-?: Extension[K] extends (...args: any) => any ? never : K };\ntype MethodParams<Extension> = { [Key in UniqueKeys<Extension>]: Extension[Key] extends (...args: any) => any ? Parameters<Extension[Key]> : never };\ntype MethodReturns<Extension> = { [Key in UniqueKeys<Extension>]: Extension[Key] extends (...args: any) => any ? ReturnType<Extension[Key]> : never };\n\nexport type ReactiveInvoke<Extension> = <T extends keyof Methods<Extension>>(funcName: Methods<Extension>[T] extends never ? never : T, ...args: MethodParams<Extension>[T]) => MethodReturns<Extension>[T];\nexport type ReactiveSet<Extension> = <T extends keyof Properties<Extension>>(propertyName: Properties<Extension>[T] extends never ? never : T, value: Extension[T]) => void;\n\nexport type ReactiveMethods<Extension> = {\n  invoke: ReactiveInvoke<Extension>;\n  set: ReactiveSet<Extension>;\n}\n\nexport const reactiveInvoke = <Extension, T extends keyof Methods<Extension>>(extensionAssignment: Extension, funcName: T, args: MethodParams<Extension>[T]): MethodReturns<Extension>[T] => {\n  return (extensionAssignment[funcName] as Function)(...args as []);\n}\n\nexport const reactiveSet = <Extension, T extends keyof Properties<Extension>>(extensionAssignment: Extension, propertyName: T, value: Extension[T]): void => {\n  extensionAssignment[propertyName] = value;\n}\n\nexport const openUI = (runtime: Runtime, details: { id: string, name: string, component: string, label?: string }) => runtime.emit(openUIEvent, details);\n\nexport const registerButtonCallback = (runtime: Runtime, buttonID: string, callback: (...args: any[]) => void) => {\n  runtime.emit(registerButtonCallbackEvent, buttonID);\n  runtime.on(buttonID, callback);\n}\n\nconst enum Color {\n  ui = \"ui\",\n  text = \"text\",\n  motion = \"motion\",\n  red = \"red\",\n  sound = \"sound\",\n  control = \"control\",\n  data = \"data\",\n  pen = \"pen\",\n  error = \"error\",\n  extensions = \"extensions\",\n  drop = \"drop\"\n}\n\n/**\n * Makes it easier to reference the css color variables defined in prg-extension-boilerplate/packages/scratch-gui/src/components/programmatic-modal/programmatic-modal.jsx\n */\nclass CssVar {\n  root: Color;\n\n  constructor(root: Color) { this.root = root }\n\n  get(...parts: string[]) { return `var(--${this.root}-${parts.join(\"-\")})` }\n  primary(...parts: string[]) { return this.get(\"primary\", ...parts) }\n  secondary(...parts: string[]) { return this.get(\"secondary\", ...parts) }\n  tertiary(...parts: string[]) { return this.get(\"tertiary\", ...parts) }\n  transparent(...parts: string[]) { return this.get(\"transparent\", ...parts) }\n  light(...parts: string[]) { return this.get(\"light\", ...parts) }\n}\n\nconst ui = new CssVar(Color.ui);\nconst text = new CssVar(Color.text);\nconst motion = new CssVar(Color.motion);\nconst red = new CssVar(Color.red);\nconst sound = new CssVar(Color.sound);\nconst control = new CssVar(Color.control);\nconst data = new CssVar(Color.data);\nconst pen = new CssVar(Color.pen);\nconst error = new CssVar(Color.error);\nconst extensions = new CssVar(Color.extensions);\nconst drop = new CssVar(Color.extensions);\n\n/**\n * Color variable references corresponding to the css variables defined in prg-extension-boilerplate/packages/scratch-gui/src/components/programmatic-modal/programmatic-modal.jsx\n */\nexport const color = {\n  \"ui\": {\n    primary: ui.primary(),\n    secondary: ui.secondary(),\n    tertiary: ui.tertiary(),\n    modalOverlay: ui.get(\"modal\", \"overlay\"),\n    white: ui.get(\"white\"),\n    whiteDim: ui.get(\"white\", \"dim\"),\n    whiteTransparent: ui.get(\"white\", \"transparent\"),\n    transparent: ui.transparent(),\n    blackTransparent: ui.get(\"black\", \"transparent\"),\n  },\n  \"text\": {\n    primary: text.primary(),\n    primaryTransparent: text.transparent(),\n  },\n  \"motion\": {\n    primary: motion.primary(),\n    tertiary: motion.tertiary(),\n    transparent: motion.get(\"transparent\"),\n    lightTansparent: motion.light(\"transparent\"),\n  },\n  \"red\": {\n    primary: red.primary(),\n    tertiary: red.tertiary(),\n  },\n  \"sound\": {\n    primary: sound.primary(),\n    tertiary: sound.tertiary(),\n  },\n  \"control\": {\n    primary: control.primary(),\n  },\n  \"data\": {\n    primary: data.primary(),\n  },\n  \"pen\": {\n    primary: pen.primary(),\n    transparent: pen.transparent(),\n  },\n  \"error\": {\n    primary: error.primary(),\n    light: error.light(),\n    transparent: error.transparent(),\n  },\n  \"extensions\": {\n    primary: extensions.primary(),\n    tertiary: extensions.tertiary(),\n    light: extensions.light(),\n    transparent: extensions.transparent(),\n  },\n  \"drop\": {\n    highlight: drop.get(\"highlight\")\n  }\n}","const validRegEx = new RegExp('^[a-z0-9]+$', 'i');\nconst invalidRegEx = new RegExp('[^a-z0-9]+', 'gi');\n\nexport const isValidID = (id) => validRegEx.test(id);\n\nconst guard = 'prg';\nconst guards = [guard, guard.split(\"\").reverse().join(\"\")];\n\nconst guardsRegEx = new RegExp(`${guards[0]}([0-9]+)${guards[1]}`, 'g');\n\nconst wrap = (str) => `${guards[0]}${str}${guards[1]}`;\n\nconst replaceAll = (query, current, desired) => query.replaceAll(current, desired);\n\nexport const encode = (query: string): string => {\n  const matches = [...query.matchAll(invalidRegEx)];\n  const invalidCharacters = matches.reduce((set, current) => {\n    current[0].split(\"\").forEach(char => set.add(char));\n    return set;\n  }, new Set<string>());\n  const replacements = [...invalidCharacters].map(char => ({ char, code: char.charCodeAt(0) }));\n  return replacements.reduce((modified, { char, code }) => replaceAll(modified, char, wrap(code)), `${query}`);\n}\n\nexport const decode = (query: string): string => {\n  const matches = [...query.matchAll(guardsRegEx)];\n  const replacements = matches.reduce((replacements, match) => {\n    const [key, code] = match;\n    return replacements.set(key, String.fromCharCode(code as any as number));\n  }, new Map());\n  return [...replacements].reduce((modified, [current, desired]) => replaceAll(modified, current, desired), `${query}`);\n}","import { ExtensionBaseConstructor } from \"$common/extension/ExtensionBase\";\nimport { ExtensionBase } from \"../../ExtensionBase\";\nimport { BaseGenericExtension, NonAbstractConstructor } from \"$common/types\";\nimport { MinimalExtensionConstructor } from \"../required\";\nimport { ExtensionIntanceWithFunctionality, ExtensionWithFunctionality } from \"..\";\n\n/**\n * WARNING! If you change this key, it will affect already saved projects.\n * Do not rename this without first developing a mechanism for searching for previously used keys.\n */\nexport const saveDataKey = \"customSaveDataPerExtension\" as const;\n\n/**\n * @summary Utility class to assist in creating a (typesafe) object that, for a given Extension type, handles both:\n * - writing out data on save\n * - doing something with save data on load\n * \n * @description This class's constructor takes an object with both an `onSave` and an `onLoad` method\n * (and the `onSave`'s return type must match `onLoad`'s argument type)\n * @example\n * new SaveDataHandler({\n *    Extension: MyExtension,\n *    onSave: () => ({x: 0, y: 3}),\n *    onLoad: (data) => {\n *       const sum = data.x + data.y; // do something with saved data\n *    }\n * })\n */\nexport class SaveDataHandler<T extends BaseGenericExtension | ExtensionIntanceWithFunctionality<[\"customSaveData\"]>, TData> {\n  constructor(public hooks: {\n    // @ts-ignore\n    Extension: NonAbstractConstructor<T>,\n    onSave: (self: T) => TData,\n    onLoad: (self: T, data: TData) => void,\n  }) { }\n}\n\n/**\n * Mixin the ability for extensions to save and reload custom data (including any data related to custom arguments)\n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport default function mixin<T extends MinimalExtensionConstructor>(Ctor: T) {\n  abstract class ExtensionWithCustomSaveDataSupport extends Ctor {\n    /**\n     * Optional field that can be defined if you need to save custom data for an extension \n     * (like some extension specific variable, or an API endpoint).\n     * @example\n     * class Example extends Extension<..., ...> {\n     *    someValue = 5;\n     *    ...\n     *    saveDataHandler = new SaveDataHandler({\n     *      Extension: Example,\n     *      // NOTE: The type info for 'instance' could be left off in the line below\n     *      onSave: (instance: Example) => ({ valueToSave: instance.someValue }),\n     *      onLoad: (instance, data) => instance.someValue = data.valueToSave\n     *    })\n     * }\n     * @see Extension.MakeSaveDataHandler\n     */\n    protected saveDataHandler: SaveDataHandler<ExtensionWithCustomSaveDataSupport, any> = undefined;\n\n    /**\n     * Save function called 'internally' by the VM when serializing a project.\n     * @param toSave \n     * @param extensionIDs \n     * @returns \n     */\n    private save(toSave: { [saveDataKey]: Record<string, any> }, extensionIDs: Set<string>) {\n      const { saveDataHandler, id } = this;\n      const argumentManager = this.supports(\"customArguments\") ? this.customArgumentManager : null;\n      const saveData = saveDataHandler?.hooks.onSave(this) ?? {};\n      argumentManager?.saveTo(saveData);\n      if (Object.keys(saveData).length === 0) return;\n      const container = toSave[saveDataKey];\n      container ? (container[id] = saveData) : (toSave[saveDataKey] = { [id]: saveData });\n      extensionIDs.add(id);\n    }\n\n    /**\n     * Load function called 'internally' by the VM when loading a project.\n     * Will be invoked on an extension immediately after it is constructed.\n     * @param saved \n     * @returns \n     */\n    private load(saved: { [saveDataKey]: Record<string, any> }) {\n      if (!saved) return;\n      const { saveDataHandler, id } = this;\n      const saveData = saveDataKey in saved ? saved[saveDataKey][id] : null;\n      if (!saveData) return;\n      saveDataHandler?.hooks.onLoad(this, saveData);\n\n      if (this.supports(\"customArguments\")) this.getOrCreateCustomArgumentManager().loadFrom(saveData);\n    }\n  }\n  return ExtensionWithCustomSaveDataSupport;\n}","class Color {\n    /**\n     * @typedef {object} RGBObject - An object representing a color in RGB format.\n     * @property {number} r - the red component, in the range [0, 255].\n     * @property {number} g - the green component, in the range [0, 255].\n     * @property {number} b - the blue component, in the range [0, 255].\n     */\n\n    /**\n     * @typedef {object} HSVObject - An object representing a color in HSV format.\n     * @property {number} h - hue, in the range [0-359).\n     * @property {number} s - saturation, in the range [0,1].\n     * @property {number} v - value, in the range [0,1].\n     */\n\n    /** @type {RGBObject} */\n    static get RGB_BLACK () {\n        return {r: 0, g: 0, b: 0};\n    }\n\n    /** @type {RGBObject} */\n    static get RGB_WHITE () {\n        return {r: 255, g: 255, b: 255};\n    }\n\n    /**\n     * Convert a Scratch decimal color to a hex string, #RRGGBB.\n     * @param {number} decimal RGB color as a decimal.\n     * @return {string} RGB color as #RRGGBB hex string.\n     */\n    static decimalToHex (decimal) {\n        if (decimal < 0) {\n            decimal += 0xFFFFFF + 1;\n        }\n        let hex = Number(decimal).toString(16);\n        hex = `#${'000000'.substr(0, 6 - hex.length)}${hex}`;\n        return hex;\n    }\n\n    /**\n     * Convert a Scratch decimal color to an RGB color object.\n     * @param {number} decimal RGB color as decimal.\n     * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     */\n    static decimalToRgb (decimal) {\n        const a = (decimal >> 24) & 0xFF;\n        const r = (decimal >> 16) & 0xFF;\n        const g = (decimal >> 8) & 0xFF;\n        const b = decimal & 0xFF;\n        return {r: r, g: g, b: b, a: a > 0 ? a : 255};\n    }\n\n    /**\n     * Convert a hex color (e.g., F00, #03F, #0033FF) to an RGB color object.\n     * CC-BY-SA Tim Down:\n     * https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb\n     * @param {!string} hex Hex representation of the color.\n     * @return {RGBObject} null on failure, or rgb: {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     */\n    static hexToRgb (hex) {\n        const shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n        hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);\n        const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n        return result ? {\n            r: parseInt(result[1], 16),\n            g: parseInt(result[2], 16),\n            b: parseInt(result[3], 16)\n        } : null;\n    }\n\n    /**\n     * Convert an RGB color object to a hex color.\n     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     * @return {!string} Hex representation of the color.\n     */\n    static rgbToHex (rgb) {\n        return Color.decimalToHex(Color.rgbToDecimal(rgb));\n    }\n\n    /**\n     * Convert an RGB color object to a Scratch decimal color.\n     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     * @return {!number} Number representing the color.\n     */\n    static rgbToDecimal (rgb) {\n        return (rgb.r << 16) + (rgb.g << 8) + rgb.b;\n    }\n\n    /**\n    * Convert a hex color (e.g., F00, #03F, #0033FF) to a decimal color number.\n    * @param {!string} hex Hex representation of the color.\n    * @return {!number} Number representing the color.\n    */\n    static hexToDecimal (hex) {\n        return Color.rgbToDecimal(Color.hexToRgb(hex));\n    }\n\n    /**\n     * Convert an HSV color to RGB format.\n     * @param {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}\n     * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     */\n    static hsvToRgb (hsv) {\n        let h = hsv.h % 360;\n        if (h < 0) h += 360;\n        const s = Math.max(0, Math.min(hsv.s, 1));\n        const v = Math.max(0, Math.min(hsv.v, 1));\n\n        const i = Math.floor(h / 60);\n        const f = (h / 60) - i;\n        const p = v * (1 - s);\n        const q = v * (1 - (s * f));\n        const t = v * (1 - (s * (1 - f)));\n\n        let r;\n        let g;\n        let b;\n\n        switch (i) {\n        default:\n        case 0:\n            r = v;\n            g = t;\n            b = p;\n            break;\n        case 1:\n            r = q;\n            g = v;\n            b = p;\n            break;\n        case 2:\n            r = p;\n            g = v;\n            b = t;\n            break;\n        case 3:\n            r = p;\n            g = q;\n            b = v;\n            break;\n        case 4:\n            r = t;\n            g = p;\n            b = v;\n            break;\n        case 5:\n            r = v;\n            g = p;\n            b = q;\n            break;\n        }\n\n        return {\n            r: Math.floor(r * 255),\n            g: Math.floor(g * 255),\n            b: Math.floor(b * 255)\n        };\n    }\n\n    /**\n     * Convert an RGB color to HSV format.\n     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     * @return {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}\n     */\n    static rgbToHsv (rgb) {\n        const r = rgb.r / 255;\n        const g = rgb.g / 255;\n        const b = rgb.b / 255;\n        const x = Math.min(Math.min(r, g), b);\n        const v = Math.max(Math.max(r, g), b);\n\n        // For grays, hue will be arbitrarily reported as zero. Otherwise, calculate\n        let h = 0;\n        let s = 0;\n        if (x !== v) {\n            const f = (r === x) ? g - b : ((g === x) ? b - r : r - g);\n            const i = (r === x) ? 3 : ((g === x) ? 5 : 1);\n            h = ((i - (f / (v - x))) * 60) % 360;\n            s = (v - x) / v;\n        }\n\n        return {h: h, s: s, v: v};\n    }\n\n    /**\n     * Linear interpolation between rgb0 and rgb1.\n     * @param {RGBObject} rgb0 - the color corresponding to fraction1 <= 0.\n     * @param {RGBObject} rgb1 - the color corresponding to fraction1 >= 1.\n     * @param {number} fraction1 - the interpolation parameter. If this is 0.5, for example, mix the two colors equally.\n     * @return {RGBObject} the interpolated color.\n     */\n    static mixRgb (rgb0, rgb1, fraction1) {\n        if (fraction1 <= 0) return rgb0;\n        if (fraction1 >= 1) return rgb1;\n        const fraction0 = 1 - fraction1;\n        return {\n            r: (fraction0 * rgb0.r) + (fraction1 * rgb1.r),\n            g: (fraction0 * rgb0.g) + (fraction1 * rgb1.g),\n            b: (fraction0 * rgb0.b) + (fraction1 * rgb1.b)\n        };\n    }\n}\n\nmodule.exports = Color;\n","const Color = require('../util/color');\n\n/**\n * @fileoverview\n * Utilities for casting and comparing Scratch data-types.\n * Scratch behaves slightly differently from JavaScript in many respects,\n * and these differences should be encapsulated below.\n * For example, in Scratch, add(1, join(\"hello\", world\")) -> 1.\n * This is because \"hello world\" is cast to 0.\n * In JavaScript, 1 + Number(\"hello\" + \"world\") would give you NaN.\n * Use when coercing a value before computation.\n */\n\nclass Cast {\n    /**\n     * Scratch cast to number.\n     * Treats NaN as 0.\n     * In Scratch 2.0, this is captured by `interp.numArg.`\n     * @param {*} value Value to cast to number.\n     * @return {number} The Scratch-casted number value.\n     */\n    static toNumber (value) {\n        // If value is already a number we don't need to coerce it with\n        // Number().\n        if (typeof value === 'number') {\n            // Scratch treats NaN as 0, when needed as a number.\n            // E.g., 0 + NaN -> 0.\n            if (Number.isNaN(value)) {\n                return 0;\n            }\n            return value;\n        }\n        const n = Number(value);\n        if (Number.isNaN(n)) {\n            // Scratch treats NaN as 0, when needed as a number.\n            // E.g., 0 + NaN -> 0.\n            return 0;\n        }\n        return n;\n    }\n\n    /**\n     * Scratch cast to boolean.\n     * In Scratch 2.0, this is captured by `interp.boolArg.`\n     * Treats some string values differently from JavaScript.\n     * @param {*} value Value to cast to boolean.\n     * @return {boolean} The Scratch-casted boolean value.\n     */\n    static toBoolean (value) {\n        // Already a boolean?\n        if (typeof value === 'boolean') {\n            return value;\n        }\n        if (typeof value === 'string') {\n            // These specific strings are treated as false in Scratch.\n            if ((value === '') ||\n                (value === '0') ||\n                (value.toLowerCase() === 'false')) {\n                return false;\n            }\n            // All other strings treated as true.\n            return true;\n        }\n        // Coerce other values and numbers.\n        return Boolean(value);\n    }\n\n    /**\n     * Scratch cast to string.\n     * @param {*} value Value to cast to string.\n     * @return {string} The Scratch-casted string value.\n     */\n    static toString (value) {\n        return String(value);\n    }\n\n    /**\n     * Cast any Scratch argument to an RGB color array to be used for the renderer.\n     * @param {*} value Value to convert to RGB color array.\n     * @return {Array.<number>} [r,g,b], values between 0-255.\n     */\n    static toRgbColorList (value) {\n        const color = Cast.toRgbColorObject(value);\n        return [color.r, color.g, color.b];\n    }\n\n    /**\n     * Cast any Scratch argument to an RGB color object to be used for the renderer.\n     * @param {*} value Value to convert to RGB color object.\n     * @return {import(\"../typescript-support/types\").RGBObject} [r,g,b], values between 0-255.\n     */\n    static toRgbColorObject (value) {\n        let color;\n        if (typeof value === 'string' && value.substring(0, 1) === '#') {\n            color = Color.hexToRgb(value);\n            // If the color wasn't *actually* a hex color, cast to black\n            if (!color) color = {r: 0, g: 0, b: 0, a: 255};\n        } else {\n            color = Color.decimalToRgb(Cast.toNumber(value));\n        }\n        return color;\n    }\n\n    /**\n     * Determine if a Scratch argument is a white space string (or null / empty).\n     * @param {*} val value to check.\n     * @return {boolean} True if the argument is all white spaces or null / empty.\n     */\n    static isWhiteSpace (val) {\n        return val === null || (typeof val === 'string' && val.trim().length === 0);\n    }\n\n    /**\n     * Compare two values, using Scratch cast, case-insensitive string compare, etc.\n     * In Scratch 2.0, this is captured by `interp.compare.`\n     * @param {*} v1 First value to compare.\n     * @param {*} v2 Second value to compare.\n     * @returns {number} Negative number if v1 < v2; 0 if equal; positive otherwise.\n     */\n    static compare (v1, v2) {\n        let n1 = Number(v1);\n        let n2 = Number(v2);\n        if (n1 === 0 && Cast.isWhiteSpace(v1)) {\n            n1 = NaN;\n        } else if (n2 === 0 && Cast.isWhiteSpace(v2)) {\n            n2 = NaN;\n        }\n        if (isNaN(n1) || isNaN(n2)) {\n            // At least one argument can't be converted to a number.\n            // Scratch compares strings as case insensitive.\n            const s1 = String(v1).toLowerCase();\n            const s2 = String(v2).toLowerCase();\n            if (s1 < s2) {\n                return -1;\n            } else if (s1 > s2) {\n                return 1;\n            }\n            return 0;\n        }\n        // Handle the special case of Infinity\n        if (\n            (n1 === Infinity && n2 === Infinity) ||\n            (n1 === -Infinity && n2 === -Infinity)\n        ) {\n            return 0;\n        }\n        // Compare as numbers.\n        return n1 - n2;\n    }\n\n    /**\n     * Determine if a Scratch argument number represents a round integer.\n     * @param {*} val Value to check.\n     * @return {boolean} True if number looks like an integer.\n     */\n    static isInt (val) {\n        // Values that are already numbers.\n        if (typeof val === 'number') {\n            if (isNaN(val)) { // NaN is considered an integer.\n                return true;\n            }\n            // True if it's \"round\" (e.g., 2.0 and 2).\n            return val === parseInt(val, 10);\n        } else if (typeof val === 'boolean') {\n            // `True` and `false` always represent integer after Scratch cast.\n            return true;\n        } else if (typeof val === 'string') {\n            // If it contains a decimal point, don't consider it an int.\n            return val.indexOf('.') < 0;\n        }\n        return false;\n    }\n\n    static get LIST_INVALID () {\n        return 'INVALID';\n    }\n\n    static get LIST_ALL () {\n        return 'ALL';\n    }\n\n    /**\n     * Compute a 1-based index into a list, based on a Scratch argument.\n     * Two special cases may be returned:\n     * LIST_ALL: if the block is referring to all of the items in the list.\n     * LIST_INVALID: if the index was invalid in any way.\n     * @param {*} index Scratch arg, including 1-based numbers or special cases.\n     * @param {number} length Length of the list.\n     * @param {boolean} acceptAll Whether it should accept \"all\" or not.\n     * @return {(number|string)} 1-based index for list, LIST_ALL, or LIST_INVALID.\n     */\n    static toListIndex (index, length, acceptAll) {\n        if (typeof index !== 'number') {\n            if (index === 'all') {\n                return acceptAll ? Cast.LIST_ALL : Cast.LIST_INVALID;\n            }\n            if (index === 'last') {\n                if (length > 0) {\n                    return length;\n                }\n                return Cast.LIST_INVALID;\n            } else if (index === 'random' || index === 'any') {\n                if (length > 0) {\n                    return 1 + Math.floor(Math.random() * length);\n                }\n                return Cast.LIST_INVALID;\n            }\n        }\n        index = Math.floor(Cast.toNumber(index));\n        if (index < 1 || index > length) {\n            return Cast.LIST_INVALID;\n        }\n        return index;\n    }\n}\n\nmodule.exports = Cast;\n","import { ArgumentType } from \"./types/enums\";\nimport { RGBObject, TypeByArgumentType, ValueOf } from \"./types\";\nimport Cast from '$scratch-vm/util/cast';\n\nexport const castToType = (argumentType: ValueOf<typeof ArgumentType>, value: any) => {\n  switch (argumentType) {\n    case ArgumentType.String:\n      return `${value}`;\n    case ArgumentType.Number:\n      return parseFloat(value);\n    case ArgumentType.Boolean:\n      return JSON.parse(value ?? false);\n    case ArgumentType.Note:\n      return parseInt(value);\n    case ArgumentType.Angle:\n      return parseInt(value);\n    case ArgumentType.Matrix:\n      return toMatrix(value);\n    case ArgumentType.Color:\n      return Cast.toRgbColorObject(value) as RGBObject;\n    default:\n      throw new Error(`Method not implemented for value of ${value} and type ${argumentType}`);\n  }\n}\n\nexport const tryCastToArgumentType = <T extends ValueOf<typeof ArgumentType>>(\n  argumentType: T,\n  value: any,\n  onFailure: (value: any) => TypeByArgumentType<T>\n): TypeByArgumentType<T> => {\n  try {\n    const casted = castToType(argumentType, value);\n    return casted as TypeByArgumentType<T>;\n  }\n  catch {\n    return onFailure(value);\n  }\n}\n\nconst toFlag = (value: string): boolean => parseInt(value) === 1;\n\nconst toMatrix = (matrixString: string): boolean[][] => {\n  if (matrixString.length !== 25) return new Array(5).fill(new Array(5).fill(false));\n\n  const entries = matrixString.split('');\n  const matrix = entries.map(toFlag).reduce((matrix, flag, index) => {\n    const row = Math.floor(index / 5);\n    const column = index % 5;\n    (column === 0) ? matrix[row] = [flag] : matrix[row].push(flag);\n    return matrix;\n  }, new Array<boolean[]>(5));\n\n  return matrix;\n}","export type ArgumentEntry<T> = { text: string, value: T };\nexport type ArgumentEntrySetter<T> = (entry: ArgumentEntry<T>) => void;\n\nexport default class CustomArgumentManager {\n  map: Map<string, ArgumentEntry<any>> = new Map();\n  pending: { id: string, entry: ArgumentEntry<any> } = null;\n\n  clearPending() { this.pending = null }\n  setPending(update: typeof this.pending) { this.pending = update }\n\n  add<T>(entry: ArgumentEntry<T>): string {\n    const id = CustomArgumentManager.GetIdentifier();\n    this.map.set(id, entry);\n    this.clearPending();\n    return id;\n  }\n\n  insert<T>(id: string, entry: ArgumentEntry<T>): string {\n    this.map.set(id, entry);\n    this.clearPending();\n    return id;\n  }\n\n  request<T>(): [string, ArgumentEntrySetter<T>] {\n    this.clearPending();\n    const id = CustomArgumentManager.GetIdentifier();\n    return [id, (entry) => this.setPending({ id, entry })];\n  }\n\n  tryResolve() {\n    if (!this.pending) return;\n    const { pending: { entry, id } } = this;\n    this.map.set(id, entry);\n    this.clearPending();\n    return { entry, id };\n  }\n\n  getCurrentEntries() {\n    return Array.from(this.map.entries())\n      .filter(([_, entry]) => entry !== null)\n      .map(([id, { text }]) => [text, id] as const);\n  }\n\n  getEntry(id: string) { return this.map.get(id) }\n\n  static SaveKey = \"internal_customArgumentsSaveData\" as const;\n\n  requiresSave() { this.map.size > 0 }\n\n  saveTo(obj: object) {\n    const entries = Array.from(this.map.entries())\n      .filter(([_, entry]) => entry !== null)\n      .map(([id, entry]) => ({ id, entry }));\n    if (entries.length === 0) return;\n    obj[CustomArgumentManager.SaveKey] = entries;\n  }\n\n  loadFrom(obj: Record<typeof CustomArgumentManager[\"SaveKey\"], { id: string, entry: ArgumentEntry<any> }[]>) {\n    obj[CustomArgumentManager.SaveKey]?.forEach(({ id, entry }) => {\n      this.map.set(id, entry);\n    });\n  }\n\n  /**\n   * @todo Implement this if it becomes necessary (i.e the every growing size of this.map becomes an issue)\n   */\n  private purgeStaleIDs() {\n    // Somehow, tap into blockly to loop through all current blocks & their field dropdowns.\n    // Collect all field dropdowns values. \n    // Then, loop over entries in this.map -- if the values don't appear in the collected in-use values, drop those items.\n    // NOTE: The blocks in the 'pallette' do not show up in a target's \"blocks\" object, which makes this tricky.\n  }\n\n  static IsIdentifier = (query: string) => query.startsWith(CustomArgumentManager.IdentifierPrefix);\n  private static GetIdentifier = () => CustomArgumentManager.IdentifierPrefix + new Date().getTime().toString();\n  private static IdentifierPrefix = \"__customArg__\";\n}","import { ExtensionInstance } from \"$common/extension\";\nimport { untilObject } from \"$common/utils\";\nimport { ArgumentEntry, ArgumentEntrySetter } from \"./CustomArgumentManager\";\n\n/** Constructed based on Svelte documentation: https://svelte.dev/docs#run-time-client-side-component-api-creating-a-component */\ntype CreateComponentOptions = {\n  target: Element | HTMLElement;\n  anchor?: Element | HTMLElement;\n  props: {};\n}\n\nexport type CustomArgumentUIConstructor = (options: CreateComponentOptions) => void;\n\nexport const renderToDropdown = async <T>(\n  compononentConstructor: CustomArgumentUIConstructor,\n  props: {\n    extension: ExtensionInstance,\n    setter: ArgumentEntrySetter<T>,\n    current: ArgumentEntry<T>\n  }\n) => {\n  const dropdownContainerClass = \"blocklyDropDownContent\";\n  const elements = document.getElementsByClassName(dropdownContainerClass);\n  if (elements.length !== 1) return console.error(`Uh oh! Expected 1 element with class '${dropdownContainerClass}', but found ${elements.length}`);\n  const [target] = elements;\n  const anchor = await untilObject(() => target.children[0]);\n  const component = new compononentConstructor({ target, anchor, props });\n  centerDropdownButton(anchor);\n}\n\nconst centerDropdownButton = (container: Element) => {\n  type ClassAndStyleModification = [string, (syle: CSSStyleDeclaration) => void];\n\n  const findElementAndModifyStyle = ([className, styleMod]: ClassAndStyleModification) => {\n    const elements = container.getElementsByClassName(className);\n    console.assert(elements.length === 1, `Incorrect number of elements found with class: ${className}`);\n    styleMod((elements[0] as HTMLElement).style);\n  };\n\n  const elements = [\n    [\n      \"goog-menuitem goog-option\",\n      (style) => {\n        style.margin = \"auto\";\n        style.paddingLeft = style.paddingRight = \"0px\";\n      }\n    ],\n    [\n      \"goog-menuitem-content\",\n      (style) => style.textAlign = \"center\"\n    ]\n  ] satisfies ClassAndStyleModification[];\n\n  elements.forEach(findElementAndModifyStyle);\n}","/**\n * Class adapted from: https://github.com/LLK/scratch-svg-renderer/blob/develop/src/bitmap-adapter.js\n */\nexport default class {\n  private makeImage() { return new Image() }\n  private makeCanvas() { return document.createElement('canvas') }\n\n  /**\n   * Return a canvas with the resized version of the given image, done using nearest-neighbor interpolation\n   * @param {CanvasImageSource} image The image to resize\n   * @param {int} newWidth The desired post-resize width of the image\n   * @param {int} newHeight The desired post-resize height of the image\n   * @returns {HTMLCanvasElement} A canvas with the resized image drawn on it.\n   */\n  resize(image, newWidth, newHeight) {\n    // We want to always resize using nearest-neighbor interpolation. However, canvas implementations are free to\n    // use linear interpolation (or other \"smooth\" interpolation methods) when downscaling:\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1360415\n    // It seems we can get around this by resizing in two steps: first width, then height. This will always result\n    // in nearest-neighbor interpolation, even when downscaling.\n    const stretchWidthCanvas = this.makeCanvas();\n    stretchWidthCanvas.width = newWidth;\n    stretchWidthCanvas.height = image.height;\n    let context = stretchWidthCanvas.getContext('2d');\n    context.imageSmoothingEnabled = false;\n    context.drawImage(image, 0, 0, stretchWidthCanvas.width, stretchWidthCanvas.height);\n    const stretchHeightCanvas = this.makeCanvas();\n    stretchHeightCanvas.width = newWidth;\n    stretchHeightCanvas.height = newHeight;\n    context = stretchHeightCanvas.getContext('2d');\n    context.imageSmoothingEnabled = false;\n    context.drawImage(stretchWidthCanvas, 0, 0, stretchHeightCanvas.width, stretchHeightCanvas.height);\n    return stretchHeightCanvas;\n  }\n\n  /**\n   * Scratch 2.0 had resolution 1 and 2 bitmaps. All bitmaps in Scratch 3.0 are equivalent\n   * to resolution 2 bitmaps. Therefore, converting a resolution 1 bitmap means doubling\n   * it in width and height.\n   * @param {!string} dataURI Base 64 encoded image data of the bitmap\n   * @param {!function} callback Node-style callback that returns updated dataURI if conversion succeeded\n   */\n  convertResolution1Bitmap(dataURI, callback) {\n    const image = new Image();\n    image.src = dataURI;\n    image.onload = () => {\n      callback(null, this.resize(image, image.width * 2, image.height * 2).toDataURL());\n    };\n    image.onerror = () => {\n      callback('Image load failed');\n    };\n  }\n\n  /**\n   * Given width/height of an uploaded item, return width/height the image will be resized\n   * to in Scratch 3.0\n   * @param {!number} oldWidth original width\n   * @param {!number} oldHeight original height\n   * @return {object} Array of new width, new height\n   */\n  getResizedWidthHeight(oldWidth, oldHeight) {\n    const STAGE_WIDTH = 480;\n    const STAGE_HEIGHT = 360;\n    const STAGE_RATIO = STAGE_WIDTH / STAGE_HEIGHT;\n\n    // If both dimensions are smaller than or equal to corresponding stage dimension,\n    // double both dimensions\n    if ((oldWidth <= STAGE_WIDTH) && (oldHeight <= STAGE_HEIGHT)) {\n      return { width: oldWidth * 2, height: oldHeight * 2 };\n    }\n\n    // If neither dimension is larger than 2x corresponding stage dimension,\n    // this is an in-between image, return it as is\n    if ((oldWidth <= STAGE_WIDTH * 2) && (oldHeight <= STAGE_HEIGHT * 2)) {\n      return { width: oldWidth, height: oldHeight };\n    }\n\n    const imageRatio = oldWidth / oldHeight;\n    // Otherwise, figure out how to resize\n    if (imageRatio >= STAGE_RATIO) {\n      // Wide Image\n      return { width: STAGE_WIDTH * 2, height: STAGE_WIDTH * 2 / imageRatio };\n    }\n    // In this case we have either:\n    // - A wide image, but not with as big a ratio between width and height,\n    // making it so that fitting the width to double stage size would leave\n    // the height too big to fit in double the stage height\n    // - A square image that's still larger than the double at least\n    // one of the stage dimensions, so pick the smaller of the two dimensions (to fit)\n    // - A tall image\n    // In any of these cases, resize the image to fit the height to double the stage height\n    return { width: STAGE_HEIGHT * 2 * imageRatio, height: STAGE_HEIGHT * 2 };\n  }\n\n  /**\n   * Given bitmap data, resize as necessary.\n   * @param {string} fileData Base 64 encoded image data of the bitmap\n   * @param {string} fileType The MIME type of this file\n   * @returns {Promise} Resolves to resized image data Uint8Array\n   */\n  importBitmap(dataURI: string): Promise<Uint8Array> {\n    return new Promise((resolve, reject) => {\n      const image = this.makeImage();\n      image.src = dataURI;\n      image.onload = () => {\n        const newSize = this.getResizedWidthHeight(image.width, image.height);\n        if (newSize.width === image.width && newSize.height === image.height) {\n          // No change\n          resolve(this.convertDataURIToBinary(dataURI));\n        } else {\n          const resizedDataURI = this.resize(image, newSize.width, newSize.height).toDataURL();\n          resolve(this.convertDataURIToBinary(resizedDataURI));\n        }\n      };\n      image.onerror = () => {\n        reject('Image load failed');\n      };\n    });\n  }\n\n  // TODO consolidate with scratch-vm/src/util/base64-util.js\n  // From https://gist.github.com/borismus/1032746\n  convertDataURIToBinary(dataURI) {\n    const BASE64_MARKER = ';base64,';\n    const base64Index = dataURI.indexOf(BASE64_MARKER) + BASE64_MARKER.length;\n    const base64 = dataURI.substring(base64Index);\n    const raw = window.atob(base64);\n    const rawLength = raw.length;\n    const array = new Uint8Array(new ArrayBuffer(rawLength));\n\n    for (let i = 0; i < rawLength; i++) {\n      array[i] = raw.charCodeAt(i);\n    }\n    return array;\n  }\n}","export const getUrlHelper = (dimensions: { width: number, height: number }) => {\n  const canvas = document.body.appendChild(document.createElement(\"canvas\"));\n\n  const setDimensions = ({ width, height }: Parameters<typeof getUrlHelper>[0]) => {\n    if (canvas.width !== width) canvas.width = width;\n    if (canvas.height !== height) canvas.height = height;\n  };\n\n  setDimensions(dimensions);\n\n  canvas.hidden = true;\n  const context = canvas.getContext(\"2d\");\n\n  return {\n    /**\n     * \n     * @param image \n     * @returns \n     */\n    getDataURL(image: ImageData) {\n      const { width, height } = image;\n      setDimensions(image);\n      context.save();\n      context.clearRect(0, 0, width, height);\n      context.putImageData(image, 0, 0);\n      const url = canvas.toDataURL('image/png');\n      context.restore();\n      return url;\n    }\n  }\n}","import type RenderedTarget from \"$scratch-vm/sprites/rendered-target\";\nimport Target from \"$scratch-vm/engine/target\";\nimport { MinimalExtensionConstructor } from \"../../required\";\nimport MockBitmapAdapter from \"./MockBitmapAdapter\";\nimport { getUrlHelper } from \"./utils\";\n\nlet bitmapAdapter: MockBitmapAdapter;\nlet urlHelper: ReturnType<typeof getUrlHelper>;\n\nconst rendererKey: keyof RenderedTarget = \"renderer\";\nconst isRenderedTarget = (target: Target | RenderedTarget): target is RenderedTarget => rendererKey in target;\n\n/**\n * Mixin the ability for extensions to add costumes to sprites\n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport default function <T extends MinimalExtensionConstructor>(Ctor: T) {\n  abstract class ExtensionWithCustomSupport extends Ctor {\n\n    /**\n     * Add a costume to the current sprite based on same image data\n     * @param {RenderedTarget} target (e.g. `util.target`)\n     * @param {ImageData} image What image to use to create the costume\n     * @param {\"add only\" | \"add and set\"} action What action should be applied\n     * - **_add only_**: generates the costume and append it it to the sprite's costume library\n     * - **_add and set_**: Both generate the costume (adding it to the sprite's costume library) and set it as the sprite's current costume\n     * @param {string?} name optional name to attach to the costume\n     */\n    async addCostume(target: Target, image: ImageData, action: \"add only\" | \"add and set\", name?: string) {\n      if (!isRenderedTarget(target)) return console.warn(\"Costume could not be added is the supplied target wasn't a rendered target\");\n\n      name ??= `${this.id}_generated_${Date.now()}`;\n      bitmapAdapter ??= new MockBitmapAdapter();\n      urlHelper ??= getUrlHelper(image);\n\n      // storage is of type: https://github.com/LLK/scratch-storage/blob/develop/src/ScratchStorage.js\n      const { storage } = this.runtime;\n      const dataFormat = storage.DataFormat.PNG;\n      const assetType = storage.AssetType.ImageBitmap;\n      const dataBuffer = await bitmapAdapter.importBitmap(urlHelper.getDataURL(image));\n\n      const asset = storage.createAsset(assetType, dataFormat, dataBuffer, null, true);\n      const { assetId } = asset;\n      const costume = { name, dataFormat, asset, md5: `${assetId}.${dataFormat}`, assetId };\n\n      await this.runtime.addCostume(costume);\n\n      const { length } = target.getCostumes();\n\n      target.addCostume(costume, length);\n      if (action === \"add and set\") target.setCostume(length);\n    }\n\n  }\n\n  return ExtensionWithCustomSupport;\n}\n","import type Runtime from \"$scratch-vm/engine/runtime\";\nimport CustomArgumentManager, { ArgumentEntry } from \"$common/extension/mixins/optional/customArguments/CustomArgumentManager\";\nimport { CustomArgumentUIConstructor, renderToDropdown } from \"$common/extension/mixins/optional/customArguments/dropdownOverride\";\nimport { ArgumentType } from \"$common/types/enums\";\nimport { openDropdownState, closeDropdownState, initDropdownState, customArgumentFlag, customArgumentCheck, dropdownStateFlag, dropdownEntryFlag } from \"$common/globals\";\nimport { Argument, BaseGenericExtension } from \"$common/types\";\nimport { MinimalExtensionConstructor } from \"../../required\";\nimport { WithDependencies } from \"../../dependencies\";\n\ntype ComponentGetter = (id: string, componentName: string) => CustomArgumentUIConstructor;\n\nconst callingContext = {\n  DrowpdownOpen: openDropdownState,\n  DropdownClose: closeDropdownState,\n  Init: initDropdownState,\n} as const;\n\n/**\n * Mixin the ability for extensions to create custom argument types with their own specific UIs\n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport default function mixin<T extends MinimalExtensionConstructor>(Ctor: T) {\n  abstract class ExtensionWithCustomArgumentSupport extends Ctor implements WithDependencies<[\"customSaveData\"]> {\n\n    getStaticDependencies() {\n      return [\"customSaveData\"] as const;\n    }\n\n    /**\n     * Create a custom argument for one of this block's arguments\n     * @param param0 \n     * - component: The svelte component to render the custom argument UI\n     * - initial: The starting value of the the custom argument (including both its value and text representation)\n     * - acceptReportersHandler: A function that must be defined if you'd like for your custom argument to accept reporters\n     * @returns \n     */\n    protected makeCustomArgument = <T>({ component, initial, acceptReportersHandler: handler }: { component: string, initial: ArgumentEntry<T>, acceptReportersHandler?: (x: any) => ArgumentEntry<T> }): Argument<T> => {\n      this.argumentManager ??= new CustomArgumentManager();\n      const id = this.argumentManager.add(initial);\n      const getItems = () => [{ text: customArgumentFlag, value: JSON.stringify({ component, id }) }];\n      return {\n        type: ArgumentType.Custom,\n        defaultValue: id,\n        options: handler === undefined ? getItems : { acceptsReports: true, getItems, handler },\n      } as Argument<T>\n    }\n\n    protected argumentManager: CustomArgumentManager = null;\n\n    public get customArgumentManager(): CustomArgumentManager {\n      return this.argumentManager\n    }\n\n    public getOrCreateCustomArgumentManager(): CustomArgumentManager {\n      this.argumentManager ??= new CustomArgumentManager();\n      return this.argumentManager;\n    }\n\n    /**\n     * Utilized externally by scratch-vm to check if a given argument should be treated as a 'custom argument'.\n     * Checks if the value returned by a dyanmic menu indicates that it should be treated as a 'custom argument'\n     */\n    private [customArgumentCheck](arr: Array<string | { text: string }>) {\n      if (arr.length !== 1) return false;\n      const item = arr[0];\n      if (typeof item !== \"object\") return false;\n      const { text } = item;\n      return text === customArgumentFlag;\n    };\n\n    /**\n     * Utilized externally by scratch-vm to process custom arguments\n     * @param runtime NOTE: once we switch to V2, we can remove this and instead use the extension's runtime\n     * @param param1 \n     * @param getComponent \n     * @returns \n     */\n    private processCustomArgumentHack(runtime: Runtime, [{ value }]: { value: string }[], getComponent: ComponentGetter): (readonly [string, string])[] {\n\n      const { id: extensionID, customArgumentManager: argumentManager } = this;\n      const { component, id: initialID } = JSON.parse(value) as { component: string, id: string };\n      const context = runtime[dropdownStateFlag];\n\n      switch (context) {\n        case callingContext.Init:\n          return argumentManager.getCurrentEntries();\n        case callingContext.DropdownClose: {\n          const result = argumentManager.tryResolve();\n          return result ? [[result.entry.text, result.id]] : argumentManager.getCurrentEntries();\n        }\n        case callingContext.DrowpdownOpen: {\n          const currentEntry = runtime[dropdownEntryFlag] as ArgumentEntry<any>;\n          const prevID = currentEntry?.value ?? initialID;\n          const current = argumentManager.getEntry(prevID);\n          const [id, setEntry] = argumentManager.request();\n          renderToDropdown(getComponent(extensionID, component), { setter: setEntry, current, extension: this as any as BaseGenericExtension });\n          return [[\"Apply\", id]];\n        }\n      }\n\n      throw new Error(\"Error during processing -- Context:\" + callingContext);\n    };\n\n  }\n  return ExtensionWithCustomArgumentSupport;\n}","import { MenuThatAcceptsReporters, DynamicMenuThatAcceptsReporters, Menu, MenuItem, DynamicMenu, ExtensionMenuMetadata, ExtensionArgumentMetadata } from \"$common/types\";\nimport { isFunction, isPrimitive } from \"$common/utils\";\n\nconst reporterItemsKey: keyof MenuThatAcceptsReporters<any> = \"items\";\nconst reporterItemsGetterKey: keyof DynamicMenuThatAcceptsReporters<any> = \"getItems\";\n\nexport const menuProbe = {\n  isSimpleStatic: (menu: Menu<any>): menu is any[] | MenuItem<any>[] => Array.isArray(menu),\n  isSimpleDynamic: (menu: Menu<any>): menu is DynamicMenu<any> => isFunction(menu),\n  isStaticWithReporters: (menu: Menu<any>): menu is MenuThatAcceptsReporters<any> => reporterItemsKey in menu,\n  isDynamicWithReporters: (menu: Menu<any>): menu is DynamicMenuThatAcceptsReporters<any> => reporterItemsGetterKey in menu,\n}\n\nexport const getMenuName = (index: number) => `${index}`;\n\nexport const convertMenuItemsToString = (item: any | MenuItem<any>) =>\n  isPrimitive(item) ? `${item}` : { ...item, value: `${item.value}` };\n\nexport const asStaticMenu = (items: MenuItem<any>[], acceptReporters: boolean) => ({\n  acceptReporters,\n  items: items\n    .map(item => item /**TODO figure out how to format */)\n    .map(convertMenuItemsToString)\n} satisfies ExtensionMenuMetadata);\n\nexport const addOptionsAndGetMenuName = (options: Menu<any>, menus: Menu<any>[],) => {\n  const alreadyAddedIndex = menus.indexOf(options);\n  const menuIndex = alreadyAddedIndex >= 0 ? alreadyAddedIndex : menus.push(options) - 1;\n  return `${getMenuName(menuIndex)}`;\n}\n\nexport const setMenu = (entry: ExtensionArgumentMetadata, options: Menu<any>, menus: Menu<any>[]) =>\n  options ? entry.menu = addOptionsAndGetMenuName(options, menus) : null;","import { BlockMetadata, BlockOperation } from \"$common/types\";\nimport { isFunction } from \"$common/utils\";\n\nexport const format = (text: string, identifier: string, description: string): string => {\n  return text; // make use of formatMessage in the future\n}\n\nexport type BlockGetter<This, Fn extends BlockOperation> = (this: This, self: This) => BlockMetadata<Fn>;\nexport type BlockDefinition<T, Fn extends BlockOperation> = BlockMetadata<Fn> | BlockGetter<T, Fn>;\n\nexport const isBlockGetter = <T, Fn extends BlockOperation>(details: BlockDefinition<any, Fn>): details is BlockGetter<T, Fn> => isFunction(details);\n\nexport const getButtonID = (id: string, opcode: string) => `${id}_${opcode}`;\n\nexport const extractArgNamesFromText = (text: string): string[] => {\n  const textAndNumbersInBrackets = /\\[([A-Za-z0-9]+)\\]/gm;\n  const argNames: string[] = [];\n  for (const [_, result] of text.matchAll(textAndNumbersInBrackets)) {\n    argNames.push(result);\n  }\n  return argNames;\n}","import { Argument, DynamicMenuThatAcceptsReporters, Menu, MenuThatAcceptsReporters, VerboseArgument } from \"$common/types\";\nimport { isPrimitive, identity } from \"$common/utils\";\n\nexport type Handler = (MenuThatAcceptsReporters<any>['handler']);\nconst isVerbose = (arg: Argument<any>): arg is VerboseArgument<any> => !isPrimitive(arg);\nconst handlerKey: keyof MenuThatAcceptsReporters<any> = 'handler';\nconst hasHandler = (options: Menu<any>): options is MenuThatAcceptsReporters<any> | DynamicMenuThatAcceptsReporters<any> => options && handlerKey in options;\n\nexport const extractHandlers = (args: readonly Argument<any>[]): Handler[] => args.map(element => {\n  if (!isVerbose(element)) return identity;\n  const { options } = element;\n  if (!hasHandler(options)) return identity;\n  return options.handler;\n});","import { Argument, ArgumentType, BlockMetadata, BlockOperation, ExtensionArgumentMetadata, Menu, MultipleArgsBlock, OneArgBlock, ValidKey, ValueOf, VerboseArgument } from \"$common/types\";\nimport { assertSameLength, isPrimitive, isString } from \"$common/utils\";\nimport { extractHandlers } from \"./handlers\";\nimport { setMenu } from \"./menus\";\nimport { format } from \"./util\";\n\nexport const getArgName = (index: number) => `${index}`;\n\nconst getArgumentType = <T>(arg: Argument<T>): ValueOf<typeof ArgumentType> =>\n  isPrimitive(arg) ? arg as ValueOf<typeof ArgumentType> : (arg as VerboseArgument<T>).type;\n\n/**\n * Extract an array of args tied to a block \n * @param block \n * @returns An array of 0, 1, or 2+ args\n */\nexport const extractArgs = (block: BlockMetadata<BlockOperation>) => {\n  const argKey: ValidKey<OneArgBlock> = \"arg\";\n  const argsKey: ValidKey<MultipleArgsBlock> = \"args\";\n  if (argKey in block && block[argKey]) return [(block as OneArgBlock).arg];\n  if (argsKey in block && (block[argsKey]?.length ?? 0) > 0) return (block as MultipleArgsBlock).args;\n  return [];\n}\n\n/**\n * Combine arguments' type, name, and handler information into a single structure\n * @param args \n * @param names \n * @returns \n */\nexport const zipArgs = (args: readonly Argument<any>[], names?: string[]) => {\n  const types = args.map(getArgumentType);\n  const handlers = extractHandlers(args);\n  names ??= types.map((_, index) => getArgName(index));\n  assertSameLength(types, handlers, names);\n  return types.map((type, index) => ({ type, name: names[index], handler: handlers[index] }));\n}\n\nexport const convertToArgumentInfo = (opcode: string, args: readonly Argument<any>[], menus: Menu<any>[]) => {\n  if (!args || args.length === 0) return undefined;\n\n  return Object.fromEntries(\n    args\n      .map((element, index) => {\n        const entry = {} as ExtensionArgumentMetadata;\n        entry.type = getArgumentType(element);\n\n        if (isPrimitive(element)) return entry;\n\n        const { defaultValue, options } = element as VerboseArgument<any>;\n\n        setDefaultValue(entry, opcode, index, defaultValue);\n        setMenu(entry, options, menus);\n\n        return entry;\n      })\n      .reduce(\n        (accumulation, entry, index) => accumulation.set(getArgName(index), entry),\n        new Map<string, ExtensionArgumentMetadata>\n      )\n  );\n}\n\nconst getArgTranslationID = (blockname: string, index: number) => `${blockname}-arg${index}-default`;\n\nconst getDefaultValue = (defaultValue: any, opcode: string, index: number) => isString(defaultValue)\n  ? format(defaultValue, getArgTranslationID(opcode, index), `Default value for arg ${index + 1} of ${opcode} block`)\n  : defaultValue;\n\nconst setDefaultValue = (entry: ExtensionArgumentMetadata, opcode: string, index: number, defaultValue: any,) => {\n  if (defaultValue === undefined) return;\n  entry.defaultValue = getDefaultValue(defaultValue, opcode, index)\n}","import { AnyBlock, OneArgBlock, MultipleArgsBlock, Argument } from \"$common/types\";\nimport { isString } from \"$common/utils\";\nimport { getArgName } from \"./args\";\nimport { format } from \"./util\";\n\nconst isDynamicText = (text: AnyBlock[\"text\"]): text is (OneArgBlock[\"text\"] | MultipleArgsBlock[\"text\"]) => !isString(text);\n\nexport const convertToDisplayText = (opcode: string, text: AnyBlock[\"text\"], args: readonly Argument<any>[]) => {\n  if (!args || args.length === 0) return text as string;\n\n  if (!isDynamicText(text)) return format(text, opcode, `Block text for '${opcode}'`);\n\n  const textFunc: (...args: any[]) => string = text;\n  const argPlaceholders = args.map((_, index) => `[${getArgName(index)}]`);\n  return format(textFunc(...argPlaceholders), opcode, `Block text for '${opcode}'`);\n}","import { castToType } from \"$common/cast\";\nimport CustomArgumentManager from \"$common/extension/mixins/optional/customArguments/CustomArgumentManager\";\nimport { ArgumentType, BlockType } from \"$common/types/enums\";\nimport { BlockOperation, ValueOf, Menu, ExtensionMetadata, ExtensionBlockMetadata, ExtensionMenuMetadata, DynamicMenu, BlockMetadata, } from \"$common/types\";\nimport { registerButtonCallback } from \"$common/ui\";\nimport { isString, typesafeCall, } from \"$common/utils\";\nimport type BlockUtility from \"$root/packages/scratch-vm/src/engine/block-utility\";\nimport { menuProbe, asStaticMenu, getMenuName, convertMenuItemsToString } from \"./menus\";\nimport { Handler } from \"./handlers\";\nimport { BlockDefinition, getButtonID, isBlockGetter } from \"./util\";\nimport { convertToArgumentInfo, extractArgs, zipArgs } from \"./args\";\nimport { convertToDisplayText } from \"./text\";\nimport { CustomizableExtensionConstructor, MinimalExtensionInstance, } from \"..\";\nimport { ExtensionIntanceWithFunctionality } from \"../..\";\n\nexport const getImplementationName = (opcode: string) => `internal_${opcode}`;\n\n/**\n * Wraps a blocks operation so that the arguments passed from Scratch are first extracted and then passed as indices in a parameter array.\n * @param _this What will be bound to the 'this' context of the underlying operation\n * @param operation The operation (function) to wrap\n * @param args The args that must be parsed before being passed to the underlying operation \n * @returns \n */\nexport const wrapOperation = <T extends MinimalExtensionInstance>(\n  _this: T,\n  operation: BlockOperation,\n  args: { name: string, type: ValueOf<typeof ArgumentType>, handler: Handler }[]\n) => _this.supports(\"customArguments\")\n    ? function (this: ExtensionIntanceWithFunctionality<[\"customArguments\"]>, argsFromScratch: Record<string, any>, blockUtility: BlockUtility) {\n      const castedArguments = args.map(({ name, type, handler }) => {\n        const param = argsFromScratch[name];\n        switch (type) {\n          case ArgumentType.Custom:\n            const isIdentifier = isString(param) && CustomArgumentManager.IsIdentifier(param);\n            const value = isIdentifier ? this.customArgumentManager.getEntry(param).value : param;\n            return handler.call(_this, value);\n          default:\n            return castToType(type, handler.call(_this, param));\n        }\n      });\n      return operation.call(_this, ...castedArguments, blockUtility);\n    }\n    : function (this: T, argsFromScratch: Record<string, any>, blockUtility: BlockUtility) {\n      const castedArguments = args.map(({ name, type, handler }) =>\n        castToType(type, handler.call(_this, argsFromScratch[name]))\n      );\n      return operation.call(_this, ...castedArguments, blockUtility);\n    }\n\n/**\n * Mixin the ability for extension's to:\n * - build up block definitions incrementally (through the use of `pushBlock`)\n * - implement a valid `getInfo` method that interacts with the scratch-vm correctly  \n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport default function (Ctor: CustomizableExtensionConstructor) {\n  type BlockEntry = { definition: BlockDefinition<ScratchExtension, BlockOperation>, operation: BlockOperation };\n  type BlockMap = Map<string, BlockEntry>;\n  abstract class ScratchExtension extends Ctor {\n    private readonly blockMap: BlockMap = new Map();\n\n    private readonly menus: Menu<any>[] = [];\n    private info: ExtensionMetadata;\n\n    /**\n     * Add a block \n     * @param opcode \n     * @param definition \n     * @param operation \n     */\n    pushBlock<Fn extends BlockOperation>(opcode: string, definition: BlockDefinition<any, Fn>, operation: BlockOperation) {\n      if (this.blockMap.has(opcode)) throw new Error(`Attempt to push block with opcode ${opcode}, but it was already set. This is assumed to be a mistake.`)\n      this.blockMap.set(opcode, { definition, operation });\n    }\n\n    protected getInfo(): ExtensionMetadata {\n      if (!this.info) {\n        const { id, name, blockIconURI } = this;\n        const blocks = Array.from(this.blockMap.entries()).map(entry => this.convertToInfo(entry));\n        this.info = { id, blocks, name, blockIconURI, menus: this.collectMenus() };\n      }\n      return this.info;\n    }\n\n    private convertToInfo(details: [opcode: string, entry: BlockEntry]) {\n      const [opcode, entry] = details;\n      const { definition, operation } = entry;\n\n      // Utilize explicit casting to appease test framework's typechecker\n      const block = isBlockGetter(definition)\n        ? typesafeCall(definition, this, this) as BlockMetadata<BlockOperation>\n        : definition as BlockMetadata<BlockOperation>;\n\n      const { type, text } = block;\n\n      const args = extractArgs(block);\n\n      const { id, runtime, menus } = this;\n\n      const displayText = convertToDisplayText(opcode, text, args);\n      const argumentsInfo = convertToArgumentInfo(opcode, args, menus);\n\n      const info: ExtensionBlockMetadata = { opcode, text: displayText, blockType: type, arguments: argumentsInfo };\n\n      if (type === BlockType.Button) {\n        const buttonID = getButtonID(id, opcode);\n        registerButtonCallback(runtime, buttonID, operation.bind(this));\n        info.func = buttonID;\n      } else {\n        const implementationName = getImplementationName(opcode);\n        this[implementationName] = wrapOperation(this as MinimalExtensionInstance, operation, zipArgs(args));\n      }\n\n      return info;\n    }\n\n    private collectMenus() {\n      const { isSimpleStatic, isSimpleDynamic, isStaticWithReporters, isDynamicWithReporters } = menuProbe;\n      return Object.fromEntries(\n        this.menus\n          .map((menu, index) => {\n            if (isSimpleStatic(menu)) return asStaticMenu(menu, false);\n            if (isSimpleDynamic(menu)) return this.registerDynamicMenu(menu, false, index);\n            if (isStaticWithReporters(menu)) return asStaticMenu(menu.items, true);\n            if (isDynamicWithReporters(menu)) return this.registerDynamicMenu(menu.getItems, true, index);\n            throw new Error(\"Unable to process menu\");\n          })\n          .reduce((map, menu, index) => map.set(getMenuName(index), menu), new Map<string, ExtensionMenuMetadata>())\n      );\n    }\n\n    private registerDynamicMenu(getItems: DynamicMenu<any>, acceptReporters: boolean, menuIndex: number) {\n      const key = `internal_dynamic_${menuIndex}`; // legacy support?\n      this[key] = () => getItems.call(this).map(item => item).map(convertMenuItemsToString);\n      return { acceptReporters, items: key } satisfies ExtensionMenuMetadata\n    }\n  }\n\n  return ScratchExtension;\n}","import type BlockUtility from \"$scratch-vm/engine/block-utility\";\nimport { TypedMethodDecorator } from \".\";\nimport { BlockType } from \"$common/types/enums\";\nimport { BlockMetadata } from \"$common/types\";\nimport { getImplementationName } from \"../mixins/required/scratchInfo/index\";\nimport { ExtensionInstance } from \"..\";\n\n/**\n * This a decorator function that should be associated with methods of your Extension class, all in order to turn your class methods\n * into Blocks that can be executed in the Block Programming Environment.\n * @param {BlockMetadata} blockInfoOrGetter Either an object or a function that returns an object of the following specified shapes \n * (which shape is required depends on your method's argument(s)):\n * @example \n * Block method accepts no arguments\n * ```ts\n * {\n *  type: BlockType, // e.g. \"reporter\", \"command\"\n *  text: string // the display text of your block\n * }\n * ```\n * @example \n * Block method accepts one argument\n * ```ts\n * {\n *  type: BlockType, // e.g. \"reporter\", \"command\"\n *  text: (arg) => string, // a function that returns a string, hover over the 'text' field in your code for more thourough documentation\n *  arg: Argument, // hover over the 'arg' field in your code for more thourough documentation\n * }\n * ```\n* @example \n * Block method accepts 2 or more arguments\n * ```ts\n * {\n *  type: BlockType, // e.g. \"reporter\", \"command\"\n *  text: (...args) => string, // a function that returns a string, hover over the 'text' field in your code for more thourough documentation\n *  args: Argument[], // hover over the 'args' field in your code for more thourough documentation\n * }\n * ```\n * @returns A manipulated version of the original method that is\n */\nexport function block<\n  const This extends ExtensionInstance,\n  const Args extends any[],\n  const Return,\n  const Fn extends (...args: Args) => Return,\n  const TRemoveUtil extends any[] = Args extends [...infer R extends any[], BlockUtility] ? R : Args,\n>\n  (\n    blockInfoOrGetter: (BlockMetadata<(...args: TRemoveUtil) => Return> | ((this: This, self: This) => BlockMetadata<(...args: TRemoveUtil) => Return>))\n  ): TypedMethodDecorator<This, Args, Return, (...args: Args) => Return> {\n\n  return function (this: This, target: (this: This, ...args: Args) => Return, context: ClassMethodDecoratorContext<This, Fn>) {\n    const opcode = target.name;\n    const internalFuncName = getImplementationName(opcode);\n    context.addInitializer(function () { this.pushBlock(opcode, blockInfoOrGetter, target) });\n    return (function () { return this[internalFuncName].call(this, ...arguments) }) as Function as Fn;\n  };\n}\n\n\ntype BlockFromArgsAndReturn<Args extends any[], Return> = Args extends [...infer R extends any[], BlockUtility]\n  ? BlockMetadata<(...args: R) => Return> : BlockMetadata<(...args: Args) => Return>;\n\n/**\n * This is a short-hand for invoking the block command when your `blockType` is button\n * @param text \n * @returns \n * @see {@link block} \n * @example\n * // Ignore the leading \"_\"\n * _@buttonBlock(\"The text of button block\")\n * buttonMethod() {\n *    this.openUI(\"someUI\")\n * }\n * \n */\nexport function buttonBlock<\n  This extends ExtensionInstance,\n>(text: string): TypedMethodDecorator<This, [], void, () => void> {\n  type Args = [] | [BlockUtility];\n  type Return = void;\n  type Fn = (...args: Args) => Return;\n\n  return block<This, Args, Return, Fn>({\n    text,\n    type: BlockType.Button\n  });\n}","import { legacySupportWithInfoArgument } from \"$common/extension/mixins/optional/legacySupport\";\nimport { ExtensionMetadata, ExtensionBlockMetadata, ExtensionMenuItems, BlockOperation, Argument, ExtensionMenuMetadata, ExtensionDynamicMenu, Menu, DynamicMenuThatAcceptsReporters, BaseGenericExtension, VerboseArgument, DefineBlock, AbstractConstructor, NonAbstractConstructor, BlockMetadata } from \"$common/types\";\nimport { isFunction, isString } from \"$common/utils\";\nimport { block } from \"../blocks\";\nimport { ArgumentMethods, BlockDecorators, BlockDefinitions, BlockEntry, BlockMap, LegacyExtension, LegacyExtensionDecorator, LegacySupport, ObjectOrGetter } from \"./types\";\nimport { ExtensionInstance } from \"$common/extension\";\n\n/**\n * \n * @param info \n * @param flags \n * @returns \n */\nexport const legacy = <\n  const TInfo extends ExtensionMetadata,\n  TFlags extends { incrementalDevelopment: boolean } = undefined,\n  const TStrict extends boolean = TFlags extends { incrementalDevelopment: false } | undefined ? true : false\n>(info: TInfo, flags?: TFlags): LegacySupport<TInfo, TStrict> => ({\n\n  for<TExtension extends LegacyExtension<TInfo, TStrict>>() {\n\n    const legacyExtension = (): LegacyExtensionDecorator<TExtension> => (value, context) => {\n      abstract class LegacySupport extends legacySupportWithInfoArgument(value as AbstractConstructor<ExtensionInstance>, info) {\n        readonly originalClassName = context.name;\n      };\n\n      return LegacySupport as AbstractConstructor<ExtensionInstance> as NonAbstractConstructor<TExtension>;\n    };\n\n    const blockMethodBroker = getBlockMetaData(info).map(([opcode, entry]) => {\n      const key = opcode as keyof BlockDefinitions<TInfo, TExtension>;\n      return {\n        key,\n        definer: createBlockDefiner<TExtension & BaseGenericExtension>(entry),\n        decorator: createBlockDecorator<TExtension & ExtensionInstance>(entry)\n      }\n    });\n\n    const legacyDefinition = blockMethodBroker.reduce((definitions, { key, definer }) => {\n      definitions[key] = definer as any; // TODO: See if we can get this type to work\n      return definitions;\n    }, {} as BlockDefinitions<TInfo, TExtension>);\n\n\n    const legacyBlock = blockMethodBroker.reduce((decorators, { key, decorator }) => {\n      decorators[key] = decorator as any; // TODO: See if we can get this type to work\n      return decorators;\n    }, {} as BlockDecorators<TInfo>);\n\n    const throwTypeOnlyError = () => {\n      throw new Error(\"This property is not meant to be accessed, and is instead solely for type inference / documentation purposes.\")\n    };\n\n    return {\n      legacyExtension, legacyDefinition, legacyBlock,\n      ReservedNames: {\n        get Menus(): any { return throwTypeOnlyError() },\n        get Blocks(): any { return throwTypeOnlyError() },\n        get ArgumentNamesByBlock(): any { return throwTypeOnlyError() },\n      },\n    };\n  }\n})\n\n/**\n * Creates a function that returns a function that acts as a block definition for the 'entry' block metadata.\n * @param entry \n * @returns \n */\nconst createBlockDefiner = <TExtension extends ExtensionInstance & BaseGenericExtension>(entry: BlockEntry) =>\n  (objOrGetter: ObjectOrGetter<{ opertation: BlockOperation } & Partial<ArgumentMethods<any, any>>, TExtension>) =>\n    ((extension: TExtension) => {\n      const { operation, argumentMethods } = isFunction(objOrGetter) ? objOrGetter.call(extension, extension) : objOrGetter;\n      if (argumentMethods) attachArgumentMethods(entry, argumentMethods, extension);\n      return { ...entry, operation }\n    }) as DefineBlock<TExtension, BlockOperation>;\n\n/**\n * Creates a function that returns a decorator function that wraps the data contained within 'entry'.\n * @param entry \n * @returns \n */\nconst createBlockDecorator = <TExtension extends ExtensionInstance>(entry: BlockEntry) =>\n  (...params: ([ObjectOrGetter<ArgumentMethods<any, any>, TExtension>] | [])) => {\n    if (params.length === 0 || !params[0]) return block<TExtension, any[], any, any>(entry as BlockMetadata<any>);\n    const objOrGetter = params[0];\n    return block<TExtension, any[], any, any>((extension: TExtension) => {\n      const { argumentMethods } = isFunction(objOrGetter)\n        ? objOrGetter.call(extension, extension) : objOrGetter;\n\n      attachArgumentMethods(entry, argumentMethods, extension);\n      return entry as BlockMetadata<any>;\n    });\n  }\n\nconst attachArgumentMethods = (\n  block: ReturnType<BlockMap[\"get\"]>,\n  argumentMethods: Record<number, Partial<DynamicMenuThatAcceptsReporters<unknown>>>,\n  extension: ExtensionInstance\n) => {\n  const args = block.args ? block.args : block.arg ? [block.arg] : [];\n\n  Object.entries(argumentMethods)\n    .map(([indexKey, { handler, getItems }]) => {\n      const arg = args[parseInt(indexKey)] as VerboseArgument<any>;\n      return { arg, methods: { handler, getItems } }\n    })\n    .forEach(({ arg, methods }) =>\n      Object.entries(methods)\n        .filter(([_, method]) => method)\n        .map(([key, method]) => [key, method.bind(extension)])\n        .forEach(([key, method]) => tryUpdateKey(arg.options, key, method)));\n}\n\nconst tryUpdateKey = <T>(obj, key: string, value: T) => {\n  obj[key] = value;\n}\n\nconst asBlockMetaData = (block: ExtensionBlockMetadata | string) => {\n  if (isString(block)) throw new Error(`Block defined as string, unexpected! ${block}`)\n  return block as ExtensionBlockMetadata;\n}\n\nconst convertAndInsertBlock = (map: BlockMap, block: ExtensionBlockMetadata, metadata: ExtensionMetadata) => {\n  const { opcode, arguments: _arguments, blockType: type } = block;\n  const { text, orderedNames } = parseText(block);\n\n  if (!_arguments) return map.set(opcode, { type, text });\n\n  const args = Object.entries(_arguments ?? {})\n    .map(([name, { menu, ...rest }]) => ({ options: extractMenuOptions(metadata, menu), name, menu, ...rest }))\n    .sort(({ name: a }, { name: b }) => orderedNames.indexOf(a) < orderedNames.indexOf(b) ? -1 : 1)\n    .map(({ name, ...details }) => details satisfies Argument<any> as Argument<unknown>);\n\n  const { length } = args;\n  return length >= 2\n    ? map.set(opcode, { type, text, args: args as [] })\n    : map.set(opcode, { type, text, arg: args[0] })\n}\n\nconst getBlockMetaData = (metadata: ExtensionMetadata) => Array.from(\n  metadata.blocks\n    .map(asBlockMetaData)\n    .reduce((map, block) => convertAndInsertBlock(map, block, metadata), new Map() as BlockMap)\n    .entries()\n);\n\nexport const parseText = ({ arguments: _arguments, text }: ExtensionBlockMetadata) => {\n  const placeholder = \"Error: This should have been overridden by legacy support\";\n\n  if (!_arguments) return { orderedNames: null as null, text: placeholder };\n\n  const args = Object.keys(_arguments)\n    .map(name => ({ name, template: `[${name}]` }))\n    .sort(({ template: a }, { template: b }) => text.indexOf(a) < text.indexOf(b) ? -1 : 1);\n\n  return args.length === 0\n    ? { orderedNames: null as null, text: placeholder }\n    : { orderedNames: args.map(({ name }) => name), text: () => placeholder }\n}\n\nconst getItemsPlaceholder = { getItems: () => (\"Error: This should have been filled in.\" as any) };\nconst handlerPlaceholder = { handler: () => (\"Error: This should have been filled in.\" as any) };\n\nexport const isDynamicMenu = (menu: ExtensionMenuMetadata | ExtensionMenuItems[\"items\"]): menu is ExtensionDynamicMenu => isString(menu);\n\nconst extractMenuOptions = (data: ExtensionMetadata, menuName: string): Menu<any> => {\n  const menu = menuName ? data.menus[menuName] : undefined;\n\n  if (!menu) return undefined;\n  if (isDynamicMenu(menu)) return getItemsPlaceholder.getItems;\n\n  const { items, acceptReporters: acceptsReporters } = menu;\n\n  if (!isDynamicMenu(items)) return acceptsReporters ? { acceptsReporters, items: [...items], ...handlerPlaceholder } : [...items];\n\n  return acceptsReporters ? { acceptsReporters, ...handlerPlaceholder, ...getItemsPlaceholder } : getItemsPlaceholder.getItems;\n}","import { ExtensionInstance } from \"$common/extension\";\nimport { AbstractConstructor, ExtensionArgumentMetadata, ExtensionBlockMetadata, ExtensionMenuMetadata, ExtensionMetadata } from \"$common/types\";\nimport { isString, set } from \"$common/utils\";\nimport { isDynamicMenu, parseText } from \"../../decorators/legacySupport/index\";\nimport { MinimalExtensionConstructor } from \"../required\";\nimport { getImplementationName, wrapOperation } from \"../required/scratchInfo/index\";\n\ntype WrappedOperation = ReturnType<typeof wrapOperation>;\ntype WrappedOperationParams = Parameters<WrappedOperation>;\ntype WithLegacySupport = InstanceType<ReturnType<typeof legacySupportMixin>>;\ntype BlockMap = Map<string, Omit<ExtensionBlockMetadata, \"opcode\"> & { index: number }>;\n\nexport const isLegacy = (extension: ExtensionInstance | WithLegacySupport): extension is WithLegacySupport => {\n  const key: keyof WithLegacySupport = \"__isLegacy\";\n  return key in extension;\n}\n\nconst validBlock = (legacyBlock: string | ExtensionBlockMetadata, blockMap: BlockMap): legacyBlock is ExtensionBlockMetadata => {\n  if (isString(legacyBlock)) throw new Error(\"Block was unexpectedly a string: \" + legacyBlock);\n  if (!blockMap.has(legacyBlock.opcode)) {\n    console.error(`Could not find legacy opcode ${legacyBlock.opcode} within currently defined blocks`);\n    return false;\n  };\n  return true;\n}\n\nconst validArg = (pair: { legacy: ExtensionArgumentMetadata, modern: ExtensionArgumentMetadata }): typeof pair => {\n  if (typeof pair.legacy.menu !== typeof pair.modern.menu) throw new Error(\"Menus don't match\")\n  return pair;\n}\n\nconst getDynamicMenuName = (menu: ExtensionMenuMetadata): string => {\n  if (isDynamicMenu(menu)) return menu;\n  if (isDynamicMenu(menu.items)) return menu.items;\n  throw new Error(\"Menu is not dynamic: \" + menu);\n}\n\n/**\n * Mixin the ability for extensions to make use of 'legacy' `getInfo` json, \n * so that extensions ported to the framework can support old, serialized projects\n * @param Ctor \n * @param legacyInfo \n * @returns \n */\nexport default function legacySupportMixin<T extends MinimalExtensionConstructor>(Ctor: T) {\n  abstract class ExtensionWithLegacySupport extends Ctor {\n    private validatedInfo: ExtensionMetadata;\n\n    protected abstract getLegacyInfo(): ExtensionMetadata;\n\n    public __isLegacy = true;\n    public orderArgumentNamesByBlock: Map<string, string[]> = new Map();\n\n    protected getInfo(): ExtensionMetadata {\n      if (!this.validatedInfo) {\n        const info = super.getInfo();\n        this.validatedInfo = this.validateAndAttach(info);\n      }\n\n      return this.validatedInfo;\n    }\n\n    private getArgNames = (legacyBlock: ExtensionBlockMetadata) => {\n      const { opcode } = legacyBlock;\n\n      if (!this.orderArgumentNamesByBlock.has(opcode)) {\n        const { orderedNames } = parseText(legacyBlock);\n        this.orderArgumentNamesByBlock.set(opcode, orderedNames);\n      }\n\n      return this.orderArgumentNamesByBlock.get(opcode);\n    }\n\n    private validateAndAttach({ id, blocks, menus, ...metaData }: ExtensionMetadata): ExtensionMetadata {\n      const { id: legacyID, blocks: legacyBlocks, menus: legacyMenus } = this.getLegacyInfo();\n      const mutableBlocks = [...blocks as ExtensionBlockMetadata[]];\n\n      if (id !== legacyID) throw new Error(`ID mismatch! Legacy id: ${legacyID} vs. current id: ${id}`);\n\n      const blockMap = mutableBlocks.reduce(\n        (map, { opcode, ...block }, index) => map.set(opcode, { ...block, index }),\n        new Map() as BlockMap\n      );\n\n      const self = this;\n\n      const updates = legacyBlocks\n        .map(legacyBlock => validBlock(legacyBlock, blockMap) ? legacyBlock : undefined)\n        .filter(Boolean)\n        .map(legacyBlock => {\n          const { opcode, arguments: legacyArgs } = legacyBlock;\n          const { index, arguments: modernArgs } = blockMap.get(opcode);\n          const argNames = this.getArgNames(legacyBlock);\n\n          if (!argNames) return { replaceAt: { index, block: legacyBlock } };\n\n          const remapper = (args: Record<string, any>) => argNames.reduce(\n            (remap, current, index) => set(remap, index, args[current]),\n            {} as Record<number, any>);\n\n          const implementation: WrappedOperation = this[getImplementationName(opcode)];\n\n          this[opcode] = (\n            (...[args, util]: WrappedOperationParams) => implementation.call(self, remapper(args), util)\n          ).bind(self);\n\n          const menuUpdates = argNames\n            .map((legacyName, index) => ({ legacy: legacyArgs[legacyName], modern: modernArgs[index] }))\n            .map(validArg)\n            .map(({ legacy: { menu: legacyName }, modern: { menu: modernName } }) => ({ legacyName, modernName }))\n            .filter(menus => menus.legacyName && menus.modernName)\n            .map(({ legacyName, modernName }) =>\n              ({ legacyName, modernName, legacy: legacyMenus[legacyName], modern: menus[modernName] }))\n            .map(({ legacy, modern, legacyName, modernName }) => !isDynamicMenu(legacy) && !isDynamicMenu(legacy.items)\n              ? { type: \"static\" as const, legacy: legacyName, modern: modernName }\n              : { type: \"dynamic\" as const, legacy: legacyName, modern: modernName, methods: { legacy: getDynamicMenuName(legacy), modern: getDynamicMenuName(modern) } }\n            );\n\n          return { menuUpdates, replaceAt: { index, block: legacyBlock } };\n        });\n\n      updates.forEach(({ replaceAt: { index, block } }) => mutableBlocks[index] = block);\n\n      updates\n        .map(({ menuUpdates }) => menuUpdates)\n        .flat()\n        .filter(Boolean)\n        .map(menu => {\n          const { legacy } = menu;\n          if (legacy in menus) throw new Error(`Somehow, there was already a menu called ${legacy}, which will cause issues in the next step.`);\n          return menu;\n        })\n        .forEach(({ type, legacy, methods }) => {\n          menus[legacy] = legacyMenus[legacy];\n          if (type === \"dynamic\") self[methods.legacy] = () => self[methods.modern]();\n        });\n\n      return {\n        id, blocks: mutableBlocks, menus, ...metaData\n      };\n    }\n  }\n  return ExtensionWithLegacySupport\n}\n\n/**\n * Mixin the ability for extensions to make use of 'legacy' `getInfo` json, \n * so that extensions ported to the framework can support old, serialized projects\n * @param Ctor \n * @param legacyInfo \n * @returns \n */\nexport function legacySupportWithInfoArgument<T extends AbstractConstructor<ExtensionInstance>>(Ctor: T, legacyInfo: ExtensionMetadata) {\n  abstract class ExtensionWithLegacySupport extends legacySupportMixin(Ctor) {\n    protected getLegacyInfo() {\n      return legacyInfo;\n    }\n  }\n\n  return ExtensionWithLegacySupport\n}","import type Video from \"$scratch-vm/io/video\";\nimport { MinimalExtensionConstructor } from \"../required\";\n\nconst Format = {\n  image: \"image-data\",\n  canvas: \"canvas\"\n} as const satisfies {\n  image: (typeof Video)[\"FORMAT_IMAGE_DATA\"],\n  canvas: (typeof Video)[\"FORMAT_CANVAS\"];\n}\n\ntype VideoFrameTypeByFormat = {\n  \"image-data\": ImageData,\n  \"canvas\": HTMLCanvasElement\n}\n\n/**\n * Mixin the ability for extensions to interact with the user's web cam video feed\n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport default function <T extends MinimalExtensionConstructor>(Ctor: T) {\n  abstract class ExtensionWithVideoSupport extends Ctor {\n    private videoDevice: Video | null;\n\n    private get video(): Video | null {\n      this.videoDevice ??= this.runtime.ioDevices?.video;\n      return this.videoDevice;\n    };\n\n    /**\n     * Access the most recent frame captured by the web cam\n     * @param {\"image\" | \"canvas\"} format \n     * @returns \n     */\n    getVideoFrame<TFormat extends keyof typeof Format>(format: TFormat) {\n      return this.video?.getFrame({\n        format: Format[format]\n      }) as VideoFrameTypeByFormat[typeof Format[typeof format]]\n    }\n\n    setVideoTransparency(transparency: number) {\n      this.video?.setPreviewGhost(transparency);\n    }\n\n    /**\n     * Turn the video feed on so that it's frames can be accessed and the feed\n     * diplays within the game window.\n     */\n    enableVideo() {\n      this.video?.enableVideo();\n    }\n\n    /**\n     * Disable the video feed\n     */\n    disableVideo() {\n      this.video?.disableVideo();\n    }\n  }\n\n  return ExtensionWithVideoSupport;\n}\n","import { AbstractConstructor, ValueOf } from \"$common/types\";\nimport addCostumes from \"./optional/addCostumes/index\";\nimport customArguments from \"./optional/customArguments/index\";\nimport customSaveData from \"./optional/customSaveData\";\nimport drawable from \"./optional/drawable\";\nimport legacySupport from \"./optional/legacySupport\";\nimport ui from \"./optional/ui\";\nimport video from \"./optional/video\";\n\nimport { MinimalExtensionConstructor } from \"./required\";\n\nexport const optionalMixins = {\n  customArguments,\n  ui,\n  customSaveData,\n  video,\n  drawable,\n  addCostumes,\n  legacySupport\n} as const satisfies OptionalMixins;\n\nexport type OptionalMixins<T extends MinimalExtensionConstructor = MinimalExtensionConstructor> = {\n  ui: typeof ui<T>;\n  customArguments: typeof customArguments<T>,\n  customSaveData: typeof customSaveData<T>,\n  video: typeof video<T>,\n  drawable: typeof drawable<T>,\n  addCostumes: typeof addCostumes<T>,\n  legacySupport: typeof legacySupport<T>\n}\n\nexport type MixinName = keyof typeof optionalMixins;\n\nexport type ExtensionWithFunctionality<TSupported extends MixinName[], TBase extends MinimalExtensionConstructor = MinimalExtensionConstructor> = TSupported extends [infer Head, ...infer Tail]\n  /** Use `extends` to enable typescript to infer desired characteristics */\n  ? Head extends keyof OptionalMixins ? Tail extends (keyof OptionalMixins)[] ? TBase extends MinimalExtensionConstructor\n  /** Accumalate the TBase parameter */\n  ? ExtensionWithFunctionality<Tail, ReturnType<OptionalMixins<TBase>[Head]>>\n  /** Return never as Head, Tail, and TBase should never not meet the above type requirements */\n  : never : never : never\n  /** Base case */\n  : TBase;\n\nexport type ExtensionIntanceWithFunctionality<TSupported extends MixinName[]> = InstanceType<ExtensionWithFunctionality<TSupported>>;","import { openUI } from \"$common/ui\";\nimport { MinimalExtensionConstructor } from \"../required\";\n\n/**\n * Mixin the ability for extensions to open up UI at-will\n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport default function <T extends MinimalExtensionConstructor>(Ctor: T) {\n  abstract class ExtensionWithUISupport extends Ctor {\n\n    /**\n     * Open a UI in a modal window \n     * @param component The name of the svelte component / file to open (which should be stored within the same folder as your extension's `index.ts` file). \n     * You can optionally leave off the `.svelte` extension.\n     * @param label What to title the modal window that pops up (defaults to your extension's name if left blank)\n     */\n    openUI(component: string, label?: string) {\n      const { id, name, runtime } = this;\n      openUI(runtime, { id, name, component: component.replace(\".svelte\", \"\"), label });\n    }\n\n  }\n\n  return ExtensionWithUISupport;\n}\n","import { StageLayering, ValueOf } from \"$common/types\";\nimport { MinimalExtensionConstructor } from \"../required\";\n\ntype Handle = number;\n\ntype Renderer = {\n  /**\n   * Create a new bitmap skin from a snapshot of the provided bitmap data.\n   * @param {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} bitmapData - new contents for this skin.\n   * @param {!int} [costumeResolution=1] - The resolution to use for this bitmap.\n   * @param {?Array<number>} [rotationCenter] Optional: rotation center of the skin. If not supplied, the center of\n   * the skin will be used.\n   * @returns {!int} the ID for the new skin.\n   */\n  createBitmapSkin(bitmapData: ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement, costumeResolution?: number, rotationCenter?: Array<number> | null): Handle;\n  /**\n   * Create a new Drawable and add it to the scene.\n   * @param {string} group Layer group to add the drawable to\n   * @returns {int} The ID of the new Drawable.\n   */\n  createDrawable(group: string): Handle;\n  /**\n     * Update a drawable's visibility.\n     * @param {number} drawableID The drawable's id.\n     * @param {boolean} visible Will the drawable be visible?\n     */\n  updateDrawableVisible(drawableID: number, visible: boolean): void;\n  /**\n   * Update a drawable's visual effect.\n   * @param {number} drawableID The drawable's id.\n   * @param {string} effectName The effect to change.\n   * @param {number} value A new effect value.\n   */\n  updateDrawableEffect(drawableID: number, effectName: string, value: number): void;\n  /**\n   * Update a drawable's skin.\n   * @param {number} drawableID The drawable's id.\n   * @param {number} skinId The skin to update to.\n   */\n  updateDrawableSkinId(drawableID: Handle, skinId: Handle): void;\n  /**\n   * Update an existing bitmap skin, or create a bitmap skin if the previous skin was not bitmap.\n   * @param {!int} skinId the ID for the skin to change.\n   * @param {!ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imgData - new contents for this skin.\n   * @param {!number} bitmapResolution - the resolution scale for a bitmap costume.\n   * @param {?Array<number>} rotationCenter Optional: rotation center of the skin. If not supplied, the center of the\n   * skin will be used\n   */\n  updateBitmapSkin(skinId: Handle, imgData: ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement, bitmapResolution: number, rotationCenter?: Array<number> | null): void;\n  /**\n   * Destroy an existing skin. Do not use the skin or its ID after calling this.\n   * @param {!int} skinId - The ID of the skin to destroy.\n   */\n  destroySkin(skinId: number): void;\n  /**\n   * Destroy a Drawable, removing it from the scene.\n   * @param {int} drawableID The ID of the Drawable to remove.\n   * @param {string} group Group name that the drawable belongs to\n   */\n  destroyDrawable(drawableID: Handle, group: string): void;\n}\n\n/**\n * Mixin the ability for extensions to draw images into the canvas\n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport default function <T extends MinimalExtensionConstructor>(Ctor: T) {\n  abstract class ExtensionWithDrawingSupport extends Ctor {\n    private renderer: Renderer;\n\n    /**\n     * Draw an item on screen using image data\n     * @param {ImageData | ImageBitmap} image \n     * @returns \n     */\n    protected createDrawable<T extends ImageData | ImageBitmap>(image: T) {\n      this.renderer ??= this.runtime.renderer;\n      const { renderer } = this;\n\n      if (!renderer) return null;\n\n      const skin = renderer.createBitmapSkin(image as ImageData, 1);\n      const drawable = renderer.createDrawable(StageLayering.VideoLayer);\n\n      renderer.updateDrawableSkinId(drawable, skin);\n\n      const setTransparency = (transparency: number) =>\n        renderer.updateDrawableEffect(drawable, 'ghost', transparency);\n\n      const setVisible = (visible: boolean = true) =>\n        renderer.updateDrawableVisible(drawable, visible);\n\n      const update = (image: ImageData | ImageBitmap) =>\n        renderer.updateBitmapSkin(skin, image as ImageData, 1);\n\n      const destroy = () => {\n        setVisible(false);\n        renderer.destroyDrawable(drawable, StageLayering.VideoLayer);\n        renderer.destroySkin(skin);\n      }\n\n      setTransparency(0);\n      setVisible(true);\n\n      return { setTransparency, setVisible, update, destroy }\n    }\n  }\n\n  return ExtensionWithDrawingSupport;\n}\n","import Runtime from \"$scratch-vm/engine/runtime\";\n\nimport { AbstractConstructor, Environment, ExlcudeFirst } from \"$common/types\";\n\nexport type ExtensionConstructorParams = ConstructorParameters<typeof ConstructableExtension>;\nexport type CodeGenParams = ExlcudeFirst<ExtensionConstructorParams>;\nexport type ExtensionBaseConstructor = AbstractConstructor<ExtensionBase>;\n\nexport abstract class ConstructableExtension {\n  /**\n   * @summary This member function (or 'method') will be called when a user adds your extension via the Extensions Menu (i.e. when your extension is instantiated)\n   * @example\n   * // Initialize class field(s)\n   * private count: number;\n   *\n   * init() {\n   *  count = 0;\n   * }\n   * @example\n   * // Interact with environment's runtime\n   * init(env: Environment) {\n   *  env.runtime.emit(RuntimeEvent.ProjectStart);\n   * }\n   * @example\n   * // Nothing to initialize\n   * init() {}\n   * @description This function is intended to behave exactly like a constructor, used to initialize the state of your extension.\n   *\n   * The reason we use this function INSTEAD of a constructor is so that the base Extension class can manage the construction of this class.\n   * @param {Environment} env An object that allows your Extension to interact with the Scratch Environment. Currently is a little bare, but will be expanded soon.\n   * Can be ommitted if not needed.\n   *\n   * For Scratch developers: The `runtime` property on env is the same as the runtime passed to non-Typescript-Framework Extension constructors\n   */\n  abstract init(env: Environment): void;\n\n  protected async internal_init() {\n    const runtime = this.runtime;\n    await this.init({\n      runtime,\n      get extensionManager() { return runtime.getExtensionManager() }\n    });\n  }\n\n  /**\n   *\n   * @param runtime The 'runtime' connected to the scratch-vm that enables your extension to interact with the scratch workspace\n   * @param name The name of this extension.\n   * @param id The ID of this extension.\n   * @param blockIconURI\n   */\n  constructor(readonly runtime: Runtime, readonly name: string, readonly id: string, readonly blockIconURI: string) {\n  }\n}\n\nexport const extensionsMap = new Map<string, ExtensionBase>();\n\nexport abstract class ExtensionBase extends ConstructableExtension {\n  constructor(FORBIDDEN: never) {\n    // @ts-ignore\n    super(...arguments);\n    extensionsMap.set(this.id, this);\n  }\n}","import { AbstractConstructor } from \"$common/types\";\nimport { MixinName, optionalMixins } from \".\";\n\nexport interface WithDependencies<TDepends extends MixinName[]> {\n  /**\n   * Get the dependencies of this mixin's classes functionality. \n   * You may need to cast your returned array as const (e.g. `[] as const`) in order to satisfy type requirements.\n   * \n   * **NOTE:** The term _Static_ is used here to indicate that this function will be executed on the mixin\n   * class's `prototype` and therefore the implementation should make no reference to `this`.\n   */\n  getStaticDependencies(): readonly [...TDepends];\n}\n\ntype MixinsWithDependencies = {\n  [\n  k in keyof typeof optionalMixins as\n  ReturnType<typeof optionalMixins[k]> extends AbstractConstructor<WithDependencies<MixinName[]>>\n  ? k\n  : never\n  ]:\n  ReturnType<typeof optionalMixins[k]> extends AbstractConstructor<WithDependencies<infer X>>\n  ? X : never\n}\n\nconst optionalMixinDependencies: MixinsWithDependencies = {\n  customArguments: [\"customSaveData\"],\n}\n\nexport const getDependencies = (...mixinNames: MixinName[]) => mixinNames\n  .filter(key => key in optionalMixinDependencies)\n  .map(key => optionalMixinDependencies[key as keyof typeof optionalMixinDependencies])\n  .flat();\n","import { ExtensionWithFunctionality, MixinName, optionalMixins } from \"./mixins/index\";\nimport { ExtensionBase } from \"./ExtensionBase\";\nimport scratchInfo from \"./mixins/required/scratchInfo\";\nimport supported from \"./mixins/required/supported\";\nimport { ExtensionMenuDisplayDetails, Writeable } from \"$common/types\";\nimport { getDependencies } from \"./mixins/dependencies\";\n\nconst registerDetailsIdentifier = \"__registerMenuDetials\";\n\nconst tryAnnounceDetails = (details: ExtensionMenuDisplayDetails) => {\n  const isNode = typeof window === 'undefined';\n  if (isNode) global?.[registerDetailsIdentifier]?.(details);\n}\n\n/**\n * Creates the base class that your Extension should 'extend' which is compatible with your request. \n * \n * Your request will have the following two parts:\n * @param details The details about how your extension should display and behave within the Extensions Menu.\n * Only the `name` field is required, but before your extension can be officially published, \n * it will additionally need a `description`, `iconURL`, and `insetIconURL`\n * @param addOns An optional collection of specifiers about what functionality this extension should have.\n * In this way, the functionality your Extension has access to (through its base class) is configurable.\n * \n * To see what `addOns` you can specify, place your cursor after the details parameter and type a double quote (\"). \n * Your IDE (code editor) should then suggest what values you can provide (e.g. `\"ui\"`, `\"customArguments\"`, `\"customSaveData\"`, etc.). \n * \n * **Note:** The order of the `addOns` does not matter.\n * @returns \n * @example Defining an extension with a name and description (and no add ons)\n * ```ts\n * export default class Example extends extension({ name: \"Some Name\", description: \"Some description...\" }) {\n *  ...\n * }\n * ```\n * @example Defining an extension with a name and UI functionality\n * ```ts\n * export default class Example extends extension({ name: \"Some Name\" }, \"ui\") {\n *  ...\n * }\n * ```\n * @example Defining an extension with a name and UI & custom arguments functionality\n * ```ts\n * export default class Example extends extension({ name: \"Some Name\" }, \"ui\", \"customArguments\") {\n *  ...\n * }\n * ```\n */\nexport const extension = <const TSupported extends readonly MixinName[]>(\n  details: ExtensionMenuDisplayDetails,\n  ...addOns: Writeable<TSupported>\n): ExtensionWithFunctionality<[...TSupported]> & typeof ExtensionBase => {\n\n  tryAnnounceDetails(details);\n\n  const Base = scratchInfo(supported(ExtensionBase, addOns)) as ExtensionWithFunctionality<[...TSupported]>;\n\n  if (!addOns) return Base;\n\n  addOns.push(...getDependencies(...addOns));\n\n  return Array.from(new Set([...addOns]))\n    .sort() // Ensure same order always\n    .map(key => optionalMixins[key])\n    .reduce((acc, mixin) => mixin(acc), Base)\n}\n\nexport const registerExtensionDefinitionCallback = (callback: (details: ExtensionMenuDisplayDetails) => void) =>\n  global[registerDetailsIdentifier] = (details) => {\n    if (!details) return;\n    callback(details);\n    delete global[registerDetailsIdentifier];\n  };\n\nexport type ExtensionConstructor<TSupported extends MixinName[] = []> = ReturnType<typeof extension<TSupported>>;\nexport type ExtensionInstance<TSupported extends MixinName[] = []> = InstanceType<ExtensionConstructor<TSupported>>;","import { ExtensionIntanceWithFunctionality, MixinName, optionalMixins } from \"..\";\nimport { ExtensionBaseConstructor } from \"../../ExtensionBase\";\n\n/**\n * Mixin the ability for extensions to check which optional mixins they support\n * @param Ctor \n * @returns \n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n */\nexport default function (Ctor: ExtensionBaseConstructor, supported: string[]) {\n  abstract class ExtensionWithConfigurableSupport extends Ctor {\n\n    supports<const TKey extends MixinName>(mixinName: TKey): this is typeof this & ExtensionIntanceWithFunctionality<[TKey]> {\n      return supported.includes(mixinName);\n    }\n  }\n\n  return ExtensionWithConfigurableSupport;\n}","import { ExtensionMenuDisplayDetails, ExtensionBlocks, BlockDefinitions, Translations } from \"$common/types\";\nimport { isFunction } from \"$common/utils\";\nimport { extension } from \"./index\";\nimport { getImplementationName } from \"./mixins/required/scratchInfo/index\";\n\n/**\n * @summary Base class for extensions implemented via the Typescript Extension Framework (using the \"generic\" strategy).\n * @example\n * class MyExtension extends Extension<\n *  { // Display details\n *    name: \"My Extension\",\n *    description: \"This is my extension\",\n *    iconURL: \"example.png\",\n *    insetIconURL: \"example.svg\"\n *  },\n *  { // Blocks\n *    myBlock: (someArg: number) => void;\n *  }\n * > {\n *  init(env: Environment): { ... };\n *  defineBlocks(): MyExtension[\"BlockDefinitions\"] { return ... }\n * }\n * @description Extension developers will create Typescript classes that `extend` (or 'inherit', or 'implement') this `Extension` class.\n *\n * In order to `extend` this class, you must first specify 2 generic type arguments, which effectively describe what kind of Extension you're implementing.\n *\n * More specifically, the 2 generic type arguments describe how this extension is presented to the user (by specifyng the details displayed in the Extensions Menu),\n * and what this Extension actually does (by specifying the blocks it will define).\n *\n * By declaring that we're extending an `Extension` with our specific generic type arguments,\n * Typescript holds us accountable to implement exactly what we said we would (all in order to make a working extension).\n *\n * This includes:\n * * Defining an `init` method, which is used INSTEAD of a constructor\n * * Defining a `defineBlocks` method that does just that: defines this extension's blocks\n * @template MenuDetails How the extension should display in the extensions menu\n * @template Blocks What kind of blocks this extension implements\n * @link https://www.typescriptlang.org/docs/handbook/2/generics.html Learn more about generics!\n */\n\nexport abstract class Extension<\n  MenuDetails extends ExtensionMenuDisplayDetails,\n  Blocks extends ExtensionBlocks\n> extends extension(undefined, \"ui\", \"customSaveData\", \"customArguments\") {\n\n  readonly BlockFunctions: Blocks;\n  readonly BlockDefinitions: BlockDefinitions<typeof this>;\n  readonly Translations: Translations<typeof this>;\n\n  /**\n   * @summary Extension member method that returns an object defining all blocks that belong to the extension.\n   * @description Every block your extension implements (defined by the second generic argument of the Extension class), will have an entry in the object return by this function.\n   * Each entry will either be an object or a function that returns an object that provides the:\n   * - type: the type of block\n   * - text: what is displayed on the block\n   * - arg or args: the arguments the block accepts\n   * - operation: the function that is called when the blocked is executed\n   * @example\n   * // Returning an object with two block definition function for 'someBlock'\n   * defineBlocks(): ExampleExtension[\"BlockDefinitions\"] {\n   *  return {\n   *    // Using object syntax\n   *    someBlock: {\n   *      type: BlockType.Reporter,\n   *      arg: ArgumentType.String,\n   *      text: (argument) => `Some text about ${argument}`,\n   *      operation: (argument) => {\n   *        // do something\n   *      }\n   *    },\n   *    // Using arrow function syntax\n   *    someBlock: (self: MyExtension) => ({\n   *      type: BlockType.Reporter,\n   *      arg: ArgumentType.String,\n   *      text: (argument) => `Some text about ${argument}`,\n   *      operation: (argument) => {\n   *        // do something\n   *      }\n   *    }),\n   *    // Using method function syntax\n   *    someOtherBlock(self: MyExtension) {\n   *      const type = BlockType.Reporter;\n   *      const arg = ArgumentType.String;\n   *      return {\n   *        arg, type,\n   *        text: (argument) => `Some text about ${argument}`,\n   *        operation: (argument) => {\n   *          // do something\n   *        }\n   *      }\n   *    }\n   *  }\n   * }\n   * @see BlockDefinitions\n   * @returns {BlockDefinitions<Blocks>} An object defining 'block definition' objects / functions for each block associated with this Extension.\n   */\n  abstract defineBlocks(): BlockDefinitions<Extension<MenuDetails, Blocks>>;\n\n  protected async internal_init() {\n    await super.internal_init();\n    const blocks = this.defineBlocks();\n    const self = this;\n    for (const opcode in blocks) {\n      this.validateOpcode(opcode);\n      const block = blocks[opcode];\n      const { operation, text, arg, args, type } = isFunction(block) ? block.call(this, this) : block;;\n      this.pushBlock(opcode,\n        arg\n          ? { text, type, arg }\n          : args\n            ? { text, type, args }\n            : { text, type },\n        operation);\n      const internalFuncName = getImplementationName(opcode);\n      (this as unknown)[opcode] = function () { return self[internalFuncName].call(self, ...arguments); };\n    }\n  }\n\n  private validateOpcode(opcode: string) {\n    if (!(opcode in this)) return;\n\n    const error = `The Extension has a member defined as '${opcode}', ` +\n      `but that name should be reserved for the opcode of the block with the same name. ` +\n      `Please rename your member, and attach the \"validateGenericExtension\" decorator to your class ` +\n      `so that this can be an error in your IDE and not at runtime.`;\n\n    throw new Error(error);\n  }\n}\n","import { ExtensionBlocks, ExtensionMenuDisplayDetails } from \"$common/types\";\nimport { TypedClassDecorator } from \".\";\nimport { ExtensionConstructor } from \"..\";\nimport { Extension } from \"../GenericExtension\";\n\n/**\n * Used to validate (through type assertion) that a Generic Extension does not\n * define any members with the same name as one of its blocks. \n * \n * The Generic Extension `Extension` class predates this requirment of having no overlap between the keys of blocks and the members of the associated Extension \n * class, so this decorator is provided as an easy way to check and confirm a Generic Extension class is compliant.\n * \n * Runtime errors will also be produced if this condition is not met.\n * @param failure If this extension is not valid, this will be a type that displays the member names causing trouble. \n * @returns \n */\nexport const validGenericExtension = <const T extends Extension<ExtensionMenuDisplayDetails, ExtensionBlocks>>\n  (...failure: T extends Extension<any, infer Blocks> ? T extends { [k in keyof Blocks]?: any } ? [{ [k in keyof Blocks & keyof T]: \"Your class cannot have a member with this name, as it's a name of one of your blocks.\" }] : [] : never):\n  TypedClassDecorator<T, ConstructorParameters<ExtensionConstructor>> => {\n  return function (value, context) { }\n}"],"names":["ExtensionFramework","exports","BlockType","Boolean","Button","Command","Conditional","Event","Hat","Loop","Reporter","ArgumentType","Angle","Color","Number","String","Matrix","Note","Image","Custom","StageLayering","BackgroundLayer","VideoLayer","PenLayer","SpriteLayer","LayerGroups","Language","Azeri","Bahasa_Indonesia","Cymraeg","Dansk","Deutsch","Eesti","English","Euskara","Gaeilge","Galego","Hrvatski","isiZulu","Italiano","Kiswahili","Magyar","Nederlands","Norsk_Nynorsk","Polski","Rapa_Nui","Suomi","Svenska","LanguageKeys","Object","keys","async","untilObject","getter","delay","timeout","value","Promise","resolve","clearTimeout","setTimeout","isString","query","isFunction","prototype","toString","call","Function","isPrimitive","identity","x","untilExternalScriptLoaded","url","scriptLoaded","reject","script","document","createElement","onload","onerror","src","body","appendChild","typesafeCall","fn","_this","args","set","container","key","assertSameLength","collections","size","reduce","length","add","Set","Error","openUIEvent","registerButtonCallbackEvent","customArgumentFlag","customArgumentCheck","dropdownStateFlag","dropdownEntryFlag","initDropdownState","openDropdownState","closeDropdownState","openUI","runtime","details","emit","registerButtonCallback","buttonID","callback","on","CssVar","constructor","root","this","get","parts","join","primary","secondary","tertiary","transparent","light","ui","text","motion","red","sound","control","data","pen","error","extensions","drop","color","modalOverlay","white","whiteDim","whiteTransparent","blackTransparent","primaryTransparent","lightTansparent","highlight","validRegEx","RegExp","invalidRegEx","guards","split","reverse","guardsRegEx","replaceAll","current","desired","saveDataKey","RGB_BLACK","r","g","b","RGB_WHITE","static","decimal","hex","substr","a","replace","m","result","exec","parseInt","rgb","decimalToHex","rgbToDecimal","hexToRgb","hsv","h","s","Math","max","min","v","i","floor","f","p","q","t","rgb0","rgb1","fraction1","fraction0","Cast","isNaN","n","toLowerCase","toRgbColorObject","substring","decimalToRgb","toNumber","val","trim","v1","v2","n1","n2","isWhiteSpace","NaN","s1","s2","Infinity","indexOf","LIST_INVALID","LIST_ALL","index","acceptAll","random","cast","castToType","argumentType","parseFloat","JSON","parse","toMatrix","toFlag","matrixString","Array","fill","map","matrix","flag","row","push","CustomArgumentManager","Map","pending","clearPending","setPending","update","entry","id","GetIdentifier","insert","request","tryResolve","getCurrentEntries","from","entries","filter","_","getEntry","requiresSave","saveTo","obj","SaveKey","loadFrom","forEach","purgeStaleIDs","IsIdentifier","startsWith","IdentifierPrefix","Date","getTime","renderToDropdown","compononentConstructor","props","dropdownContainerClass","elements","getElementsByClassName","console","target","anchor","children","centerDropdownButton","style","margin","paddingLeft","paddingRight","textAlign","className","styleMod","assert","MockBitmapAdapter","makeImage","makeCanvas","resize","image","newWidth","newHeight","stretchWidthCanvas","width","height","context","getContext","imageSmoothingEnabled","drawImage","stretchHeightCanvas","convertResolution1Bitmap","dataURI","toDataURL","getResizedWidthHeight","oldWidth","oldHeight","STAGE_WIDTH","STAGE_HEIGHT","imageRatio","importBitmap","newSize","convertDataURIToBinary","resizedDataURI","BASE64_MARKER","base64Index","base64","raw","window","atob","rawLength","array","Uint8Array","ArrayBuffer","charCodeAt","getUrlHelper","dimensions","canvas","setDimensions","hidden","getDataURL","save","clearRect","putImageData","restore","bitmapAdapter","urlHelper","isRenderedTarget","callingContext","DrowpdownOpen","DropdownClose","Init","menuProbe","isSimpleStatic","menu","isArray","isSimpleDynamic","isStaticWithReporters","isDynamicWithReporters","getMenuName","convertMenuItemsToString","item","asStaticMenu","items","acceptReporters","setMenu","options","menus","alreadyAddedIndex","menuIndex","addOptionsAndGetMenuName","format","identifier","description","isBlockGetter","getButtonID","opcode","extractHandlers","element","hasHandler","handler","getArgName","getArgumentType","arg","type","extractArgs","block","argsKey","zipArgs","names","types","handlers","name","convertToArgumentInfo","fromEntries","defaultValue","setDefaultValue","accumulation","undefined","getDefaultValue","convertToDisplayText","isDynamicText","textFunc","argPlaceholders","getImplementationName","wrapOperation","operation","supports","argsFromScratch","blockUtility","castedArguments","param","customArgumentManager","blockInfoOrGetter","internalFuncName","addInitializer","pushBlock","arguments","createBlockDefiner","objOrGetter","extension","argumentMethods","attachArgumentMethods","createBlockDecorator","params","indexKey","getItems","methods","method","bind","tryUpdateKey","asBlockMetaData","getBlockMetaData","metadata","blocks","_arguments","blockType","orderedNames","parseText","rest","extractMenuOptions","sort","convertAndInsertBlock","placeholder","template","getItemsPlaceholder","handlerPlaceholder","isDynamicMenu","menuName","acceptsReporters","validBlock","legacyBlock","blockMap","has","validArg","pair","legacy","modern","getDynamicMenuName","legacySupportMixin","Ctor","__isLegacy","orderArgumentNamesByBlock","getArgNames","getInfo","validatedInfo","info","super","validateAndAttach","metaData","legacyID","legacyBlocks","legacyMenus","getLegacyInfo","mutableBlocks","self","updates","legacyArgs","modernArgs","argNames","replaceAt","implementation","util","remap","remapper","menuUpdates","legacyName","modernName","flat","Format","optionalMixins","makeCustomArgument","component","initial","acceptReportersHandler","argumentManager","stringify","acceptsReports","getStaticDependencies","getOrCreateCustomArgumentManager","arr","processCustomArgumentHack","getComponent","extensionID","initialID","currentEntry","prevID","setEntry","setter","label","saveDataHandler","toSave","extensionIDs","saveData","hooks","onSave","load","saved","onLoad","video","videoDevice","ioDevices","getVideoFrame","getFrame","setVideoTransparency","transparency","setPreviewGhost","enableVideo","disableVideo","drawable","createDrawable","renderer","skin","createBitmapSkin","updateDrawableSkinId","setTransparency","updateDrawableEffect","setVisible","visible","updateDrawableVisible","updateBitmapSkin","destroy","destroyDrawable","destroySkin","addCostumes","action","warn","now","storage","dataFormat","DataFormat","PNG","assetType","AssetType","ImageBitmap","dataBuffer","asset","createAsset","assetId","costume","md5","addCostume","getCostumes","setCostume","legacySupport","ConstructableExtension","init","extensionManager","getExtensionManager","blockIconURI","extensionsMap","ExtensionBase","FORBIDDEN","optionalMixinDependencies","customArguments","registerDetailsIdentifier","addOns","global","tryAnnounceDetails","Base","supported","mixinName","includes","definition","convertToInfo","collectMenus","func","registerDynamicMenu","mixinNames","getDependencies","acc","mixin","Extension","internal_init","defineBlocks","validateOpcode","Branch","Exit","Enter","First","Second","Third","Fourth","Fifth","Sixth","Seventh","FrameworkID","RuntimeEvent","ScriptGlowOn","ScriptGlowOff","BlockGlowOn","BlockGlowOff","HasCloudDataUpdate","TurboModeOn","TurboModeOff","RecordingOn","RecordingOff","ProjectStart","ProjectRunStart","ProjectRunStop","ProjectStopAll","StopForTarget","VisualReport","ProjectLoaded","ProjectChanged","ToolboxExtensionsNeedUpdate","TargetsUpdate","MonitorsUpdate","BlockDragUpdate","BlockDragEnd","ExtensionAdded","ExtensionFieldAdded","PeripheralListUpdate","PeripheralConnected","PeripheralDisconnected","PeripheralRequestError","PeripheralConnectionLostError","PeripheralScanTimeout","MicListening","BlocksInfoUpdate","RuntimeStarted","RuntimeDisposed","BlocksNeedUpdate","SaveDataHandler","ScratchBlocksConstants","OutputShapeHexagonal","OutputShapeRound","OutputShapeSquare","TargetType","Sprite","Stage","VariableType","Scalar","List","BrooadcastMessage","activeClass","buttonBlock","color$1","copyTo","source","decode","matchAll","replacements","match","code","fromCharCode","modified","encode","invalidCharacters","char","fetchWithTimeout","resource","controller","AbortController","abort","response","fetch","signal","getTextFromMenuItem","getValueFromMenuItem","isValidID","test","flags","for","blockMethodBroker","definer","decorator","legacyDefinition","definitions","decorators","throwTypeOnlyError","legacyExtension","LegacySupport","legacyInfo","ExtensionWithLegacySupport","legacySupportWithInfoArgument","originalClassName","ReservedNames","Menus","Blocks","ArgumentNamesByBlock","loadExternalScript","onError","px","numberOf","reactiveInvoke","extensionAssignment","funcName","reactiveSet","propertyName","registerExtensionDefinitionCallback","rgbToHex","splitOnCapitals","tryCastToArgumentType","onFailure","untilCondition","condition","untilExternalGlobalVariableLoaded","globalVariableName","untilReady","ready","untilTimePassed","timeMs","validGenericExtension","failure","defineProperty"],"mappings":"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"}