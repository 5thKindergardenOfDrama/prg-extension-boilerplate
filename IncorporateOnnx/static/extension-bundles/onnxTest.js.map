{"version":3,"file":"onnxTest.js","sources":["../../../../extensions/src/common/onnx/index.ts","../../../../extensions/src/common/utils.ts","../../../../extensions/src/onnxTest/index.ts"],"sourcesContent":["import { loadExternalScript, untilReady } from \"$common/utils\";\nimport * as ort from \"onnxruntime-web\";\n\ntype OnWindow = { ort: typeof ort };\n\nexport class OnnxRuntime {\n  static FromCDN = \"https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js\";\n\n  ready = false;\n  private onnx: typeof ort;\n\n  get runtime(): Promise<typeof ort> { return untilReady(this).then(() => this.onnx); }\n\n  private get globalOnnx() { return (window as any as OnWindow).ort }\n\n  constructor() {\n    const onnx = this.globalOnnx;\n    onnx ? this.resolve() : loadExternalScript(OnnxRuntime.FromCDN, this.resolve.bind(this));\n  }\n\n  private resolve() {\n    this.ready = true;\n    this.onnx = this.globalOnnx;\n  }\n}","import { Extension } from \"./Extension\";\nimport { MenuItem } from \"./types\"\n\ntype FetchParams = {\n  request: Parameters<typeof fetch>[0],\n  options: Parameters<typeof fetch>[1]\n}\n\nexport const getValueFromMenuItem = <T>(item: MenuItem<T>) => typeof item === \"object\" ? (item as { value: T }).value : item;\n\nexport const getTextFromMenuItem = <T>(item: MenuItem<T>) => typeof item === \"object\" ? (item as { text: string }).text : item;\n\nexport async function fetchWithTimeout(\n  resource: FetchParams[\"request\"],\n  options: FetchParams[\"options\"] & { timeout: number }\n) {\n  const { timeout } = options;\n\n  const controller = new AbortController();\n  const id = setTimeout(() => controller.abort(), timeout);\n\n  const response = await fetch(resource, {\n    ...options,\n    signal: controller.signal\n  });\n\n  clearTimeout(id);\n\n  return response;\n}\n\nexport async function untilObject<T>(getter: () => T, delay: number = 100): Promise<T> {\n  let timeout: NodeJS.Timeout;\n  let value: T = getter();\n  while (!value) {\n    await new Promise(resolve => {\n      clearTimeout(timeout);\n      timeout = setTimeout(resolve, delay);\n    });\n    value = getter();\n  }\n  clearTimeout(timeout);\n  return value;\n}\n\nexport async function untilCondition(condition: () => boolean, delay: number = 100): Promise<void> {\n  let timeout: NodeJS.Timeout;\n  while (!condition()) {\n    await new Promise(resolve => {\n      clearTimeout(timeout);\n      timeout = setTimeout(resolve, delay);\n    });\n  }\n  clearTimeout(timeout);\n};\n\nexport async function untilReady<T extends { ready: boolean }>(obj: T, delay: number = 100): Promise<void> {\n  let timeout: NodeJS.Timeout;\n  while (!obj.ready) {\n    await new Promise(resolve => {\n      clearTimeout(timeout);\n      timeout = setTimeout(resolve, delay);\n    });\n  }\n  clearTimeout(timeout);\n};\n\nexport const isString = (query: any) => typeof query === 'string' || query instanceof String;\n\nexport const isFunction = (query: any) =>\n  Object.prototype.toString.call(query) === \"[object Function]\"\n  || \"function\" === typeof query\n  || query instanceof Function;\n\nexport const splitOnCapitals = (query: string) => query.split(/(?=[A-Z])/);\n\n/**\n * A type safe utility function for copy values from one object to another\n * @param param0 object containing the target to copy values to and the source of the values to copy\n */\nexport const copyTo = <TTarget extends object, TSource extends { [k in keyof TTarget]?: TTarget[k] }>({ target, source }: { target: TTarget, source: TSource }) => {\n  for (const key in source) {\n    if (!(key in target)) continue;\n    // @ts-ignore -- the types of the function should ensure this is valud TS\n    target[key] = source[key]\n  }\n}\n\nexport const identity = (x: any) => x;\n\nexport const loadExternalScript = (url: string, onLoad: () => void, onError?: () => void) => {\n  const script = document.createElement('script');\n\n  script.onload = onLoad;\n\n  script.onerror = onError ?? (() => {\n    throw new Error(`Error loading endpoint: ${url}`)\n  });\n\n  script.src = url;\n\n  document.body.appendChild(script);\n}","import { BlockType, Extension, Environment, } from \"$common\";\nimport { OnnxRuntime } from \"$common/onnx\";\n\ntype Details = {\n  name: \"Onnx Example\",\n  description: \"A demonstration that an onnx model can be used (not exciting, nor educationally valuable)\",\n  iconURL: \"\",\n  insetIconURL: \"\"\n};\n\n\ntype Blocks = {\n  test: () => void\n}\n\nexport default class ExtensionNameGoesHere extends Extension<Details, Blocks> {\n  onnx = new OnnxRuntime();\n\n  init(env: Environment) { }\n\n  defineBlocks(): ExtensionNameGoesHere[\"BlockDefinitions\"] {\n\n    return {\n      test: {\n        type: BlockType.Command,\n        text: \"eee\",\n        operation: async () => {\n          try {\n            const { InferenceSession, Tensor } = await this.onnx.runtime;\n\n            // create a new session and load the specific model.\n            //\n            // the model in this example contains a single MatMul node\n            // it has 2 inputs: 'a'(float32, 3x4) and 'b'(float32, 4x3)\n            // it has 1 output: 'c'(float32, 3x3)\n            const session = await InferenceSession.create(`${location.href}/static/model.onnx`);\n\n            // prepare inputs. a tensor need its corresponding TypedArray as data\n            const dataA = Float32Array.from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);\n            const dataB = Float32Array.from([10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]);\n            const tensorA = new Tensor('float32', dataA, [3, 4]);\n            const tensorB = new Tensor('float32', dataB, [4, 3]);\n\n            // prepare feeds. use model input names as keys.\n            const feeds = { a: tensorA, b: tensorB };\n\n            // feed inputs and run\n            const results = await session.run(feeds);\n\n            // read from results\n            const dataC = results.c.data;\n            console.log(dataC);\n          } catch (e) {\n            console.error(`failed to inference ONNX model: ${e}.`);\n          }\n        }\n      }\n    }\n  }\n}"],"names":["OnnxRuntime","static","this","FromCDN","__init","ready","runtime","async","obj","delay","timeout","Promise","resolve","clearTimeout","setTimeout","untilReady","then","onnx","globalOnnx","ort","constructor","prototype","call","url","onLoad","onError","script","document","createElement","lhs","rhsFn","onload","onerror","Error","src","body","appendChild","loadExternalScript","bind","__initStatic","ExtensionNameGoesHere","Extension","internal_getCodeGenArgs","id","name","blockIconURI","args","super","init","env","defineBlocks","test","type","BlockType","Command","text","operation","InferenceSession","Tensor","session","create","location","href","dataA","Float32Array","from","dataB","tensorA","feeds","a","b","dataC","run","c","data","console","log","e","error"],"mappings":"wCAKA,MAAAA,EACAC,sBAAAC,KAAAC,QAAA,8DAAA,CAEAC,SAAAF,KAAAG,OAAA,CAAA,CAGAC,cAAA,OC6CAC,eAAAC,EAAAC,EAAA,KACA,IAAAC,EACA,MAAAF,EAAAH,aACA,IAAAM,SAAAC,IACAC,aAAAH,GACAA,EAAAI,WAAAF,EAAAH,EAAA,IAGAI,aAAAH,EACA,CDtDAK,CAAAb,MAAAc,MAAA,IAAAd,KAAAe,MAAA,CAEAC,iBAAA,OAAA,OAAAC,GAAA,CAEAC,cAAApB,EAAAqB,UAAAjB,OAAAkB,KAAApB,MACAA,KAAAgB,WACAhB,KAAAU,UCyEA,EAAAW,EAAAC,EAAAC,KACA,MAAAC,EAAAC,SAAAC,cAAA,UA3FA,IAAAC,EAAAC,EA6FAJ,EAAAK,OAAAP,EAEAE,EAAAM,SA/FAF,EA+FA,IAAA,KACA,MAAA,IAAAG,MAAA,2BAAAV,IACA,EAjGA,OAAAM,EA+FAJ,GA/FAI,EAAAC,KAmGAJ,EAAAQ,IAAAX,EAEAI,SAAAQ,KAAAC,YAAAV,EAAA,EDpFAW,CAAArC,EAAAG,QAAAD,KAAAU,QAAA0B,KAAApC,MACA,CAEAU,UACAV,KAAAG,OAAA,EACAH,KAAAe,KAAAf,KAAAgB,UACA,EACAlB,EAAAuC,eETA,MAAAC,UAAAC,EAAAA,UACAC,0BAAA,MAAA,CAAAC,GAAA,WAAAC,KAAA,eAAAC,aAAA,ytCAAA,CACAzB,eAAA0B,GAAAC,SAAAD,GAAAN,EAAAnB,UAAAjB,OAAAkB,KAAApB,KAAA,CACAE,SAAAF,KAAAe,KAAA,IAAAjB,CAAA,CAEAgD,KAAAC,GAAA,CAEAC,eAEA,MAAA,CACAC,KAAA,CACAC,KAAAC,EAAAA,UAAAC,QACAC,KAAA,MACAC,UAAAjD,UACA,IACA,MAAAkD,iBAAAA,EAAAC,OAAAA,SAAAxD,KAAAe,KAAAX,QAOAqD,QAAAF,EAAAG,OAAA,GAAAC,SAAAC,0BAGAC,EAAAC,aAAAC,KAAA,CAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,GAAA,KACAC,EAAAF,aAAAC,KAAA,CAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,IAAA,IAAA,MACAE,EAAA,IAAAT,EAAA,UAAAK,EAAA,CAAA,EAAA,IAIAK,EAAA,CAAAC,EAAAF,EAAAG,EAHA,IAAAZ,EAAA,UAAAQ,EAAA,CAAA,EAAA,KASAK,SAHAZ,EAAAa,IAAAJ,IAGAK,EAAAC,KACAC,QAAAC,IAAAL,EAGA,CAFA,MAAAM,GACAF,QAAAG,MAAA,mCAAAD,KACA"}