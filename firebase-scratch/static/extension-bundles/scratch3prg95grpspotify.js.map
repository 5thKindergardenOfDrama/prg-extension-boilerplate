{"version":3,"file":"scratch3prg95grpspotify.js","sources":["../../../../extensions/scripts/node_modules/tslib/tslib.es6.js","../../../../extensions/src/scratch3_spotify/helper.ts","../../../../extensions/src/scratch3_spotify/index.ts"],"sourcesContent":["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.push(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.push(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n","export type TimingData = {\n  beats: number[],\n  crossfade_duration: number\n  downbeats: number[],\n  loop_duration: number,\n  start_time: number,\n  buffer: Uint8Array\n}\n\nexport const getTimingDataFromResponse = async (response: Response) => {\n  const arrayBuffer = await response.arrayBuffer();\n  const buffer = new Uint8Array(arrayBuffer);\n  const index = findTextInBuffer(buffer, \"GEOB\");\n  return getTimingDataFromBuffer(buffer, index + 1, 8);\n}\n\nconst findTextInBuffer = (buffer: Uint8Array, text: string) => {\n  for (let i = 0; i < buffer.length - text.length; i++) {\n    let match = true;\n    for (let j = 0; j < text.length; j++) {\n      const c = String.fromCharCode(buffer[i + j]);\n      if (c !== text[j]) {\n        match = false;\n        break;\n      }\n    }\n    if (match) {\n      return i;\n    }\n  }\n  return -1;\n};\n\nconst getTimingDataFromBuffer = (buffer: Uint8Array, start: number, which: number): TimingData => {\n  let sectionCount = 0;\n  let i;\n  for (i = start; i < buffer.length; i++) {\n    if (buffer[i] == 0) {\n      sectionCount++;\n    }\n    if (sectionCount >= which) {\n      break;\n    }\n  }\n  i++;\n  let content = \"\";\n  while (i < buffer.length) {\n    if (buffer[i] == 0) {\n      break;\n    }\n    var c = String.fromCharCode(buffer[i]);\n    content += c;\n    i++;\n  }\n  try {\n    return { ...JSON.parse(content), buffer } as TimingData;\n  } catch (e) {\n    return undefined;\n  }\n};","/// <reference types=\"spotify-api\" />\n\nimport { ArgumentType, Block, BlockType, Environment, Extension } from \"$common\";\n\nimport * as Tone from \"tone\";\nimport { asyncSome, fetchWithTimeout } from \"$common\";\nimport { getTimingDataFromResponse, TimingData } from \"./helper\";\n\n// TODO use fetch instead of nets\nconst SERVER_TIMEOUT = 10000; // 10 seconds\n\n/**\n * @summary This type describes how your extension will display in the extensions menu.\n * @description Like all Typescript type declarations, it looks and acts a lot like a javascript object.\n * It will be passed as the first generic argument to the Extension class that your specific extension `extends`\n * (see the class defintion below for more information on extending the Extension base class).\n * @see ExtensionMenuDisplayDetails for all possible display menu properties.\n * @link https://www.typescriptlang.org/docs/handbook/2/objects.html Learn more about object types! (This is specifically a 'type alias')\n * @link https://www.typescriptlang.org/docs/handbook/2/generics.html Learn more about generics!\n */\ntype Details = {\n    name: \"Spotify\";\n    description: \"This extension plays 30 second previews of songs from Spotify.\"; // It's a resurrection of Eric Rosenbaum's https://github.com/ericrosenbaum/spotify-extension/blob/gh-pages/extension.js\";\n    /**\n     * IMPORTANT! Place your icon image (typically a png) in the same directory as this index.ts file\n     */\n    iconURL: \"Replace with the name of your icon image file (which should be placed in the same directory as this file)\";\n    /**\n     * IMPORTANT! Place your inset icon image (typically an svg) in the same directory as this index.ts file\n     * NOTE: This icon will also appear on all of your extension's blocks\n     */\n    insetIconURL: \"Replace with the name of your inset icon image file (which should be placed in the same directory as this file)\";\n};\n\n/**\n * @summary This type describes all of the blocks your extension will/does implement.\n * @description As you can see, each block is represented as a function.\n * In typescript, you can specify a function in either of the following ways (and which you choose is a matter of preference):\n * - Arrow syntax: `nameOfFunction: (argument1Name: argument1Type, argument2Name: argument2Type, ...etc...) => returnType;`\n * - 'Method' syntax: `nameOfFunction(argument1Name: argument1Type, argument2Name: argument2Type, ...etc...): returnType;`\n *\n * The three included functions demonstrate some of the most common types of blocks: commands, reporters, and hats.\n * - Command functions/blocks take 0 or more arguments, and return nothing (indicated by the use of a `void` return type).\n * - Reporter functions/blocks also take 0 or more arguments, but they must return a value (likely a `string` or `number`).\n * - Hat functions/blocks also take 0 or more arguments, but they must return a boolean value.\n *\n * Feel free to delete these once you're ready to implement your own blocks.\n *\n * This type will be passed as the second generic argument to the Extension class that your specific extension 'extends'\n * (see the class defintion below for more information on extending the Extension base class).\n * @link https://www.typescriptlang.org/docs/handbook/2/functions.html Learn more about function types!\n * @link https://www.typescriptlang.org/docs/handbook/2/objects.html Learn more about object types! (This is specifically a 'type alias')\n * @link https://www.typescriptlang.org/docs/handbook/2/generics.html Learn more about generics!\n */\ntype Blocks = {\n    searchAndPlay(query: string): void;\n    searchAndPlayWait(query: string): void;\n    trackData(trackAttr: string): string;\n    stopMusic(): void;\n    musicStopped(): boolean;\n    everyBeat(): boolean;\n    everyBar(): boolean;\n    // leaving out fancy blocks that allow mixing for now\n    /* playNextBeat(): void;\n    playBeat(beatNum: number): void;\n    playBeatAndWait(beatNum: number): void;\n    currentBeat(): number; */\n};\n\n/**\n * @summary This is the class responsible for implementing the functionality of your blocks.\n * @description You'll notice that this class `extends` (or 'inherits') from the base `Extension` class.\n *\n * Hover over `Extension` to get a more in depth explanation of the base class, and what it means to `extend it`.\n */\nexport default class Spotify extends Extension<Details, Blocks> {\n    /**\n     * @summary A field to demonstrate how Typescript Class fields work\n     * @link https://www.typescriptlang.org/docs/handbook/2/classes.html#fields\n     */\n    prevQuery: string = \"\";\n    currentArtistName: string = \"no artist\";\n    currentTrackName: string = \"no track\";\n    currentAlbumName: string = \"no album\";\n\n    spotifyToken: AccessToken;\n\n    /**\n     *  player for playing entire track\n     */\n    player: Tone.Player = new Tone.Player().toDestination();\n\n    gain: Tone.Gain = new Tone.Gain();\n    audioContext: Tone.BaseContext = Tone.context;\n\n    /**\n     *  beat players for playing individual beat at a time\n     */\n    beatPlayers: Tone.Player[] = [];\n    trackTimingData: TimingData;\n    beatTimeouts: NodeJS.Timeout[] = [];\n    barTimeouts: NodeJS.Timeout[] = [];\n    trackTimeout: NodeJS.Timeout;\n    trackStartTime: number;\n\n    currentBeatPlayerIndex: number = 0;\n    currentBeatNum: number = 0;\n    beatFlag: boolean = false;\n    barFlag: boolean = false;\n    songFlag: boolean = false;\n    currentTrackDuration: number = 0;\n    trackTempo: number = 0;\n    numBeats: number = 0;\n\n    resolvePlayUntil: (value: void | PromiseLike<void>) => void;\n\n    async init(env: Environment) {\n        const options = { attack: 0.1, decay: 0, sustain: 1.0, release: 0.01 };\n        for (let i = 0; i < 4; i++) {\n            const beatPlayer = new Tone.Player();\n            const ampEnv = new Tone.AmplitudeEnvelope(options).toDestination();\n            beatPlayer.connect(ampEnv);\n            this.beatPlayers.push(beatPlayer);\n        }\n\n        Tone.Destination.chain(this.gain);\n\n        this.spotifyToken = await getAccessToken();\n\n        env.onStopSign(this.stopMusic);\n    }\n\n    playTrack() {\n        const { player, trackTimingData, currentTrackDuration } = this;\n        if (!player.buffer || !player.buffer.loaded || !trackTimingData) return;\n        const now = Tone.now();\n        player.start(now, 0, currentTrackDuration);\n        this.trackStartTime = now;\n        this.songFlag = true;\n        this.setupTimeouts();\n    }\n\n    clearTimeouts() {\n        clearTimeout(this.trackTimeout);\n        this.beatTimeouts.forEach(clearTimeout);\n        this.barTimeouts.forEach(clearTimeout);\n    }\n\n    resetTrackData() {\n        this.player = new Tone.Player().toDestination();\n        this.currentArtistName = \"no artist\";\n        this.currentTrackName = \"no track\";\n        this.currentAlbumName = \"no album\";\n        this.trackTempo = 0;\n    }\n\n    async requestSearch(query: string) {\n        this.player.stop();\n        this.clearTimeouts();\n\n        if (query == \"\") return;\n        this.currentBeatNum = 0;\n\n        const sameQuery = query === this.prevQuery;\n        if (sameQuery) return;\n\n        const url = `https://api.spotify.com/v1/search?q=${query}&type=track`;\n        const headers = { Authorization: \"Bearer \" + this.spotifyToken.value };\n\n        const response = await fetchWithTimeout(url, { headers, timeout: SERVER_TIMEOUT });\n\n        if (!response.ok) console.log(`Error with Spotify API query: ${response}`);\n\n        const { status } = response;\n        const json: SpotifyApi.TrackSearchResponse = await response.json();\n\n        const success = status === 200\n\n        if (!success) {\n            console.log(`Error with Spotify API query: ${json}`);\n            const tokenExpired = status === 401;\n\n            if (!tokenExpired) return console.error(`Spotify token error: ${status}`);\n\n            console.log(\"401 error\");\n            const newToken = await getAccessToken();\n            this.spotifyToken = newToken;\n            return;\n        }\n\n        this.prevQuery = query;\n        const trackObjects = json.tracks.items;\n\n        const noTracksFound = !trackObjects || trackObjects.length === 0;\n        if (noTracksFound) return this.resetTrackData();\n\n        const nonExplicitSongs = trackObjects.filter(track => !track.explicit);\n\n        if (nonExplicitSongs.length === 0) {\n            this.resetTrackData();\n            return console.log(\"no results without explicit lyrics\");\n        }\n\n        const timingFound = await asyncSome(nonExplicitSongs, this.tryGetTimingData.bind(this));\n\n        if (!timingFound) {\n            console.log(\"no more results\");\n            this.resetTrackData();\n        }\n    };\n\n    async tryGetTimingData({ artists, name, album, preview_url }: SpotifyApi.TrackObjectFull) {\n        const success = await this.tryGetTrackTimingData(preview_url);\n\n        if (!success) {\n            console.log(`No timing data for ${name}.`);\n            return false;\n        }\n\n        this.currentArtistName = artists[0].name;\n        this.currentTrackName = name;\n        this.currentAlbumName = album.name;\n        return true;\n    }\n\n    async tryGetTrackTimingData(url: string) {\n        if (!url) return false;\n        const response = await fetch(url);\n\n        this.trackTimingData = await getTimingDataFromResponse(response);\n\n        if (!this.trackTimingData) return false;\n\n        const { beats, loop_duration, buffer } = this.trackTimingData;\n\n        let sum = 0;\n        for (let i = 0; i < beats.length - 1; i++) {\n            sum += beats[i + 1] - beats[i];\n        }\n\n        const averageBeatLength = sum / (beats.length - 1);\n        const tempoEstimate = 60 / averageBeatLength;\n        this.trackTempo = tempoEstimate;\n\n        // use the loop duration to set the number of beats\n        const durationLessThanBeat = () => ({ beat }: { beat: number }) => loop_duration < beat;\n        const { index } = beats.map((beat, index) => ({ beat, index })).find(durationLessThanBeat);\n        this.numBeats = index;\n\n        await this.audioContext.rawContext.decodeAudioData(\n            buffer.buffer,\n            (audioBuffer) => {\n                const { player, beatPlayers } = this;\n                player.buffer.set(audioBuffer);\n                this.currentTrackDuration = loop_duration;\n                beatPlayers.forEach(({ buffer }) => buffer.set(audioBuffer));\n            }\n        );\n\n        return true;\n    }\n\n    setupTimeouts() {\n        const { numBeats, trackTimingData } = this;\n        const { beats, downbeats } = trackTimingData;\n\n        // events on each beat\n        this.beatTimeouts = [];\n        for (let i = 0; i < numBeats; i++) {\n            const callback = (value: number) => {\n                this.beatFlag = true;\n                this.currentBeatNum = value;\n            }\n            const duration = (beats[i] - 0.1) * 1000;\n            const timeout = setTimeout(callback.bind(this), duration, i);\n            this.beatTimeouts.push(timeout);\n        }\n\n        // events on each bar\n        this.barTimeouts = [];\n        for (let i = 0; i < downbeats.length; i++) {\n            if (downbeats[i] < beats[numBeats - 1]) {\n                const duration = (downbeats[i] - 0.1) * 1000;\n                const timeout = setTimeout(() => this.barFlag = true, duration);\n                this.barTimeouts.push(timeout);\n            }\n        }\n    }\n\n    stopMusic() {\n        this.player.stop();\n        this.clearTimeouts();\n        this.songFlag = false;\n        if (this.resolvePlayUntil) this.resolvePlayUntil();\n    }\n\n    defineBlocks(): Spotify[\"BlockDefinitions\"] {\n        return {\n            searchAndPlay: searchAndPlay,\n            searchAndPlayWait: searchAndPlayWait,\n            stopMusic: stopMusic,\n            musicStopped: musicStopped,\n            everyBeat: everyBeat,\n            everyBar: everyBar,\n            trackData: getTrackData,\n            // leaving out fancy blocks that allow mixing for now\n            /*playNextBeat: playNextBeat,\n            playBeat: playBeat,\n            playBeatAndWait: playBeatAndWait,\n            currentBeat: getCurrentBeat, */\n        };\n    }\n}\n\nconst currentTimeSec = (): number => {\n    return new Date().getTime() / 1000;\n};\n\ntype AccessToken = {\n    expirationTime: number;\n    value: string;\n};\n\nconst getAccessToken = async (): Promise<AccessToken> => {\n    const url = \"https://u61j2fb017.execute-api.us-east-1.amazonaws.com/prod/get-spotify-token\";\n    const response = await fetchWithTimeout(url, { timeout: SERVER_TIMEOUT });\n\n    if (!response.ok) {\n        console.error(`Spotify token error: ${response}`);\n        return undefined;\n    }\n\n    const { status } = response;\n    const success = status === 200;\n\n    if (!success) {\n        console.error(`Spotify token error ${status}: ${response.statusText}`);\n        return undefined;\n    }\n\n    const { token }: { token: string } = await response.json();\n\n    return { expirationTime: currentTimeSec() + 3600, value: token };\n};\n\nconst refreshAccessTokenIfNeeded = (\n    token: AccessToken\n): Promise<AccessToken> => {\n    return new Promise((resolve, reject) => {\n        if (currentTimeSec() > token.expirationTime) {\n            getAccessToken().then((newToken) => {\n                token = newToken;\n                console.log(\"token expired, got a new one\");\n                resolve(token);\n            });\n        } else {\n            resolve(token);\n        }\n    });\n};\n\ntype SearchAndPlayBlock = Blocks[\"searchAndPlay\"];\nconst searchAndPlay = (extension: Spotify) => ({\n    type: BlockType.Command,\n    arg: { type: ArgumentType.String, defaultValue: \"tacos\" },\n    text: (searchQuery) => `play music like ${searchQuery}`,\n    operation: async function (searchQuery) {\n        let token = await refreshAccessTokenIfNeeded(extension.spotifyToken);\n        extension.spotifyToken = token;\n        await extension.requestSearch(searchQuery);\n        await extension.playTrack();\n\n        setTimeout(() => {\n            extension.songFlag = false;\n        }, extension.currentTrackDuration * 1000);\n    },\n});\n\ntype SearchAndPlayWaitBlock = Blocks[\"searchAndPlayWait\"];\nconst searchAndPlayWait = (extension: Spotify) => ({\n    type: BlockType.Command,\n    arg: { type: ArgumentType.String, defaultValue: \"Lauryn Hill\" },\n    text: (searchQuery) => `play music like ${searchQuery} until done`,\n    operation: async function (searchQuery) {\n        let token = await refreshAccessTokenIfNeeded(extension.spotifyToken);\n        extension.spotifyToken = token;\n        await extension.requestSearch(searchQuery);\n        await extension.playTrack();\n\n        return new Promise<void>((resolve) => {\n            extension.resolvePlayUntil = resolve;\n            setTimeout(extension.resolvePlayUntil, extension.currentTrackDuration * 1000);\n        });\n    },\n});\n\ntype StopMusicBlock = Blocks[\"stopMusic\"];\nconst stopMusic = (extension: Spotify) => ({\n    type: BlockType.Command,\n    text: `stop the music`,\n    operation: extension.stopMusic,\n});\n\ntype TrackData = Blocks[\"trackData\"];\nconst getTrackData = () => ({\n    type: BlockType.Reporter,\n    arg: {\n        type: ArgumentType.String,\n        defaultValue: \"full\",\n        options: [\"track\", \"artist\", \"album\", \"full\"],\n    },\n    text: (requestedData) => `${requestedData} name`,\n    operation: function (requestedData) {\n        switch (requestedData) {\n            case \"track\":\n                return this.currentTrackName;\n            case \"artist\":\n                return this.currentArtistName;\n            case \"album\":\n                return this.currentAlbumName;\n            case \"full\":\n                return `${this.currentTrackName} by ${this.currentArtistName} from ${this.currentAlbumName}`;\n            default:\n                return \"\";\n        }\n    },\n});\n\ntype EveryBeat = Blocks[\"everyBeat\"];\nconst everyBeat = (extension: Spotify) => ({\n    type: BlockType.Hat,\n    text: `every beat`,\n    operation: function () {\n        console.log(\"Every beat\");\n        if (extension.beatFlag) setTimeout(() => extension.beatFlag = false, 60);\n        return extension.beatFlag;\n    },\n});\n\ntype EveryBar = Blocks[\"everyBar\"];\nconst everyBar = (extension: Spotify) => ({\n    type: BlockType.Hat,\n    text: `every 4 beats`,\n    operation: function () {\n        if (extension.barFlag) setTimeout(() => extension.barFlag = false, 60);\n        return extension.barFlag;\n    },\n});\n\ntype MusicStopped = Blocks[\"musicStopped\"];\nconst musicStopped = (extension: Spotify) => ({\n    type: BlockType.Boolean,\n    text: `music stopped?`,\n    operation: () => !extension.songFlag,\n});\n"],"names":["scratch3prg95grpspotify","exports","$common","Tone","_interopNamespace","e","__esModule","n","Object","create","keys","forEach","k","d","getOwnPropertyDescriptor","defineProperty","get","enumerable","freeze","Tone__namespace","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","rejected","result","done","then","apply","findTextInBuffer","buffer","text","i","length","match","j","String","fromCharCode","getTimingDataFromBuffer","start","which","sectionCount","content","assign","JSON","parse","Spotify","Extension","constructor","this","prevQuery","currentArtistName","currentTrackName","currentAlbumName","player","Player","toDestination","gain","Gain","audioContext","context","beatPlayers","beatTimeouts","barTimeouts","currentBeatPlayerIndex","currentBeatNum","beatFlag","barFlag","songFlag","currentTrackDuration","trackTempo","numBeats","init","env","options","attack","decay","sustain","release","beatPlayer","ampEnv","AmplitudeEnvelope","connect","push","Destination","chain","spotifyToken","getAccessToken","onStopSign","stopMusic","playTrack","trackTimingData","loaded","now","trackStartTime","setupTimeouts","clearTimeouts","clearTimeout","trackTimeout","resetTrackData","requestSearch","query","stop","url","headers","Authorization","response","fetchWithTimeout","timeout","ok","console","log","status","json","error","newToken","trackObjects","tracks","items","nonExplicitSongs","filter","track","explicit","asyncSome","tryGetTimingData","bind","artists","name","album","preview_url","tryGetTrackTimingData","fetch","arrayBuffer","Uint8Array","index","getTimingDataFromResponse","beats","loop_duration","sum","tempoEstimate","map","beat","find","rawContext","decodeAudioData","audioBuffer","set","downbeats","callback","duration","setTimeout","resolvePlayUntil","defineBlocks","searchAndPlay","searchAndPlayWait","musicStopped","everyBeat","everyBar","trackData","getTrackData","currentTimeSec","Date","getTime","statusText","token","expirationTime","refreshAccessTokenIfNeeded","extension","type","BlockType","Command","arg","ArgumentType","defaultValue","searchQuery","operation","Reporter","requestedData","Hat","Boolean","ExtensionFramework"],"mappings":"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"}